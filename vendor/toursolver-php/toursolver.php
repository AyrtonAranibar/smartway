<?php

/**
 *
 * 
 *
 * Generated by <a href="http://enunciate.webcohesion.com">Enunciate</a>.
 *
 */
 

namespace Com\Geoconcept\Ebooking\Api\Model;

/**
 * (no documentation provided)
 */
class Phone
{

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $number;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $country;

    /**
     * Constructs a Phone from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getNumber()
    {
        return $this->number;
    }

    /**
     * (no documentation provided)
     *
     * @param string $number
     */
    public function setNumber($number)
    {
        $this->number = $number;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getCountry()
    {
        return $this->country;
    }

    /**
     * (no documentation provided)
     *
     * @param string $country
     */
    public function setCountry($country)
    {
        $this->country = $country;
    }

    /**
     * Initializes this Phone from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of Phone from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'number') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->number = $child;
            $happened = true;
        }
        else if (($xml->localName == 'country') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->country = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of Phone from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this Phone to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->number) {
            $writer->startElementNs(null, 'number', null);
            $writer->text($this->number);
            $writer->endElement();
        }
        if ($this->country) {
            $writer->startElementNs(null, 'country', null);
            $writer->text($this->country);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Ebooking\Api\Model;

/**
 * (no documentation provided)
 */
class ScheduleTimeWindow
{

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Ebooking\Api\Model\ScheduleTime
     */
    private $end;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $maxAppointments;

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Ebooking\Api\Model\ScheduleTime
     */
    private $start;

    /**
     * Constructs a ScheduleTimeWindow from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Ebooking\Api\Model\ScheduleTime
     */
    public function getEnd()
    {
        return $this->end;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Ebooking\Api\Model\ScheduleTime $end
     */
    public function setEnd($end)
    {
        $this->end = $end;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getMaxAppointments()
    {
        return $this->maxAppointments;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $maxAppointments
     */
    public function setMaxAppointments($maxAppointments)
    {
        $this->maxAppointments = $maxAppointments;
    }
    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Ebooking\Api\Model\ScheduleTime
     */
    public function getStart()
    {
        return $this->start;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Ebooking\Api\Model\ScheduleTime $start
     */
    public function setStart($start)
    {
        $this->start = $start;
    }

    /**
     * Initializes this ScheduleTimeWindow from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of ScheduleTimeWindow from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'end') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Ebooking\Api\Model\ScheduleTime($xml);
            $this->end = $child;
            $happened = true;
        }
        else if (($xml->localName == 'maxAppointments') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->maxAppointments = $child;
            $happened = true;
        }
        else if (($xml->localName == 'start') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Ebooking\Api\Model\ScheduleTime($xml);
            $this->start = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of ScheduleTimeWindow from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this ScheduleTimeWindow to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->end) {
            $writer->startElementNs(null, 'end', null);
            $this->end->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->maxAppointments) {
            $writer->startElementNs(null, 'maxAppointments', null);
            $writer->text($this->maxAppointments);
            $writer->endElement();
        }
        if ($this->start) {
            $writer->startElementNs(null, 'start', null);
            $this->start->writeXmlContents($writer);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Ebooking\Api\Model;

/**
 * (no documentation provided)
 */
class SchedulingCustomer
{

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $id;

    /**
     * (no documentation provided)
     *
     * @var array
     */
    private $extra;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $name;

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Ebooking\Api\Model\Phone
     */
    private $phone;

    /**
     * Constructs a SchedulingCustomer from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * (no documentation provided)
     *
     * @param string $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }
    /**
     * (no documentation provided)
     *
     * @return array
     */
    public function getExtra()
    {
        return $this->extra;
    }

    /**
     * (no documentation provided)
     *
     * @param array $extra
     */
    public function setExtra($extra)
    {
        $this->extra = $extra;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * (no documentation provided)
     *
     * @param string $name
     */
    public function setName($name)
    {
        $this->name = $name;
    }
    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Ebooking\Api\Model\Phone
     */
    public function getPhone()
    {
        return $this->phone;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Ebooking\Api\Model\Phone $phone
     */
    public function setPhone($phone)
    {
        $this->phone = $phone;
    }

    /**
     * Initializes this SchedulingCustomer from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of SchedulingCustomer from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'extra') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->extra = $child;
            $happened = true;
        }
        else if (($xml->localName == 'name') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->name = $child;
            $happened = true;
        }
        else if (($xml->localName == 'phone') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Ebooking\Api\Model\Phone($xml);
            $this->phone = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of SchedulingCustomer from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this SchedulingCustomer to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->id) {
            $writer->startElementNs(null, 'id', null);
            $writer->text($this->id);
            $writer->endElement();
        }
        if ($this->extra) {
            $writer->startElementNs(null, 'extra', null);
            $writer->text($this->extra);
            $writer->endElement();
        }
        if ($this->name) {
            $writer->startElementNs(null, 'name', null);
            $writer->text($this->name);
            $writer->endElement();
        }
        if ($this->phone) {
            $writer->startElementNs(null, 'phone', null);
            $this->phone->writeXmlContents($writer);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Ebooking\Api\Model;

/**
 * (no documentation provided)
 */
class TimeWindow
{

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $wishedEnd;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $wishedStart;

    /**
     * Constructs a TimeWindow from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getWishedEnd()
    {
        return $this->wishedEnd;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $wishedEnd
     */
    public function setWishedEnd($wishedEnd)
    {
        $this->wishedEnd = $wishedEnd;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getWishedStart()
    {
        return $this->wishedStart;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $wishedStart
     */
    public function setWishedStart($wishedStart)
    {
        $this->wishedStart = $wishedStart;
    }

    /**
     * Initializes this TimeWindow from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of TimeWindow from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'wishedEnd') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->wishedEnd = $child;
            $happened = true;
        }
        else if (($xml->localName == 'wishedStart') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->wishedStart = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of TimeWindow from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this TimeWindow to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->wishedEnd) {
            $writer->startElementNs(null, 'wishedEnd', null);
            $writer->text($this->wishedEnd);
            $writer->endElement();
        }
        if ($this->wishedStart) {
            $writer->startElementNs(null, 'wishedStart', null);
            $writer->text($this->wishedStart);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Mycustomers\Api\Model;

/**
 * (no documentation provided)
 */
class ClientBaseEntity
{

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $updateDate;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $mobile;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $givenName;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $lastFeedback;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $stateFull;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $countryFull;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $ownerId;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $phone;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $email;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $possibleVisitDays3;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $possibleVisitDays2;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $possibleVisitDays1;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $timeWindowEndTime3;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $minSpacing;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $lastComment;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $nextVisitDate;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $possibleVisitDays4;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $color;

    /**
     * (no documentation provided)
     *
     * @var boolean
     */
    private $isCustomer;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $startsBefore;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $lastVisitDate;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $frequencyType;

    /**
     * (no documentation provided)
     *
     * @var double[]
     */
    private $quantities;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $additionalAddress;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $timeWindowEndTime2;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $title;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $description;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $occupation;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $designation;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $externRef;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $geocodeType;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $lastUpdateUser;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $timeWindowEndTime4;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $sector;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $streetAndNumber;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $y;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $timeWindowBeginTime3;

    /**
     * (no documentation provided)
     *
     * @var boolean
     */
    private $wholeVisitInTimeWindow;

    /**
     * (no documentation provided)
     *
     * @var boolean
     */
    private $useManualPositioning;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $surName;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $city;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $timeWindowBeginTime1;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $lastVisitId;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $zipCode;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $creationDate;

    /**
     * (no documentation provided)
     *
     * @var boolean
     */
    private $getNotification;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $requiredSkills;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $maxSpacing;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $x;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $id;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $photoURL;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $type;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $frequency;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $fixedVisitDuration;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $timeWindowBeginTime2;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $timeWindowEndTime1;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $agency;

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Mycustomers\Api\Model\ManualPosition
     */
    private $manualPosition;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $timeWindowBeginTime4;

    /**
     * Constructs a ClientBaseEntity from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getUpdateDate()
    {
        return $this->updateDate;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $updateDate
     */
    public function setUpdateDate($updateDate)
    {
        $this->updateDate = $updateDate;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getMobile()
    {
        return $this->mobile;
    }

    /**
     * (no documentation provided)
     *
     * @param string $mobile
     */
    public function setMobile($mobile)
    {
        $this->mobile = $mobile;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getGivenName()
    {
        return $this->givenName;
    }

    /**
     * (no documentation provided)
     *
     * @param string $givenName
     */
    public function setGivenName($givenName)
    {
        $this->givenName = $givenName;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getLastFeedback()
    {
        return $this->lastFeedback;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $lastFeedback
     */
    public function setLastFeedback($lastFeedback)
    {
        $this->lastFeedback = $lastFeedback;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getStateFull()
    {
        return $this->stateFull;
    }

    /**
     * (no documentation provided)
     *
     * @param string $stateFull
     */
    public function setStateFull($stateFull)
    {
        $this->stateFull = $stateFull;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getCountryFull()
    {
        return $this->countryFull;
    }

    /**
     * (no documentation provided)
     *
     * @param string $countryFull
     */
    public function setCountryFull($countryFull)
    {
        $this->countryFull = $countryFull;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getOwnerId()
    {
        return $this->ownerId;
    }

    /**
     * (no documentation provided)
     *
     * @param string $ownerId
     */
    public function setOwnerId($ownerId)
    {
        $this->ownerId = $ownerId;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getPhone()
    {
        return $this->phone;
    }

    /**
     * (no documentation provided)
     *
     * @param string $phone
     */
    public function setPhone($phone)
    {
        $this->phone = $phone;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getEmail()
    {
        return $this->email;
    }

    /**
     * (no documentation provided)
     *
     * @param string $email
     */
    public function setEmail($email)
    {
        $this->email = $email;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getPossibleVisitDays3()
    {
        return $this->possibleVisitDays3;
    }

    /**
     * (no documentation provided)
     *
     * @param string $possibleVisitDays3
     */
    public function setPossibleVisitDays3($possibleVisitDays3)
    {
        $this->possibleVisitDays3 = $possibleVisitDays3;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getPossibleVisitDays2()
    {
        return $this->possibleVisitDays2;
    }

    /**
     * (no documentation provided)
     *
     * @param string $possibleVisitDays2
     */
    public function setPossibleVisitDays2($possibleVisitDays2)
    {
        $this->possibleVisitDays2 = $possibleVisitDays2;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getPossibleVisitDays1()
    {
        return $this->possibleVisitDays1;
    }

    /**
     * (no documentation provided)
     *
     * @param string $possibleVisitDays1
     */
    public function setPossibleVisitDays1($possibleVisitDays1)
    {
        $this->possibleVisitDays1 = $possibleVisitDays1;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getTimeWindowEndTime3()
    {
        return $this->timeWindowEndTime3;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $timeWindowEndTime3
     */
    public function setTimeWindowEndTime3($timeWindowEndTime3)
    {
        $this->timeWindowEndTime3 = $timeWindowEndTime3;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getMinSpacing()
    {
        return $this->minSpacing;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $minSpacing
     */
    public function setMinSpacing($minSpacing)
    {
        $this->minSpacing = $minSpacing;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getLastComment()
    {
        return $this->lastComment;
    }

    /**
     * (no documentation provided)
     *
     * @param string $lastComment
     */
    public function setLastComment($lastComment)
    {
        $this->lastComment = $lastComment;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getNextVisitDate()
    {
        return $this->nextVisitDate;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $nextVisitDate
     */
    public function setNextVisitDate($nextVisitDate)
    {
        $this->nextVisitDate = $nextVisitDate;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getPossibleVisitDays4()
    {
        return $this->possibleVisitDays4;
    }

    /**
     * (no documentation provided)
     *
     * @param string $possibleVisitDays4
     */
    public function setPossibleVisitDays4($possibleVisitDays4)
    {
        $this->possibleVisitDays4 = $possibleVisitDays4;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getColor()
    {
        return $this->color;
    }

    /**
     * (no documentation provided)
     *
     * @param string $color
     */
    public function setColor($color)
    {
        $this->color = $color;
    }
    /**
     * (no documentation provided)
     *
     * @return boolean
     */
    public function getIsCustomer()
    {
        return $this->isCustomer;
    }

    /**
     * (no documentation provided)
     *
     * @param boolean $isCustomer
     */
    public function setIsCustomer($isCustomer)
    {
        $this->isCustomer = $isCustomer;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getStartsBefore()
    {
        return $this->startsBefore;
    }

    /**
     * (no documentation provided)
     *
     * @param string $startsBefore
     */
    public function setStartsBefore($startsBefore)
    {
        $this->startsBefore = $startsBefore;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getLastVisitDate()
    {
        return $this->lastVisitDate;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $lastVisitDate
     */
    public function setLastVisitDate($lastVisitDate)
    {
        $this->lastVisitDate = $lastVisitDate;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getFrequencyType()
    {
        return $this->frequencyType;
    }

    /**
     * (no documentation provided)
     *
     * @param string $frequencyType
     */
    public function setFrequencyType($frequencyType)
    {
        $this->frequencyType = $frequencyType;
    }
    /**
     * (no documentation provided)
     *
     * @return double[]
     */
    public function getQuantities()
    {
        return $this->quantities;
    }

    /**
     * (no documentation provided)
     *
     * @param double[] $quantities
     */
    public function setQuantities($quantities)
    {
        $this->quantities = $quantities;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getAdditionalAddress()
    {
        return $this->additionalAddress;
    }

    /**
     * (no documentation provided)
     *
     * @param string $additionalAddress
     */
    public function setAdditionalAddress($additionalAddress)
    {
        $this->additionalAddress = $additionalAddress;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getTimeWindowEndTime2()
    {
        return $this->timeWindowEndTime2;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $timeWindowEndTime2
     */
    public function setTimeWindowEndTime2($timeWindowEndTime2)
    {
        $this->timeWindowEndTime2 = $timeWindowEndTime2;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getTitle()
    {
        return $this->title;
    }

    /**
     * (no documentation provided)
     *
     * @param string $title
     */
    public function setTitle($title)
    {
        $this->title = $title;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getDescription()
    {
        return $this->description;
    }

    /**
     * (no documentation provided)
     *
     * @param string $description
     */
    public function setDescription($description)
    {
        $this->description = $description;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getOccupation()
    {
        return $this->occupation;
    }

    /**
     * (no documentation provided)
     *
     * @param string $occupation
     */
    public function setOccupation($occupation)
    {
        $this->occupation = $occupation;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getDesignation()
    {
        return $this->designation;
    }

    /**
     * (no documentation provided)
     *
     * @param string $designation
     */
    public function setDesignation($designation)
    {
        $this->designation = $designation;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getExternRef()
    {
        return $this->externRef;
    }

    /**
     * (no documentation provided)
     *
     * @param string $externRef
     */
    public function setExternRef($externRef)
    {
        $this->externRef = $externRef;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getGeocodeType()
    {
        return $this->geocodeType;
    }

    /**
     * (no documentation provided)
     *
     * @param string $geocodeType
     */
    public function setGeocodeType($geocodeType)
    {
        $this->geocodeType = $geocodeType;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getLastUpdateUser()
    {
        return $this->lastUpdateUser;
    }

    /**
     * (no documentation provided)
     *
     * @param string $lastUpdateUser
     */
    public function setLastUpdateUser($lastUpdateUser)
    {
        $this->lastUpdateUser = $lastUpdateUser;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getTimeWindowEndTime4()
    {
        return $this->timeWindowEndTime4;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $timeWindowEndTime4
     */
    public function setTimeWindowEndTime4($timeWindowEndTime4)
    {
        $this->timeWindowEndTime4 = $timeWindowEndTime4;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getSector()
    {
        return $this->sector;
    }

    /**
     * (no documentation provided)
     *
     * @param string $sector
     */
    public function setSector($sector)
    {
        $this->sector = $sector;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getStreetAndNumber()
    {
        return $this->streetAndNumber;
    }

    /**
     * (no documentation provided)
     *
     * @param string $streetAndNumber
     */
    public function setStreetAndNumber($streetAndNumber)
    {
        $this->streetAndNumber = $streetAndNumber;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getY()
    {
        return $this->y;
    }

    /**
     * (no documentation provided)
     *
     * @param double $y
     */
    public function setY($y)
    {
        $this->y = $y;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getTimeWindowBeginTime3()
    {
        return $this->timeWindowBeginTime3;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $timeWindowBeginTime3
     */
    public function setTimeWindowBeginTime3($timeWindowBeginTime3)
    {
        $this->timeWindowBeginTime3 = $timeWindowBeginTime3;
    }
    /**
     * (no documentation provided)
     *
     * @return boolean
     */
    public function getWholeVisitInTimeWindow()
    {
        return $this->wholeVisitInTimeWindow;
    }

    /**
     * (no documentation provided)
     *
     * @param boolean $wholeVisitInTimeWindow
     */
    public function setWholeVisitInTimeWindow($wholeVisitInTimeWindow)
    {
        $this->wholeVisitInTimeWindow = $wholeVisitInTimeWindow;
    }
    /**
     * (no documentation provided)
     *
     * @return boolean
     */
    public function getUseManualPositioning()
    {
        return $this->useManualPositioning;
    }

    /**
     * (no documentation provided)
     *
     * @param boolean $useManualPositioning
     */
    public function setUseManualPositioning($useManualPositioning)
    {
        $this->useManualPositioning = $useManualPositioning;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getSurName()
    {
        return $this->surName;
    }

    /**
     * (no documentation provided)
     *
     * @param string $surName
     */
    public function setSurName($surName)
    {
        $this->surName = $surName;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getCity()
    {
        return $this->city;
    }

    /**
     * (no documentation provided)
     *
     * @param string $city
     */
    public function setCity($city)
    {
        $this->city = $city;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getTimeWindowBeginTime1()
    {
        return $this->timeWindowBeginTime1;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $timeWindowBeginTime1
     */
    public function setTimeWindowBeginTime1($timeWindowBeginTime1)
    {
        $this->timeWindowBeginTime1 = $timeWindowBeginTime1;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getLastVisitId()
    {
        return $this->lastVisitId;
    }

    /**
     * (no documentation provided)
     *
     * @param string $lastVisitId
     */
    public function setLastVisitId($lastVisitId)
    {
        $this->lastVisitId = $lastVisitId;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getZipCode()
    {
        return $this->zipCode;
    }

    /**
     * (no documentation provided)
     *
     * @param string $zipCode
     */
    public function setZipCode($zipCode)
    {
        $this->zipCode = $zipCode;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getCreationDate()
    {
        return $this->creationDate;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $creationDate
     */
    public function setCreationDate($creationDate)
    {
        $this->creationDate = $creationDate;
    }
    /**
     * (no documentation provided)
     *
     * @return boolean
     */
    public function getGetNotification()
    {
        return $this->getNotification;
    }

    /**
     * (no documentation provided)
     *
     * @param boolean $getNotification
     */
    public function setGetNotification($getNotification)
    {
        $this->getNotification = $getNotification;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getRequiredSkills()
    {
        return $this->requiredSkills;
    }

    /**
     * (no documentation provided)
     *
     * @param string $requiredSkills
     */
    public function setRequiredSkills($requiredSkills)
    {
        $this->requiredSkills = $requiredSkills;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getMaxSpacing()
    {
        return $this->maxSpacing;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $maxSpacing
     */
    public function setMaxSpacing($maxSpacing)
    {
        $this->maxSpacing = $maxSpacing;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getX()
    {
        return $this->x;
    }

    /**
     * (no documentation provided)
     *
     * @param double $x
     */
    public function setX($x)
    {
        $this->x = $x;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * (no documentation provided)
     *
     * @param string $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getPhotoURL()
    {
        return $this->photoURL;
    }

    /**
     * (no documentation provided)
     *
     * @param string $photoURL
     */
    public function setPhotoURL($photoURL)
    {
        $this->photoURL = $photoURL;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getType()
    {
        return $this->type;
    }

    /**
     * (no documentation provided)
     *
     * @param string $type
     */
    public function setType($type)
    {
        $this->type = $type;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getFrequency()
    {
        return $this->frequency;
    }

    /**
     * (no documentation provided)
     *
     * @param string $frequency
     */
    public function setFrequency($frequency)
    {
        $this->frequency = $frequency;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getFixedVisitDuration()
    {
        return $this->fixedVisitDuration;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $fixedVisitDuration
     */
    public function setFixedVisitDuration($fixedVisitDuration)
    {
        $this->fixedVisitDuration = $fixedVisitDuration;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getTimeWindowBeginTime2()
    {
        return $this->timeWindowBeginTime2;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $timeWindowBeginTime2
     */
    public function setTimeWindowBeginTime2($timeWindowBeginTime2)
    {
        $this->timeWindowBeginTime2 = $timeWindowBeginTime2;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getTimeWindowEndTime1()
    {
        return $this->timeWindowEndTime1;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $timeWindowEndTime1
     */
    public function setTimeWindowEndTime1($timeWindowEndTime1)
    {
        $this->timeWindowEndTime1 = $timeWindowEndTime1;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getAgency()
    {
        return $this->agency;
    }

    /**
     * (no documentation provided)
     *
     * @param string $agency
     */
    public function setAgency($agency)
    {
        $this->agency = $agency;
    }
    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Mycustomers\Api\Model\ManualPosition
     */
    public function getManualPosition()
    {
        return $this->manualPosition;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Mycustomers\Api\Model\ManualPosition $manualPosition
     */
    public function setManualPosition($manualPosition)
    {
        $this->manualPosition = $manualPosition;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getTimeWindowBeginTime4()
    {
        return $this->timeWindowBeginTime4;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $timeWindowBeginTime4
     */
    public function setTimeWindowBeginTime4($timeWindowBeginTime4)
    {
        $this->timeWindowBeginTime4 = $timeWindowBeginTime4;
    }

    /**
     * Initializes this ClientBaseEntity from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of ClientBaseEntity from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'updateDate') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->updateDate = $child;
            $happened = true;
        }
        else if (($xml->localName == 'mobile') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->mobile = $child;
            $happened = true;
        }
        else if (($xml->localName == 'givenName') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->givenName = $child;
            $happened = true;
        }
        else if (($xml->localName == 'lastFeedback') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->lastFeedback = $child;
            $happened = true;
        }
        else if (($xml->localName == 'stateFull') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->stateFull = $child;
            $happened = true;
        }
        else if (($xml->localName == 'countryFull') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->countryFull = $child;
            $happened = true;
        }
        else if (($xml->localName == 'ownerId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->ownerId = $child;
            $happened = true;
        }
        else if (($xml->localName == 'phone') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->phone = $child;
            $happened = true;
        }
        else if (($xml->localName == 'email') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->email = $child;
            $happened = true;
        }
        else if (($xml->localName == 'possibleVisitDays3') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->possibleVisitDays3 = $child;
            $happened = true;
        }
        else if (($xml->localName == 'possibleVisitDays2') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->possibleVisitDays2 = $child;
            $happened = true;
        }
        else if (($xml->localName == 'possibleVisitDays1') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->possibleVisitDays1 = $child;
            $happened = true;
        }
        else if (($xml->localName == 'timeWindowEndTime3') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->timeWindowEndTime3 = $child;
            $happened = true;
        }
        else if (($xml->localName == 'minSpacing') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->minSpacing = $child;
            $happened = true;
        }
        else if (($xml->localName == 'lastComment') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->lastComment = $child;
            $happened = true;
        }
        else if (($xml->localName == 'nextVisitDate') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->nextVisitDate = $child;
            $happened = true;
        }
        else if (($xml->localName == 'possibleVisitDays4') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->possibleVisitDays4 = $child;
            $happened = true;
        }
        else if (($xml->localName == 'color') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->color = $child;
            $happened = true;
        }
        else if (($xml->localName == 'isCustomer') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->isCustomer = $child;
            $happened = true;
        }
        else if (($xml->localName == 'startsBefore') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->startsBefore = $child;
            $happened = true;
        }
        else if (($xml->localName == 'lastVisitDate') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->lastVisitDate = $child;
            $happened = true;
        }
        else if (($xml->localName == 'frequencyType') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->frequencyType = $child;
            $happened = true;
        }
        else if (($xml->localName == 'quantities') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->quantities)) {
                $this->quantities = array();
            }
            array_push($this->quantities, $child);
            $happened = true;
        }
        else if (($xml->localName == 'additionalAddress') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->additionalAddress = $child;
            $happened = true;
        }
        else if (($xml->localName == 'timeWindowEndTime2') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->timeWindowEndTime2 = $child;
            $happened = true;
        }
        else if (($xml->localName == 'title') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->title = $child;
            $happened = true;
        }
        else if (($xml->localName == 'description') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->description = $child;
            $happened = true;
        }
        else if (($xml->localName == 'occupation') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->occupation = $child;
            $happened = true;
        }
        else if (($xml->localName == 'designation') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->designation = $child;
            $happened = true;
        }
        else if (($xml->localName == 'externRef') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->externRef = $child;
            $happened = true;
        }
        else if (($xml->localName == 'geocodeType') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->geocodeType = $child;
            $happened = true;
        }
        else if (($xml->localName == 'lastUpdateUser') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->lastUpdateUser = $child;
            $happened = true;
        }
        else if (($xml->localName == 'timeWindowEndTime4') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->timeWindowEndTime4 = $child;
            $happened = true;
        }
        else if (($xml->localName == 'sector') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->sector = $child;
            $happened = true;
        }
        else if (($xml->localName == 'streetAndNumber') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->streetAndNumber = $child;
            $happened = true;
        }
        else if (($xml->localName == 'y') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->y = $child;
            $happened = true;
        }
        else if (($xml->localName == 'timeWindowBeginTime3') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->timeWindowBeginTime3 = $child;
            $happened = true;
        }
        else if (($xml->localName == 'wholeVisitInTimeWindow') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->wholeVisitInTimeWindow = $child;
            $happened = true;
        }
        else if (($xml->localName == 'useManualPositioning') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->useManualPositioning = $child;
            $happened = true;
        }
        else if (($xml->localName == 'surName') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->surName = $child;
            $happened = true;
        }
        else if (($xml->localName == 'city') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->city = $child;
            $happened = true;
        }
        else if (($xml->localName == 'timeWindowBeginTime1') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->timeWindowBeginTime1 = $child;
            $happened = true;
        }
        else if (($xml->localName == 'lastVisitId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->lastVisitId = $child;
            $happened = true;
        }
        else if (($xml->localName == 'zipCode') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->zipCode = $child;
            $happened = true;
        }
        else if (($xml->localName == 'creationDate') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->creationDate = $child;
            $happened = true;
        }
        else if (($xml->localName == 'getNotification') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->getNotification = $child;
            $happened = true;
        }
        else if (($xml->localName == 'requiredSkills') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->requiredSkills = $child;
            $happened = true;
        }
        else if (($xml->localName == 'maxSpacing') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->maxSpacing = $child;
            $happened = true;
        }
        else if (($xml->localName == 'x') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->x = $child;
            $happened = true;
        }
        else if (($xml->localName == 'id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'photoURL') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->photoURL = $child;
            $happened = true;
        }
        else if (($xml->localName == 'type') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->type = $child;
            $happened = true;
        }
        else if (($xml->localName == 'frequency') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->frequency = $child;
            $happened = true;
        }
        else if (($xml->localName == 'fixedVisitDuration') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->fixedVisitDuration = $child;
            $happened = true;
        }
        else if (($xml->localName == 'timeWindowBeginTime2') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->timeWindowBeginTime2 = $child;
            $happened = true;
        }
        else if (($xml->localName == 'timeWindowEndTime1') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->timeWindowEndTime1 = $child;
            $happened = true;
        }
        else if (($xml->localName == 'agency') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->agency = $child;
            $happened = true;
        }
        else if (($xml->localName == 'manualPosition') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Mycustomers\Api\Model\ManualPosition($xml);
            $this->manualPosition = $child;
            $happened = true;
        }
        else if (($xml->localName == 'timeWindowBeginTime4') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->timeWindowBeginTime4 = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of ClientBaseEntity from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this ClientBaseEntity to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->updateDate) {
            $writer->startElementNs(null, 'updateDate', null);
            $writer->text($this->updateDate);
            $writer->endElement();
        }
        if ($this->mobile) {
            $writer->startElementNs(null, 'mobile', null);
            $writer->text($this->mobile);
            $writer->endElement();
        }
        if ($this->givenName) {
            $writer->startElementNs(null, 'givenName', null);
            $writer->text($this->givenName);
            $writer->endElement();
        }
        if ($this->lastFeedback) {
            $writer->startElementNs(null, 'lastFeedback', null);
            $writer->text($this->lastFeedback);
            $writer->endElement();
        }
        if ($this->stateFull) {
            $writer->startElementNs(null, 'stateFull', null);
            $writer->text($this->stateFull);
            $writer->endElement();
        }
        if ($this->countryFull) {
            $writer->startElementNs(null, 'countryFull', null);
            $writer->text($this->countryFull);
            $writer->endElement();
        }
        if ($this->ownerId) {
            $writer->startElementNs(null, 'ownerId', null);
            $writer->text($this->ownerId);
            $writer->endElement();
        }
        if ($this->phone) {
            $writer->startElementNs(null, 'phone', null);
            $writer->text($this->phone);
            $writer->endElement();
        }
        if ($this->email) {
            $writer->startElementNs(null, 'email', null);
            $writer->text($this->email);
            $writer->endElement();
        }
        if ($this->possibleVisitDays3) {
            $writer->startElementNs(null, 'possibleVisitDays3', null);
            $writer->text($this->possibleVisitDays3);
            $writer->endElement();
        }
        if ($this->possibleVisitDays2) {
            $writer->startElementNs(null, 'possibleVisitDays2', null);
            $writer->text($this->possibleVisitDays2);
            $writer->endElement();
        }
        if ($this->possibleVisitDays1) {
            $writer->startElementNs(null, 'possibleVisitDays1', null);
            $writer->text($this->possibleVisitDays1);
            $writer->endElement();
        }
        if ($this->timeWindowEndTime3) {
            $writer->startElementNs(null, 'timeWindowEndTime3', null);
            $writer->text($this->timeWindowEndTime3);
            $writer->endElement();
        }
        if ($this->minSpacing) {
            $writer->startElementNs(null, 'minSpacing', null);
            $writer->text($this->minSpacing);
            $writer->endElement();
        }
        if ($this->lastComment) {
            $writer->startElementNs(null, 'lastComment', null);
            $writer->text($this->lastComment);
            $writer->endElement();
        }
        if ($this->nextVisitDate) {
            $writer->startElementNs(null, 'nextVisitDate', null);
            $writer->text($this->nextVisitDate);
            $writer->endElement();
        }
        if ($this->possibleVisitDays4) {
            $writer->startElementNs(null, 'possibleVisitDays4', null);
            $writer->text($this->possibleVisitDays4);
            $writer->endElement();
        }
        if ($this->color) {
            $writer->startElementNs(null, 'color', null);
            $writer->text($this->color);
            $writer->endElement();
        }
        if ($this->isCustomer) {
            $writer->startElementNs(null, 'isCustomer', null);
            $writer->text($this->isCustomer);
            $writer->endElement();
        }
        if ($this->startsBefore) {
            $writer->startElementNs(null, 'startsBefore', null);
            $writer->text($this->startsBefore);
            $writer->endElement();
        }
        if ($this->lastVisitDate) {
            $writer->startElementNs(null, 'lastVisitDate', null);
            $writer->text($this->lastVisitDate);
            $writer->endElement();
        }
        if ($this->frequencyType) {
            $writer->startElementNs(null, 'frequencyType', null);
            $writer->text($this->frequencyType);
            $writer->endElement();
        }
        if ($this->quantities) {
            foreach ($this->quantities as $i => $x) {
                $writer->startElementNs(null, 'quantities', null);
                $writer->text($x);
                $writer->endElement();
            }
        }
        if ($this->additionalAddress) {
            $writer->startElementNs(null, 'additionalAddress', null);
            $writer->text($this->additionalAddress);
            $writer->endElement();
        }
        if ($this->timeWindowEndTime2) {
            $writer->startElementNs(null, 'timeWindowEndTime2', null);
            $writer->text($this->timeWindowEndTime2);
            $writer->endElement();
        }
        if ($this->title) {
            $writer->startElementNs(null, 'title', null);
            $writer->text($this->title);
            $writer->endElement();
        }
        if ($this->description) {
            $writer->startElementNs(null, 'description', null);
            $writer->text($this->description);
            $writer->endElement();
        }
        if ($this->occupation) {
            $writer->startElementNs(null, 'occupation', null);
            $writer->text($this->occupation);
            $writer->endElement();
        }
        if ($this->designation) {
            $writer->startElementNs(null, 'designation', null);
            $writer->text($this->designation);
            $writer->endElement();
        }
        if ($this->externRef) {
            $writer->startElementNs(null, 'externRef', null);
            $writer->text($this->externRef);
            $writer->endElement();
        }
        if ($this->geocodeType) {
            $writer->startElementNs(null, 'geocodeType', null);
            $writer->text($this->geocodeType);
            $writer->endElement();
        }
        if ($this->lastUpdateUser) {
            $writer->startElementNs(null, 'lastUpdateUser', null);
            $writer->text($this->lastUpdateUser);
            $writer->endElement();
        }
        if ($this->timeWindowEndTime4) {
            $writer->startElementNs(null, 'timeWindowEndTime4', null);
            $writer->text($this->timeWindowEndTime4);
            $writer->endElement();
        }
        if ($this->sector) {
            $writer->startElementNs(null, 'sector', null);
            $writer->text($this->sector);
            $writer->endElement();
        }
        if ($this->streetAndNumber) {
            $writer->startElementNs(null, 'streetAndNumber', null);
            $writer->text($this->streetAndNumber);
            $writer->endElement();
        }
        if ($this->y) {
            $writer->startElementNs(null, 'y', null);
            $writer->text($this->y);
            $writer->endElement();
        }
        if ($this->timeWindowBeginTime3) {
            $writer->startElementNs(null, 'timeWindowBeginTime3', null);
            $writer->text($this->timeWindowBeginTime3);
            $writer->endElement();
        }
        if ($this->wholeVisitInTimeWindow) {
            $writer->startElementNs(null, 'wholeVisitInTimeWindow', null);
            $writer->text($this->wholeVisitInTimeWindow);
            $writer->endElement();
        }
        if ($this->useManualPositioning) {
            $writer->startElementNs(null, 'useManualPositioning', null);
            $writer->text($this->useManualPositioning);
            $writer->endElement();
        }
        if ($this->surName) {
            $writer->startElementNs(null, 'surName', null);
            $writer->text($this->surName);
            $writer->endElement();
        }
        if ($this->city) {
            $writer->startElementNs(null, 'city', null);
            $writer->text($this->city);
            $writer->endElement();
        }
        if ($this->timeWindowBeginTime1) {
            $writer->startElementNs(null, 'timeWindowBeginTime1', null);
            $writer->text($this->timeWindowBeginTime1);
            $writer->endElement();
        }
        if ($this->lastVisitId) {
            $writer->startElementNs(null, 'lastVisitId', null);
            $writer->text($this->lastVisitId);
            $writer->endElement();
        }
        if ($this->zipCode) {
            $writer->startElementNs(null, 'zipCode', null);
            $writer->text($this->zipCode);
            $writer->endElement();
        }
        if ($this->creationDate) {
            $writer->startElementNs(null, 'creationDate', null);
            $writer->text($this->creationDate);
            $writer->endElement();
        }
        if ($this->getNotification) {
            $writer->startElementNs(null, 'getNotification', null);
            $writer->text($this->getNotification);
            $writer->endElement();
        }
        if ($this->requiredSkills) {
            $writer->startElementNs(null, 'requiredSkills', null);
            $writer->text($this->requiredSkills);
            $writer->endElement();
        }
        if ($this->maxSpacing) {
            $writer->startElementNs(null, 'maxSpacing', null);
            $writer->text($this->maxSpacing);
            $writer->endElement();
        }
        if ($this->x) {
            $writer->startElementNs(null, 'x', null);
            $writer->text($this->x);
            $writer->endElement();
        }
        if ($this->id) {
            $writer->startElementNs(null, 'id', null);
            $writer->text($this->id);
            $writer->endElement();
        }
        if ($this->photoURL) {
            $writer->startElementNs(null, 'photoURL', null);
            $writer->text($this->photoURL);
            $writer->endElement();
        }
        if ($this->type) {
            $writer->startElementNs(null, 'type', null);
            $writer->text($this->type);
            $writer->endElement();
        }
        if ($this->frequency) {
            $writer->startElementNs(null, 'frequency', null);
            $writer->text($this->frequency);
            $writer->endElement();
        }
        if ($this->fixedVisitDuration) {
            $writer->startElementNs(null, 'fixedVisitDuration', null);
            $writer->text($this->fixedVisitDuration);
            $writer->endElement();
        }
        if ($this->timeWindowBeginTime2) {
            $writer->startElementNs(null, 'timeWindowBeginTime2', null);
            $writer->text($this->timeWindowBeginTime2);
            $writer->endElement();
        }
        if ($this->timeWindowEndTime1) {
            $writer->startElementNs(null, 'timeWindowEndTime1', null);
            $writer->text($this->timeWindowEndTime1);
            $writer->endElement();
        }
        if ($this->agency) {
            $writer->startElementNs(null, 'agency', null);
            $writer->text($this->agency);
            $writer->endElement();
        }
        if ($this->manualPosition) {
            $writer->startElementNs(null, 'manualPosition', null);
            $this->manualPosition->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->timeWindowBeginTime4) {
            $writer->startElementNs(null, 'timeWindowBeginTime4', null);
            $writer->text($this->timeWindowBeginTime4);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Export;

/**
 * (no documentation provided)
 */
class GpsPosition
{

    /**
     * last position recording date
     *
     * @var integer
     */
    private $date;

    /**
     * Longitude
     *
     * @var double
     */
    private $lon;

    /**
     * Latitude
     *
     * @var double
     */
    private $lat;

    /**
     * GPS positioning accuracy (radius in meters)
     *
     * @var double
     */
    private $accuracy;

    /**
     * Private life status in Mobile App.
     * If true, it means that mobile App is currently in Private life mode,
     * therefore this position is the last known position before the Private life switch.
     *
     * @var boolean
     */
    private $privateMode;

    /**
     * GPS status of the device
     *
     * @var string
     */
    private $gpsStatus;

    /**
     * Battery level of the device (0 to 1)
     *
     * @var double
     */
    private $batteryLevel;

    /**
     * heading (direction) from north, in degrees
     *
     * @var double
     */
    private $heading;

    /**
     * Constructs a GpsPosition from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * last position recording date
     *
     * @return integer
     */
    public function getDate()
    {
        return $this->date;
    }

    /**
     * last position recording date
     *
     * @param integer $date
     */
    public function setDate($date)
    {
        $this->date = $date;
    }
    /**
     * Longitude
     *
     * @return double
     */
    public function getLon()
    {
        return $this->lon;
    }

    /**
     * Longitude
     *
     * @param double $lon
     */
    public function setLon($lon)
    {
        $this->lon = $lon;
    }
    /**
     * Latitude
     *
     * @return double
     */
    public function getLat()
    {
        return $this->lat;
    }

    /**
     * Latitude
     *
     * @param double $lat
     */
    public function setLat($lat)
    {
        $this->lat = $lat;
    }
    /**
     * GPS positioning accuracy (radius in meters)
     *
     * @return double
     */
    public function getAccuracy()
    {
        return $this->accuracy;
    }

    /**
     * GPS positioning accuracy (radius in meters)
     *
     * @param double $accuracy
     */
    public function setAccuracy($accuracy)
    {
        $this->accuracy = $accuracy;
    }
    /**
     * Private life status in Mobile App.
       * If true, it means that mobile App is currently in Private life mode,
       * therefore this position is the last known position before the Private life switch.
     *
     * @return boolean
     */
    public function getPrivateMode()
    {
        return $this->privateMode;
    }

    /**
     * Private life status in Mobile App.
       * If true, it means that mobile App is currently in Private life mode,
       * therefore this position is the last known position before the Private life switch.
     *
     * @param boolean $privateMode
     */
    public function setPrivateMode($privateMode)
    {
        $this->privateMode = $privateMode;
    }
    /**
     * GPS status of the device
     *
     * @return string
     */
    public function getGpsStatus()
    {
        return $this->gpsStatus;
    }

    /**
     * GPS status of the device
     *
     * @param string $gpsStatus
     */
    public function setGpsStatus($gpsStatus)
    {
        $this->gpsStatus = $gpsStatus;
    }
    /**
     * Battery level of the device (0 to 1)
     *
     * @return double
     */
    public function getBatteryLevel()
    {
        return $this->batteryLevel;
    }

    /**
     * Battery level of the device (0 to 1)
     *
     * @param double $batteryLevel
     */
    public function setBatteryLevel($batteryLevel)
    {
        $this->batteryLevel = $batteryLevel;
    }
    /**
     * heading (direction) from north, in degrees
     *
     * @return double
     */
    public function getHeading()
    {
        return $this->heading;
    }

    /**
     * heading (direction) from north, in degrees
     *
     * @param double $heading
     */
    public function setHeading($heading)
    {
        $this->heading = $heading;
    }

    /**
     * Initializes this GpsPosition from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of GpsPosition from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'date') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->date = $child;
            $happened = true;
        }
        else if (($xml->localName == 'lon') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->lon = $child;
            $happened = true;
        }
        else if (($xml->localName == 'lat') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->lat = $child;
            $happened = true;
        }
        else if (($xml->localName == 'accuracy') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->accuracy = $child;
            $happened = true;
        }
        else if (($xml->localName == 'privateMode') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->privateMode = $child;
            $happened = true;
        }
        else if (($xml->localName == 'gpsStatus') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->gpsStatus = $child;
            $happened = true;
        }
        else if (($xml->localName == 'batteryLevel') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->batteryLevel = $child;
            $happened = true;
        }
        else if (($xml->localName == 'heading') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->heading = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of GpsPosition from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this GpsPosition to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->date) {
            $writer->startElementNs(null, 'date', null);
            $writer->text($this->date);
            $writer->endElement();
        }
        if ($this->lon) {
            $writer->startElementNs(null, 'lon', null);
            $writer->text($this->lon);
            $writer->endElement();
        }
        if ($this->lat) {
            $writer->startElementNs(null, 'lat', null);
            $writer->text($this->lat);
            $writer->endElement();
        }
        if ($this->accuracy) {
            $writer->startElementNs(null, 'accuracy', null);
            $writer->text($this->accuracy);
            $writer->endElement();
        }
        if ($this->privateMode) {
            $writer->startElementNs(null, 'privateMode', null);
            $writer->text($this->privateMode);
            $writer->endElement();
        }
        if ($this->gpsStatus) {
            $writer->startElementNs(null, 'gpsStatus', null);
            $writer->text($this->gpsStatus);
            $writer->endElement();
        }
        if ($this->batteryLevel) {
            $writer->startElementNs(null, 'batteryLevel', null);
            $writer->text($this->batteryLevel);
            $writer->endElement();
        }
        if ($this->heading) {
            $writer->startElementNs(null, 'heading', null);
            $writer->text($this->heading);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Mycustomers\Api\Model;

/**
 * (no documentation provided)
 */
class ManualPosition
{

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $when;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $who;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $x;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $y;

    /**
     * Constructs a ManualPosition from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getWhen()
    {
        return $this->when;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $when
     */
    public function setWhen($when)
    {
        $this->when = $when;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getWho()
    {
        return $this->who;
    }

    /**
     * (no documentation provided)
     *
     * @param string $who
     */
    public function setWho($who)
    {
        $this->who = $who;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getX()
    {
        return $this->x;
    }

    /**
     * (no documentation provided)
     *
     * @param double $x
     */
    public function setX($x)
    {
        $this->x = $x;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getY()
    {
        return $this->y;
    }

    /**
     * (no documentation provided)
     *
     * @param double $y
     */
    public function setY($y)
    {
        $this->y = $y;
    }

    /**
     * Initializes this ManualPosition from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of ManualPosition from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'when') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->when = $child;
            $happened = true;
        }
        else if (($xml->localName == 'who') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->who = $child;
            $happened = true;
        }
        else if (($xml->localName == 'x') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->x = $child;
            $happened = true;
        }
        else if (($xml->localName == 'y') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->y = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of ManualPosition from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this ManualPosition to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->when) {
            $writer->startElementNs(null, 'when', null);
            $writer->text($this->when);
            $writer->endElement();
        }
        if ($this->who) {
            $writer->startElementNs(null, 'who', null);
            $writer->text($this->who);
            $writer->endElement();
        }
        if ($this->x) {
            $writer->startElementNs(null, 'x', null);
            $writer->text($this->x);
            $writer->endElement();
        }
        if ($this->y) {
            $writer->startElementNs(null, 'y', null);
            $writer->text($this->y);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Ebooking\Api\Model;

/**
 * (no documentation provided)
 */
class SchedulingRequest
{

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Ebooking\Api\Model\TimeWindow
     */
    private $timeWindow;

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Ebooking\Api\Model\SchedulingAddress
     */
    private $address;

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Ebooking\Api\Model\SchedulingCustomer
     */
    private $customer;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $duration;

    /**
     * Constructs a SchedulingRequest from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Ebooking\Api\Model\TimeWindow
     */
    public function getTimeWindow()
    {
        return $this->timeWindow;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Ebooking\Api\Model\TimeWindow $timeWindow
     */
    public function setTimeWindow($timeWindow)
    {
        $this->timeWindow = $timeWindow;
    }
    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Ebooking\Api\Model\SchedulingAddress
     */
    public function getAddress()
    {
        return $this->address;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Ebooking\Api\Model\SchedulingAddress $address
     */
    public function setAddress($address)
    {
        $this->address = $address;
    }
    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Ebooking\Api\Model\SchedulingCustomer
     */
    public function getCustomer()
    {
        return $this->customer;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Ebooking\Api\Model\SchedulingCustomer $customer
     */
    public function setCustomer($customer)
    {
        $this->customer = $customer;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getDuration()
    {
        return $this->duration;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $duration
     */
    public function setDuration($duration)
    {
        $this->duration = $duration;
    }

    /**
     * Initializes this SchedulingRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of SchedulingRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'timeWindow') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Ebooking\Api\Model\TimeWindow($xml);
            $this->timeWindow = $child;
            $happened = true;
        }
        else if (($xml->localName == 'address') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Ebooking\Api\Model\SchedulingAddress($xml);
            $this->address = $child;
            $happened = true;
        }
        else if (($xml->localName == 'customer') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Ebooking\Api\Model\SchedulingCustomer($xml);
            $this->customer = $child;
            $happened = true;
        }
        else if (($xml->localName == 'duration') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->duration = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of SchedulingRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this SchedulingRequest to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->timeWindow) {
            $writer->startElementNs(null, 'timeWindow', null);
            $this->timeWindow->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->address) {
            $writer->startElementNs(null, 'address', null);
            $this->address->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->customer) {
            $writer->startElementNs(null, 'customer', null);
            $this->customer->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->duration) {
            $writer->startElementNs(null, 'duration', null);
            $writer->text($this->duration);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Ebooking\Api\Model;

/**
 * (no documentation provided)
 */
class SchedulingAddress
{

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $postalCode;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $geocodeScore;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $x;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $region;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $countryCode;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $geocodeType;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $streetAndNumber;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $complement;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $city;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $y;

    /**
     * Constructs a SchedulingAddress from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getPostalCode()
    {
        return $this->postalCode;
    }

    /**
     * (no documentation provided)
     *
     * @param string $postalCode
     */
    public function setPostalCode($postalCode)
    {
        $this->postalCode = $postalCode;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getGeocodeScore()
    {
        return $this->geocodeScore;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $geocodeScore
     */
    public function setGeocodeScore($geocodeScore)
    {
        $this->geocodeScore = $geocodeScore;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getX()
    {
        return $this->x;
    }

    /**
     * (no documentation provided)
     *
     * @param double $x
     */
    public function setX($x)
    {
        $this->x = $x;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getRegion()
    {
        return $this->region;
    }

    /**
     * (no documentation provided)
     *
     * @param string $region
     */
    public function setRegion($region)
    {
        $this->region = $region;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getCountryCode()
    {
        return $this->countryCode;
    }

    /**
     * (no documentation provided)
     *
     * @param string $countryCode
     */
    public function setCountryCode($countryCode)
    {
        $this->countryCode = $countryCode;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getGeocodeType()
    {
        return $this->geocodeType;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $geocodeType
     */
    public function setGeocodeType($geocodeType)
    {
        $this->geocodeType = $geocodeType;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getStreetAndNumber()
    {
        return $this->streetAndNumber;
    }

    /**
     * (no documentation provided)
     *
     * @param string $streetAndNumber
     */
    public function setStreetAndNumber($streetAndNumber)
    {
        $this->streetAndNumber = $streetAndNumber;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getComplement()
    {
        return $this->complement;
    }

    /**
     * (no documentation provided)
     *
     * @param string $complement
     */
    public function setComplement($complement)
    {
        $this->complement = $complement;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getCity()
    {
        return $this->city;
    }

    /**
     * (no documentation provided)
     *
     * @param string $city
     */
    public function setCity($city)
    {
        $this->city = $city;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getY()
    {
        return $this->y;
    }

    /**
     * (no documentation provided)
     *
     * @param double $y
     */
    public function setY($y)
    {
        $this->y = $y;
    }

    /**
     * Initializes this SchedulingAddress from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of SchedulingAddress from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'postalCode') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->postalCode = $child;
            $happened = true;
        }
        else if (($xml->localName == 'geocodeScore') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->geocodeScore = $child;
            $happened = true;
        }
        else if (($xml->localName == 'x') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->x = $child;
            $happened = true;
        }
        else if (($xml->localName == 'region') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->region = $child;
            $happened = true;
        }
        else if (($xml->localName == 'countryCode') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->countryCode = $child;
            $happened = true;
        }
        else if (($xml->localName == 'geocodeType') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->geocodeType = $child;
            $happened = true;
        }
        else if (($xml->localName == 'streetAndNumber') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->streetAndNumber = $child;
            $happened = true;
        }
        else if (($xml->localName == 'complement') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->complement = $child;
            $happened = true;
        }
        else if (($xml->localName == 'city') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->city = $child;
            $happened = true;
        }
        else if (($xml->localName == 'y') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->y = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of SchedulingAddress from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this SchedulingAddress to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->postalCode) {
            $writer->startElementNs(null, 'postalCode', null);
            $writer->text($this->postalCode);
            $writer->endElement();
        }
        if ($this->geocodeScore) {
            $writer->startElementNs(null, 'geocodeScore', null);
            $writer->text($this->geocodeScore);
            $writer->endElement();
        }
        if ($this->x) {
            $writer->startElementNs(null, 'x', null);
            $writer->text($this->x);
            $writer->endElement();
        }
        if ($this->region) {
            $writer->startElementNs(null, 'region', null);
            $writer->text($this->region);
            $writer->endElement();
        }
        if ($this->countryCode) {
            $writer->startElementNs(null, 'countryCode', null);
            $writer->text($this->countryCode);
            $writer->endElement();
        }
        if ($this->geocodeType) {
            $writer->startElementNs(null, 'geocodeType', null);
            $writer->text($this->geocodeType);
            $writer->endElement();
        }
        if ($this->streetAndNumber) {
            $writer->startElementNs(null, 'streetAndNumber', null);
            $writer->text($this->streetAndNumber);
            $writer->endElement();
        }
        if ($this->complement) {
            $writer->startElementNs(null, 'complement', null);
            $writer->text($this->complement);
            $writer->endElement();
        }
        if ($this->city) {
            $writer->startElementNs(null, 'city', null);
            $writer->text($this->city);
            $writer->endElement();
        }
        if ($this->y) {
            $writer->startElementNs(null, 'y', null);
            $writer->text($this->y);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Export;

/**
 * (no documentation provided)
 */
class ScheduleSlot
{

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $start;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $end;

    /**
     * (no documentation provided)
     *
     * @var boolean
     */
    private $free;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $distanceToClosest;

    /**
     * Constructs a ScheduleSlot from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getStart()
    {
        return $this->start;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $start
     */
    public function setStart($start)
    {
        $this->start = $start;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getEnd()
    {
        return $this->end;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $end
     */
    public function setEnd($end)
    {
        $this->end = $end;
    }
    /**
     * (no documentation provided)
     *
     * @return boolean
     */
    public function getFree()
    {
        return $this->free;
    }

    /**
     * (no documentation provided)
     *
     * @param boolean $free
     */
    public function setFree($free)
    {
        $this->free = $free;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getDistanceToClosest()
    {
        return $this->distanceToClosest;
    }

    /**
     * (no documentation provided)
     *
     * @param double $distanceToClosest
     */
    public function setDistanceToClosest($distanceToClosest)
    {
        $this->distanceToClosest = $distanceToClosest;
    }

    /**
     * Initializes this ScheduleSlot from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of ScheduleSlot from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'start') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->start = $child;
            $happened = true;
        }
        else if (($xml->localName == 'end') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->end = $child;
            $happened = true;
        }
        else if (($xml->localName == 'free') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->free = $child;
            $happened = true;
        }
        else if (($xml->localName == 'distanceToClosest') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->distanceToClosest = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of ScheduleSlot from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this ScheduleSlot to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->start) {
            $writer->startElementNs(null, 'start', null);
            $writer->text($this->start);
            $writer->endElement();
        }
        if ($this->end) {
            $writer->startElementNs(null, 'end', null);
            $writer->text($this->end);
            $writer->endElement();
        }
        if ($this->free) {
            $writer->startElementNs(null, 'free', null);
            $writer->text($this->free);
            $writer->endElement();
        }
        if ($this->distanceToClosest) {
            $writer->startElementNs(null, 'distanceToClosest', null);
            $writer->text($this->distanceToClosest);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Imminent\Model;

/**
 * (no documentation provided)
 */
class ImminentOrderSatisfaction
{

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $comment;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $rating;

    /**
     * Constructs a ImminentOrderSatisfaction from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getComment()
    {
        return $this->comment;
    }

    /**
     * (no documentation provided)
     *
     * @param string $comment
     */
    public function setComment($comment)
    {
        $this->comment = $comment;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getRating()
    {
        return $this->rating;
    }

    /**
     * (no documentation provided)
     *
     * @param double $rating
     */
    public function setRating($rating)
    {
        $this->rating = $rating;
    }

    /**
     * Initializes this ImminentOrderSatisfaction from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of ImminentOrderSatisfaction from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'comment') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->comment = $child;
            $happened = true;
        }
        else if (($xml->localName == 'rating') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->rating = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of ImminentOrderSatisfaction from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this ImminentOrderSatisfaction to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->comment) {
            $writer->startElementNs(null, 'comment', null);
            $writer->text($this->comment);
            $writer->endElement();
        }
        if ($this->rating) {
            $writer->startElementNs(null, 'rating', null);
            $writer->text($this->rating);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Model;

/**
 * (no documentation provided)
 */
class ScanItem
{

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $id;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $order;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $description;

    /**
     * Constructs a ScanItem from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * (no documentation provided)
     *
     * @param string $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getOrder()
    {
        return $this->order;
    }

    /**
     * (no documentation provided)
     *
     * @param string $order
     */
    public function setOrder($order)
    {
        $this->order = $order;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getDescription()
    {
        return $this->description;
    }

    /**
     * (no documentation provided)
     *
     * @param string $description
     */
    public function setDescription($description)
    {
        $this->description = $description;
    }

    /**
     * Initializes this ScanItem from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of ScanItem from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'order') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->order = $child;
            $happened = true;
        }
        else if (($xml->localName == 'description') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->description = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of ScanItem from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this ScanItem to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->id) {
            $writer->startElementNs(null, 'id', null);
            $writer->text($this->id);
            $writer->endElement();
        }
        if ($this->order) {
            $writer->startElementNs(null, 'order', null);
            $writer->text($this->order);
            $writer->endElement();
        }
        if ($this->description) {
            $writer->startElementNs(null, 'description', null);
            $writer->text($this->description);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Model;

/**
 * (no documentation provided)
 */
class GeocodeInfos
{

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $addressComplement;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $address;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $postcode;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $city;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $region;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $country;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $score;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $geocodeType;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $geocodeCity;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $geocodePostalCode;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $geocodeAddressLine;

    /**
     * Constructs a GeocodeInfos from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getAddressComplement()
    {
        return $this->addressComplement;
    }

    /**
     * (no documentation provided)
     *
     * @param string $addressComplement
     */
    public function setAddressComplement($addressComplement)
    {
        $this->addressComplement = $addressComplement;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getAddress()
    {
        return $this->address;
    }

    /**
     * (no documentation provided)
     *
     * @param string $address
     */
    public function setAddress($address)
    {
        $this->address = $address;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getPostcode()
    {
        return $this->postcode;
    }

    /**
     * (no documentation provided)
     *
     * @param string $postcode
     */
    public function setPostcode($postcode)
    {
        $this->postcode = $postcode;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getCity()
    {
        return $this->city;
    }

    /**
     * (no documentation provided)
     *
     * @param string $city
     */
    public function setCity($city)
    {
        $this->city = $city;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getRegion()
    {
        return $this->region;
    }

    /**
     * (no documentation provided)
     *
     * @param string $region
     */
    public function setRegion($region)
    {
        $this->region = $region;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getCountry()
    {
        return $this->country;
    }

    /**
     * (no documentation provided)
     *
     * @param string $country
     */
    public function setCountry($country)
    {
        $this->country = $country;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getScore()
    {
        return $this->score;
    }

    /**
     * (no documentation provided)
     *
     * @param double $score
     */
    public function setScore($score)
    {
        $this->score = $score;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getGeocodeType()
    {
        return $this->geocodeType;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $geocodeType
     */
    public function setGeocodeType($geocodeType)
    {
        $this->geocodeType = $geocodeType;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getGeocodeCity()
    {
        return $this->geocodeCity;
    }

    /**
     * (no documentation provided)
     *
     * @param string $geocodeCity
     */
    public function setGeocodeCity($geocodeCity)
    {
        $this->geocodeCity = $geocodeCity;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getGeocodePostalCode()
    {
        return $this->geocodePostalCode;
    }

    /**
     * (no documentation provided)
     *
     * @param string $geocodePostalCode
     */
    public function setGeocodePostalCode($geocodePostalCode)
    {
        $this->geocodePostalCode = $geocodePostalCode;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getGeocodeAddressLine()
    {
        return $this->geocodeAddressLine;
    }

    /**
     * (no documentation provided)
     *
     * @param string $geocodeAddressLine
     */
    public function setGeocodeAddressLine($geocodeAddressLine)
    {
        $this->geocodeAddressLine = $geocodeAddressLine;
    }

    /**
     * Initializes this GeocodeInfos from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of GeocodeInfos from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'addressComplement') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->addressComplement = $child;
            $happened = true;
        }
        else if (($xml->localName == 'address') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->address = $child;
            $happened = true;
        }
        else if (($xml->localName == 'postcode') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->postcode = $child;
            $happened = true;
        }
        else if (($xml->localName == 'city') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->city = $child;
            $happened = true;
        }
        else if (($xml->localName == 'region') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->region = $child;
            $happened = true;
        }
        else if (($xml->localName == 'country') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->country = $child;
            $happened = true;
        }
        else if (($xml->localName == 'score') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->score = $child;
            $happened = true;
        }
        else if (($xml->localName == 'geocodeType') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->geocodeType = $child;
            $happened = true;
        }
        else if (($xml->localName == 'geocodeCity') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->geocodeCity = $child;
            $happened = true;
        }
        else if (($xml->localName == 'geocodePostalCode') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->geocodePostalCode = $child;
            $happened = true;
        }
        else if (($xml->localName == 'geocodeAddressLine') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->geocodeAddressLine = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of GeocodeInfos from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this GeocodeInfos to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->addressComplement) {
            $writer->startElementNs(null, 'addressComplement', null);
            $writer->text($this->addressComplement);
            $writer->endElement();
        }
        if ($this->address) {
            $writer->startElementNs(null, 'address', null);
            $writer->text($this->address);
            $writer->endElement();
        }
        if ($this->postcode) {
            $writer->startElementNs(null, 'postcode', null);
            $writer->text($this->postcode);
            $writer->endElement();
        }
        if ($this->city) {
            $writer->startElementNs(null, 'city', null);
            $writer->text($this->city);
            $writer->endElement();
        }
        if ($this->region) {
            $writer->startElementNs(null, 'region', null);
            $writer->text($this->region);
            $writer->endElement();
        }
        if ($this->country) {
            $writer->startElementNs(null, 'country', null);
            $writer->text($this->country);
            $writer->endElement();
        }
        if ($this->score) {
            $writer->startElementNs(null, 'score', null);
            $writer->text($this->score);
            $writer->endElement();
        }
        if ($this->geocodeType) {
            $writer->startElementNs(null, 'geocodeType', null);
            $writer->text($this->geocodeType);
            $writer->endElement();
        }
        if ($this->geocodeCity) {
            $writer->startElementNs(null, 'geocodeCity', null);
            $writer->text($this->geocodeCity);
            $writer->endElement();
        }
        if ($this->geocodePostalCode) {
            $writer->startElementNs(null, 'geocodePostalCode', null);
            $writer->text($this->geocodePostalCode);
            $writer->endElement();
        }
        if ($this->geocodeAddressLine) {
            $writer->startElementNs(null, 'geocodeAddressLine', null);
            $writer->text($this->geocodeAddressLine);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Optim;

/**
 * (no documentation provided)
 */
class OperationalResourceMapping
{

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $day;

    /**
     * 
     *
     * @var string
     */
    private $id;

    /**
     * Mobile identifier
     *
     * @var string
     */
    private $operationalId;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $fuelType;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $vehicleType;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $averageFuelConsumption;

    /**
     * Constructs a OperationalResourceMapping from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getDay()
    {
        return $this->day;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $day
     */
    public function setDay($day)
    {
        $this->day = $day;
    }
    /**
     * 
     *
     * @return string
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * 
     *
     * @param string $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }
    /**
     * Mobile identifier
     *
     * @return string
     */
    public function getOperationalId()
    {
        return $this->operationalId;
    }

    /**
     * Mobile identifier
     *
     * @param string $operationalId
     */
    public function setOperationalId($operationalId)
    {
        $this->operationalId = $operationalId;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getFuelType()
    {
        return $this->fuelType;
    }

    /**
     * (no documentation provided)
     *
     * @param string $fuelType
     */
    public function setFuelType($fuelType)
    {
        $this->fuelType = $fuelType;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getVehicleType()
    {
        return $this->vehicleType;
    }

    /**
     * (no documentation provided)
     *
     * @param string $vehicleType
     */
    public function setVehicleType($vehicleType)
    {
        $this->vehicleType = $vehicleType;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getAverageFuelConsumption()
    {
        return $this->averageFuelConsumption;
    }

    /**
     * (no documentation provided)
     *
     * @param double $averageFuelConsumption
     */
    public function setAverageFuelConsumption($averageFuelConsumption)
    {
        $this->averageFuelConsumption = $averageFuelConsumption;
    }

    /**
     * Initializes this OperationalResourceMapping from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of OperationalResourceMapping from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'day') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->day = $child;
            $happened = true;
        }
        else if (($xml->localName == 'id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'operationalId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->operationalId = $child;
            $happened = true;
        }
        else if (($xml->localName == 'fuelType') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->fuelType = $child;
            $happened = true;
        }
        else if (($xml->localName == 'vehicleType') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->vehicleType = $child;
            $happened = true;
        }
        else if (($xml->localName == 'averageFuelConsumption') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->averageFuelConsumption = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of OperationalResourceMapping from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes this OperationalResourceMapping to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'operationalResourceMapping', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this OperationalResourceMapping to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->day) {
            $writer->startElementNs(null, 'day', null);
            $writer->text($this->day);
            $writer->endElement();
        }
        if ($this->id) {
            $writer->startElementNs(null, 'id', null);
            $writer->text($this->id);
            $writer->endElement();
        }
        if ($this->operationalId) {
            $writer->startElementNs(null, 'operationalId', null);
            $writer->text($this->operationalId);
            $writer->endElement();
        }
        if ($this->fuelType) {
            $writer->startElementNs(null, 'fuelType', null);
            $writer->text($this->fuelType);
            $writer->endElement();
        }
        if ($this->vehicleType) {
            $writer->startElementNs(null, 'vehicleType', null);
            $writer->text($this->vehicleType);
            $writer->endElement();
        }
        if ($this->averageFuelConsumption) {
            $writer->startElementNs(null, 'averageFuelConsumption', null);
            $writer->text($this->averageFuelConsumption);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Optim;

/**
 * (no documentation provided)
 */
class TSAdditionalCost
{

    /**
     * TSOrder type (stored in a custom data)
     *
     * @var string
     */
    private $type;

    /**
     * Cost for this type
     *
     * @var double
     */
    private $value;

    /**
     * Constructs a TSAdditionalCost from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * TSOrder type (stored in a custom data)
     *
     * @return string
     */
    public function getType()
    {
        return $this->type;
    }

    /**
     * TSOrder type (stored in a custom data)
     *
     * @param string $type
     */
    public function setType($type)
    {
        $this->type = $type;
    }
    /**
     * Cost for this type
     *
     * @return double
     */
    public function getValue()
    {
        return $this->value;
    }

    /**
     * Cost for this type
     *
     * @param double $value
     */
    public function setValue($value)
    {
        $this->value = $value;
    }

    /**
     * Initializes this TSAdditionalCost from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of TSAdditionalCost from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'type') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->type = $child;
            $happened = true;
        }
        else if (($xml->localName == 'value') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->value = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of TSAdditionalCost from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this TSAdditionalCost to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->type) {
            $writer->startElementNs(null, 'type', null);
            $writer->text($this->type);
            $writer->endElement();
        }
        if ($this->value) {
            $writer->startElementNs(null, 'value', null);
            $writer->text($this->value);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Optim;

/**
 * (no documentation provided)
 */
class TSEvaluationInfos
{

    /**
     * The identity of the resource which visits the customer when evaluating an
     * existing planning.
     * 
     * * Use this constraint when you want to &#39;evaluate&#39; an existing planning.
     * 
     * * Use the orderOriginalVisitDay constraint to specify the working day
     * when the visit must be planned.
     * 
     * * Use the orderPosition constraint to specify the position of a visit
     * in the tour.
     * 
     * **Type : ** string (storing a unique resource tag). **Default: : ** not used
     *
     * @var string
     */
    private $orderOriginalResourceId;

    /**
     * Indicates the work day when the resource which visits the customer when
     * evaluating an existing planning.
     * 
     * * Use this constraint when you want to &#39;evaluate&#39; an existing planning.
     * 
     * * Use the orderOriginalResourceID to specify the resource which visit
     * the customer.
     * 
     * * Use the orderPosition to specify the position of a visit in the
     * tour.
     * 
     * **Type : ** integer between 1 and 64 or string representing a date.
     * 
     * 1 is the first day of the planning period, the corresponding date, if
     * any, is defined by the oldest date, for all resources, in the
     * tsResourceWorkDays constraint. if the original visit day is in the date
     * format, this date cannot precede the first day of the planning period
     * defined by the resources (which is day 1).
     * 
     * **Default :** not used if the tsOrderOriginalResourceIDis not used, 1 overwise
     *
     * @var string
     */
    private $orderOriginalVisitDay;

    /**
     * The position of a customer in a resource tour.
     * 
     * Use this constraint when you want to evaluate a tour.
     * 
     * **Type : ** integer. **Default : ** not used
     *
     * @var integer
     */
    private $orderPosition;

    /**
     * Constructs a TSEvaluationInfos from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * The identity of the resource which visits the customer when evaluating an
       * existing planning.
       * 
       * * Use this constraint when you want to &#39;evaluate&#39; an existing planning.
       * 
       * * Use the orderOriginalVisitDay constraint to specify the working day
       * when the visit must be planned.
       * 
       * * Use the orderPosition constraint to specify the position of a visit
       * in the tour.
       * 
       * **Type : ** string (storing a unique resource tag). **Default: : ** not used
     *
     * @return string
     */
    public function getOrderOriginalResourceId()
    {
        return $this->orderOriginalResourceId;
    }

    /**
     * The identity of the resource which visits the customer when evaluating an
       * existing planning.
       * 
       * * Use this constraint when you want to &#39;evaluate&#39; an existing planning.
       * 
       * * Use the orderOriginalVisitDay constraint to specify the working day
       * when the visit must be planned.
       * 
       * * Use the orderPosition constraint to specify the position of a visit
       * in the tour.
       * 
       * **Type : ** string (storing a unique resource tag). **Default: : ** not used
     *
     * @param string $orderOriginalResourceId
     */
    public function setOrderOriginalResourceId($orderOriginalResourceId)
    {
        $this->orderOriginalResourceId = $orderOriginalResourceId;
    }
    /**
     * Indicates the work day when the resource which visits the customer when
       * evaluating an existing planning.
       * 
       * * Use this constraint when you want to &#39;evaluate&#39; an existing planning.
       * 
       * * Use the orderOriginalResourceID to specify the resource which visit
       * the customer.
       * 
       * * Use the orderPosition to specify the position of a visit in the
       * tour.
       * 
       * **Type : ** integer between 1 and 64 or string representing a date.
       * 
       * 1 is the first day of the planning period, the corresponding date, if
       * any, is defined by the oldest date, for all resources, in the
       * tsResourceWorkDays constraint. if the original visit day is in the date
       * format, this date cannot precede the first day of the planning period
       * defined by the resources (which is day 1).
       * 
       * **Default :** not used if the tsOrderOriginalResourceIDis not used, 1 overwise
     *
     * @return string
     */
    public function getOrderOriginalVisitDay()
    {
        return $this->orderOriginalVisitDay;
    }

    /**
     * Indicates the work day when the resource which visits the customer when
       * evaluating an existing planning.
       * 
       * * Use this constraint when you want to &#39;evaluate&#39; an existing planning.
       * 
       * * Use the orderOriginalResourceID to specify the resource which visit
       * the customer.
       * 
       * * Use the orderPosition to specify the position of a visit in the
       * tour.
       * 
       * **Type : ** integer between 1 and 64 or string representing a date.
       * 
       * 1 is the first day of the planning period, the corresponding date, if
       * any, is defined by the oldest date, for all resources, in the
       * tsResourceWorkDays constraint. if the original visit day is in the date
       * format, this date cannot precede the first day of the planning period
       * defined by the resources (which is day 1).
       * 
       * **Default :** not used if the tsOrderOriginalResourceIDis not used, 1 overwise
     *
     * @param string $orderOriginalVisitDay
     */
    public function setOrderOriginalVisitDay($orderOriginalVisitDay)
    {
        $this->orderOriginalVisitDay = $orderOriginalVisitDay;
    }
    /**
     * The position of a customer in a resource tour.
       * 
       * Use this constraint when you want to evaluate a tour.
       * 
       * **Type : ** integer. **Default : ** not used
     *
     * @return integer
     */
    public function getOrderPosition()
    {
        return $this->orderPosition;
    }

    /**
     * The position of a customer in a resource tour.
       * 
       * Use this constraint when you want to evaluate a tour.
       * 
       * **Type : ** integer. **Default : ** not used
     *
     * @param integer $orderPosition
     */
    public function setOrderPosition($orderPosition)
    {
        $this->orderPosition = $orderPosition;
    }

    /**
     * Initializes this TSEvaluationInfos from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of TSEvaluationInfos from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'orderOriginalResourceId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->orderOriginalResourceId = $child;
            $happened = true;
        }
        else if (($xml->localName == 'orderOriginalVisitDay') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->orderOriginalVisitDay = $child;
            $happened = true;
        }
        else if (($xml->localName == 'orderPosition') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->orderPosition = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of TSEvaluationInfos from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this TSEvaluationInfos to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->orderOriginalResourceId) {
            $writer->startElementNs(null, 'orderOriginalResourceId', null);
            $writer->text($this->orderOriginalResourceId);
            $writer->endElement();
        }
        if ($this->orderOriginalVisitDay) {
            $writer->startElementNs(null, 'orderOriginalVisitDay', null);
            $writer->text($this->orderOriginalVisitDay);
            $writer->endElement();
        }
        if ($this->orderPosition) {
            $writer->startElementNs(null, 'orderPosition', null);
            $writer->text($this->orderPosition);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Optim;

/**
 * (no documentation provided)
 */
class TSOptions
{

    /**
     * Enable this if you just want to evaluate (get cost, distances, etc) a set of tours.
     * Therefore, you must fill the evaluationInfos objects in orders (see TSEvaluationInfos).
     * 
     * ** Default : ** false.
     *
     * @var boolean
     */
    private $evaluation;

    /**
     * Enable this if you want the optimization to start from a specified initial configuration.
     * Therefore, you must fill the evaluationInfos objects in orders (see TSEvaluationInfos).
     * 
     * ** Default : ** false.
     *
     * @var boolean
     */
    private $startFromEvaluationInfo;

    /**
     * maximum optimization time. Default is one minute.
     * 
     * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes)
     *
     * @var string
     */
    private $maxOptimDuration;

    /**
     * Default reload duration
     * 
     * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes)
     *
     * @var string
     */
    private $reloadDuration;

    /**
     * Use it to forbid/allow reloads
     * 
     * ** Default : ** false.
     *
     * @var boolean
     */
    private $noReload;

    /**
     * Set the distance unit (meters, feet, km or miles), defaut is meters
     *
     * @var string
     */
    private $distanceType;

    /**
     * If you did not specify any resource in your request, all resources defined in your tenant will be used for this optimization.
     * If you specify a team identifier, only the resources of this team will be used.
     *
     * @var string
     */
    private $teamId;

    /**
     * Enable result export to webhook
     * 
     * If enabled, optimization result will be sent to the webook you defined in Toursolver Cloud configuration.
     * 
     * Possible values are :
     * 
     * * NONE : result will not be sent automatically when optimization
     * finishes. You will have to call the result or toursResult service to
     * retrieve it.
     * 
     * * ORDERS : the &quot;orders&quot; result will be sent to the specified webhook. See
     * OptimResultResult object for details.
     * 
     * * TOURS : the &quot;tours&quot; result will be sent to the specified webhook. See
     * OptimToursResult object for details.
     * 
     * **Default : ** NONE.
     *
     * @var string
     */
    private $sendResultToWebhook;

    /**
     * If true, PenalPerVisit will counted only once in tour delivery cost if several visits at the same location are planned consecutively.
     *
     * @var boolean
     */
    private $countVisitCostOnceIfSameLocation;

    /**
     * Depot cost configuration for tour delivery cost
     * 
     * Specifies how depots stops are counted in tour delivery cost (using PenaltyPerVisit defined on resources).
     * 
     * Possible values are :
     * 
     * * NONE : depots stops are not counted in tour delivery cost
     * 
     * * ALL : each depot stop counts as one visit in tour delivery cost
     * 
     * * ALLBUTFIRST : first depot stop is ignored but each following depot stop
     * will count as one visit in tour delivery cost
     * 
     * * FIRST : only first depot stop is counted in tour delivery cost
     * 
     * **Default : ** NONE.
     *
     * @var string
     */
    private $countDepotsInDeliveryCost;

    /**
     * Exclude visit delivery cost for visits having the maximum additional cost
     *
     * @var boolean
     */
    private $excludeVisitCostIfMaxAdditionalCost;

    /**
     * Routing method
     * 
     * Specifies routing method used for travel time and distance matrix
     * computation
     * 
     * Possible values are :
     * 
     * * TIME : routes minimizing travel time are used
     * 
     * * DISTANCE : routes minimizing travel distance are used
     * 
     * **Default : ** TIME.
     *
     * @var string
     */
    private $routingMethod;

    /**
     * Allow toll
     * 
     * If false, all toll ways will be avoided.
     * 
     * **Default : ** true.
     *
     * @var boolean
     */
    private $allowToll;

    /**
     * Allow tunnel
     * 
     * If false, all tunnels will be avoided.
     * 
     * **Default : ** true.
     *
     * @var boolean
     */
    private $allowTunnel;

    /**
     * Allow bridge
     * 
     * If false, all bridges will be avoided.
     * 
     * **Default : ** true.
     *
     * @var boolean
     */
    private $allowBridge;

    /**
     * Allow ferry boats (new solver only)
     * 
     * If false, all ferry boats junctions will be avoided.
     * 
     * **Default : ** true.
     *
     * @var boolean
     */
    private $allowBoatFerry;

    /**
     * Vehicles regulations.
     * 
     * Possible values are :
     * 
     * * bicycle
     * 
     * * bus
     * 
     * * car
     * 
     * * deliveryIntermediateVehicle
     * 
     * * deliveryLightCommercialVehicle
     * 
     * * emergencyTruck
     * 
     * * emergencyVehicle
     * 
     * * intermediateVehicle
     * 
     * * lightCommercialVehicle
     * 
     * * pedestrian
     * 
     * * taxi
     * 
     * * truck
     * 
     * If not specified, vehicle type defined in UI will be used
     *
     * @var string
     */
    private $vehicleCode;

    /**
     * Vehicles fuel type. Possible values are :
     * 
     * * diesel
     * 
     * * undefined
     * 
     * * unleaded
     *
     * @var string
     */
    private $fuelCode;

    /**
     * Speed pattern name
     * 
     * Specifies the speed pattern to be used for this optimization.
     * &quot;default_profile&quot; is the internal name for the default speed pattern (its
     * actual name in UI depends on your locale).
     * 
     * You can use your own speed pattern (defined in Toursolver UI) but you
     * will have to use its internal name : if you created a pattern called
     * &quot;Paris august speed pattern&quot;, its internal name will be
     * &quot;paris_august_speed_pattern&quot;.
     * 
     * 
     * If set to null (or not defined), no speed pattern will be used at all
     * (same speeds for whole day).
     *
     * @var string
     */
    private $speedPattern;

    /**
     * Whether to use forbidden transit areas
     * 
     * Specifies true to use forbidden transit areas, and false to ignore
     * forbidden transit areas
     * 
     * If omitted, default to true, but has no effect if no forbidden transit
     * areas are supplied
     *
     * @var boolean
     */
    private $useForbiddenTransitAreas;

    /**
     * Whether to use OTSolver instead of TSDK
     * 
     * OTSolver is the new optimization engine behind Toursolver. It behaves
     * better with big problems (more than 1000 visits). This is still a beta
     * version and all the constraints supported by TSDK are not supported yet
     * but they will be implemented as soon as possible.
     * 
     * OTSolver must be enabled for your account before you can use it.
     *
     * @var boolean
     */
    private $useOTSolver;

    /**
     * Route plans balancing type
     * 
     * 
     * * NONE : no balancing
     * 
     * * ORDERS : balance the number of orders (to be used with balanceValue)
     * 
     * * HOURS : balance the route plans duration
     * 
     * * QUANTITY : balance the route plans delivered quantity
     * 
     * Only available with OTSolver
     *
     * @var string
     */
    private $balanceType;

    /**
     * Route plans balancing target (to be used with balanceType)
     * 
     * Locked route plans are not considered.
     * 
     * Only available with OTSolver
     *
     * @var integer
     */
    private $balanceValue;

    /**
     * List of the advanced settings for new engine (OTSolver)
     * 
     * Use this to override the advanced settings set in the UI.
     * 
     * **Type : ** Array of strings
     * 
     * **Example : ** [&quot;FirstSolutionStrategy=NEAREST&quot;, &quot;ParkingTime=30&quot;]
     *
     * @var string[]
     */
    private $advancedSettings;

    /**
     * Constructs a TSOptions from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * Enable this if you just want to evaluate (get cost, distances, etc) a set of tours.
       * Therefore, you must fill the evaluationInfos objects in orders (see TSEvaluationInfos).
       * 
       * ** Default : ** false.
     *
     * @return boolean
     */
    public function getEvaluation()
    {
        return $this->evaluation;
    }

    /**
     * Enable this if you just want to evaluate (get cost, distances, etc) a set of tours.
       * Therefore, you must fill the evaluationInfos objects in orders (see TSEvaluationInfos).
       * 
       * ** Default : ** false.
     *
     * @param boolean $evaluation
     */
    public function setEvaluation($evaluation)
    {
        $this->evaluation = $evaluation;
    }
    /**
     * Enable this if you want the optimization to start from a specified initial configuration.
       * Therefore, you must fill the evaluationInfos objects in orders (see TSEvaluationInfos).
       * 
       * ** Default : ** false.
     *
     * @return boolean
     */
    public function getStartFromEvaluationInfo()
    {
        return $this->startFromEvaluationInfo;
    }

    /**
     * Enable this if you want the optimization to start from a specified initial configuration.
       * Therefore, you must fill the evaluationInfos objects in orders (see TSEvaluationInfos).
       * 
       * ** Default : ** false.
     *
     * @param boolean $startFromEvaluationInfo
     */
    public function setStartFromEvaluationInfo($startFromEvaluationInfo)
    {
        $this->startFromEvaluationInfo = $startFromEvaluationInfo;
    }
    /**
     * maximum optimization time. Default is one minute.
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes)
     *
     * @return string
     */
    public function getMaxOptimDuration()
    {
        return $this->maxOptimDuration;
    }

    /**
     * maximum optimization time. Default is one minute.
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes)
     *
     * @param string $maxOptimDuration
     */
    public function setMaxOptimDuration($maxOptimDuration)
    {
        $this->maxOptimDuration = $maxOptimDuration;
    }
    /**
     * Default reload duration
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes)
     *
     * @return string
     */
    public function getReloadDuration()
    {
        return $this->reloadDuration;
    }

    /**
     * Default reload duration
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes)
     *
     * @param string $reloadDuration
     */
    public function setReloadDuration($reloadDuration)
    {
        $this->reloadDuration = $reloadDuration;
    }
    /**
     * Use it to forbid/allow reloads
       * 
       * ** Default : ** false.
     *
     * @return boolean
     */
    public function getNoReload()
    {
        return $this->noReload;
    }

    /**
     * Use it to forbid/allow reloads
       * 
       * ** Default : ** false.
     *
     * @param boolean $noReload
     */
    public function setNoReload($noReload)
    {
        $this->noReload = $noReload;
    }
    /**
     * Set the distance unit (meters, feet, km or miles), defaut is meters
     *
     * @return string
     */
    public function getDistanceType()
    {
        return $this->distanceType;
    }

    /**
     * Set the distance unit (meters, feet, km or miles), defaut is meters
     *
     * @param string $distanceType
     */
    public function setDistanceType($distanceType)
    {
        $this->distanceType = $distanceType;
    }
    /**
     * If you did not specify any resource in your request, all resources defined in your tenant will be used for this optimization.
       * If you specify a team identifier, only the resources of this team will be used.
     *
     * @return string
     */
    public function getTeamId()
    {
        return $this->teamId;
    }

    /**
     * If you did not specify any resource in your request, all resources defined in your tenant will be used for this optimization.
       * If you specify a team identifier, only the resources of this team will be used.
     *
     * @param string $teamId
     */
    public function setTeamId($teamId)
    {
        $this->teamId = $teamId;
    }
    /**
     * Enable result export to webhook
       * 
       * If enabled, optimization result will be sent to the webook you defined in Toursolver Cloud configuration.
       * 
       * Possible values are :
       * 
       * * NONE : result will not be sent automatically when optimization
       * finishes. You will have to call the result or toursResult service to
       * retrieve it.
       * 
       * * ORDERS : the &quot;orders&quot; result will be sent to the specified webhook. See
       * OptimResultResult object for details.
       * 
       * * TOURS : the &quot;tours&quot; result will be sent to the specified webhook. See
       * OptimToursResult object for details.
       * 
       * **Default : ** NONE.
     *
     * @return string
     */
    public function getSendResultToWebhook()
    {
        return $this->sendResultToWebhook;
    }

    /**
     * Enable result export to webhook
       * 
       * If enabled, optimization result will be sent to the webook you defined in Toursolver Cloud configuration.
       * 
       * Possible values are :
       * 
       * * NONE : result will not be sent automatically when optimization
       * finishes. You will have to call the result or toursResult service to
       * retrieve it.
       * 
       * * ORDERS : the &quot;orders&quot; result will be sent to the specified webhook. See
       * OptimResultResult object for details.
       * 
       * * TOURS : the &quot;tours&quot; result will be sent to the specified webhook. See
       * OptimToursResult object for details.
       * 
       * **Default : ** NONE.
     *
     * @param string $sendResultToWebhook
     */
    public function setSendResultToWebhook($sendResultToWebhook)
    {
        $this->sendResultToWebhook = $sendResultToWebhook;
    }
    /**
     * If true, PenalPerVisit will counted only once in tour delivery cost if several visits at the same location are planned consecutively.
     *
     * @return boolean
     */
    public function getCountVisitCostOnceIfSameLocation()
    {
        return $this->countVisitCostOnceIfSameLocation;
    }

    /**
     * If true, PenalPerVisit will counted only once in tour delivery cost if several visits at the same location are planned consecutively.
     *
     * @param boolean $countVisitCostOnceIfSameLocation
     */
    public function setCountVisitCostOnceIfSameLocation($countVisitCostOnceIfSameLocation)
    {
        $this->countVisitCostOnceIfSameLocation = $countVisitCostOnceIfSameLocation;
    }
    /**
     * Depot cost configuration for tour delivery cost
       * 
       * Specifies how depots stops are counted in tour delivery cost (using PenaltyPerVisit defined on resources).
       * 
       * Possible values are :
       * 
       * * NONE : depots stops are not counted in tour delivery cost
       * 
       * * ALL : each depot stop counts as one visit in tour delivery cost
       * 
       * * ALLBUTFIRST : first depot stop is ignored but each following depot stop
       * will count as one visit in tour delivery cost
       * 
       * * FIRST : only first depot stop is counted in tour delivery cost
       * 
       * **Default : ** NONE.
     *
     * @return string
     */
    public function getCountDepotsInDeliveryCost()
    {
        return $this->countDepotsInDeliveryCost;
    }

    /**
     * Depot cost configuration for tour delivery cost
       * 
       * Specifies how depots stops are counted in tour delivery cost (using PenaltyPerVisit defined on resources).
       * 
       * Possible values are :
       * 
       * * NONE : depots stops are not counted in tour delivery cost
       * 
       * * ALL : each depot stop counts as one visit in tour delivery cost
       * 
       * * ALLBUTFIRST : first depot stop is ignored but each following depot stop
       * will count as one visit in tour delivery cost
       * 
       * * FIRST : only first depot stop is counted in tour delivery cost
       * 
       * **Default : ** NONE.
     *
     * @param string $countDepotsInDeliveryCost
     */
    public function setCountDepotsInDeliveryCost($countDepotsInDeliveryCost)
    {
        $this->countDepotsInDeliveryCost = $countDepotsInDeliveryCost;
    }
    /**
     * Exclude visit delivery cost for visits having the maximum additional cost
     *
     * @return boolean
     */
    public function getExcludeVisitCostIfMaxAdditionalCost()
    {
        return $this->excludeVisitCostIfMaxAdditionalCost;
    }

    /**
     * Exclude visit delivery cost for visits having the maximum additional cost
     *
     * @param boolean $excludeVisitCostIfMaxAdditionalCost
     */
    public function setExcludeVisitCostIfMaxAdditionalCost($excludeVisitCostIfMaxAdditionalCost)
    {
        $this->excludeVisitCostIfMaxAdditionalCost = $excludeVisitCostIfMaxAdditionalCost;
    }
    /**
     * Routing method
       * 
       * Specifies routing method used for travel time and distance matrix
       * computation
       * 
       * Possible values are :
       * 
       * * TIME : routes minimizing travel time are used
       * 
       * * DISTANCE : routes minimizing travel distance are used
       * 
       * **Default : ** TIME.
     *
     * @return string
     */
    public function getRoutingMethod()
    {
        return $this->routingMethod;
    }

    /**
     * Routing method
       * 
       * Specifies routing method used for travel time and distance matrix
       * computation
       * 
       * Possible values are :
       * 
       * * TIME : routes minimizing travel time are used
       * 
       * * DISTANCE : routes minimizing travel distance are used
       * 
       * **Default : ** TIME.
     *
     * @param string $routingMethod
     */
    public function setRoutingMethod($routingMethod)
    {
        $this->routingMethod = $routingMethod;
    }
    /**
     * Allow toll
       * 
       * If false, all toll ways will be avoided.
       * 
       * **Default : ** true.
     *
     * @return boolean
     */
    public function getAllowToll()
    {
        return $this->allowToll;
    }

    /**
     * Allow toll
       * 
       * If false, all toll ways will be avoided.
       * 
       * **Default : ** true.
     *
     * @param boolean $allowToll
     */
    public function setAllowToll($allowToll)
    {
        $this->allowToll = $allowToll;
    }
    /**
     * Allow tunnel
       * 
       * If false, all tunnels will be avoided.
       * 
       * **Default : ** true.
     *
     * @return boolean
     */
    public function getAllowTunnel()
    {
        return $this->allowTunnel;
    }

    /**
     * Allow tunnel
       * 
       * If false, all tunnels will be avoided.
       * 
       * **Default : ** true.
     *
     * @param boolean $allowTunnel
     */
    public function setAllowTunnel($allowTunnel)
    {
        $this->allowTunnel = $allowTunnel;
    }
    /**
     * Allow bridge
       * 
       * If false, all bridges will be avoided.
       * 
       * **Default : ** true.
     *
     * @return boolean
     */
    public function getAllowBridge()
    {
        return $this->allowBridge;
    }

    /**
     * Allow bridge
       * 
       * If false, all bridges will be avoided.
       * 
       * **Default : ** true.
     *
     * @param boolean $allowBridge
     */
    public function setAllowBridge($allowBridge)
    {
        $this->allowBridge = $allowBridge;
    }
    /**
     * Allow ferry boats (new solver only)
       * 
       * If false, all ferry boats junctions will be avoided.
       * 
       * **Default : ** true.
     *
     * @return boolean
     */
    public function getAllowBoatFerry()
    {
        return $this->allowBoatFerry;
    }

    /**
     * Allow ferry boats (new solver only)
       * 
       * If false, all ferry boats junctions will be avoided.
       * 
       * **Default : ** true.
     *
     * @param boolean $allowBoatFerry
     */
    public function setAllowBoatFerry($allowBoatFerry)
    {
        $this->allowBoatFerry = $allowBoatFerry;
    }
    /**
     * Vehicles regulations.
       * 
       * Possible values are :
       * 
       * * bicycle
       * 
       * * bus
       * 
       * * car
       * 
       * * deliveryIntermediateVehicle
       * 
       * * deliveryLightCommercialVehicle
       * 
       * * emergencyTruck
       * 
       * * emergencyVehicle
       * 
       * * intermediateVehicle
       * 
       * * lightCommercialVehicle
       * 
       * * pedestrian
       * 
       * * taxi
       * 
       * * truck
       * 
       * If not specified, vehicle type defined in UI will be used
     *
     * @return string
     */
    public function getVehicleCode()
    {
        return $this->vehicleCode;
    }

    /**
     * Vehicles regulations.
       * 
       * Possible values are :
       * 
       * * bicycle
       * 
       * * bus
       * 
       * * car
       * 
       * * deliveryIntermediateVehicle
       * 
       * * deliveryLightCommercialVehicle
       * 
       * * emergencyTruck
       * 
       * * emergencyVehicle
       * 
       * * intermediateVehicle
       * 
       * * lightCommercialVehicle
       * 
       * * pedestrian
       * 
       * * taxi
       * 
       * * truck
       * 
       * If not specified, vehicle type defined in UI will be used
     *
     * @param string $vehicleCode
     */
    public function setVehicleCode($vehicleCode)
    {
        $this->vehicleCode = $vehicleCode;
    }
    /**
     * Vehicles fuel type. Possible values are :
       * 
       * * diesel
       * 
       * * undefined
       * 
       * * unleaded
     *
     * @return string
     */
    public function getFuelCode()
    {
        return $this->fuelCode;
    }

    /**
     * Vehicles fuel type. Possible values are :
       * 
       * * diesel
       * 
       * * undefined
       * 
       * * unleaded
     *
     * @param string $fuelCode
     */
    public function setFuelCode($fuelCode)
    {
        $this->fuelCode = $fuelCode;
    }
    /**
     * Speed pattern name
       * 
       * Specifies the speed pattern to be used for this optimization.
       * &quot;default_profile&quot; is the internal name for the default speed pattern (its
       * actual name in UI depends on your locale).
       * 
       * You can use your own speed pattern (defined in Toursolver UI) but you
       * will have to use its internal name : if you created a pattern called
       * &quot;Paris august speed pattern&quot;, its internal name will be
       * &quot;paris_august_speed_pattern&quot;.
       * 
       * 
       * If set to null (or not defined), no speed pattern will be used at all
       * (same speeds for whole day).
     *
     * @return string
     */
    public function getSpeedPattern()
    {
        return $this->speedPattern;
    }

    /**
     * Speed pattern name
       * 
       * Specifies the speed pattern to be used for this optimization.
       * &quot;default_profile&quot; is the internal name for the default speed pattern (its
       * actual name in UI depends on your locale).
       * 
       * You can use your own speed pattern (defined in Toursolver UI) but you
       * will have to use its internal name : if you created a pattern called
       * &quot;Paris august speed pattern&quot;, its internal name will be
       * &quot;paris_august_speed_pattern&quot;.
       * 
       * 
       * If set to null (or not defined), no speed pattern will be used at all
       * (same speeds for whole day).
     *
     * @param string $speedPattern
     */
    public function setSpeedPattern($speedPattern)
    {
        $this->speedPattern = $speedPattern;
    }
    /**
     * Whether to use forbidden transit areas
       * 
       * Specifies true to use forbidden transit areas, and false to ignore
       * forbidden transit areas
       * 
       * If omitted, default to true, but has no effect if no forbidden transit
       * areas are supplied
     *
     * @return boolean
     */
    public function getUseForbiddenTransitAreas()
    {
        return $this->useForbiddenTransitAreas;
    }

    /**
     * Whether to use forbidden transit areas
       * 
       * Specifies true to use forbidden transit areas, and false to ignore
       * forbidden transit areas
       * 
       * If omitted, default to true, but has no effect if no forbidden transit
       * areas are supplied
     *
     * @param boolean $useForbiddenTransitAreas
     */
    public function setUseForbiddenTransitAreas($useForbiddenTransitAreas)
    {
        $this->useForbiddenTransitAreas = $useForbiddenTransitAreas;
    }
    /**
     * Whether to use OTSolver instead of TSDK
       * 
       * OTSolver is the new optimization engine behind Toursolver. It behaves
       * better with big problems (more than 1000 visits). This is still a beta
       * version and all the constraints supported by TSDK are not supported yet
       * but they will be implemented as soon as possible.
       * 
       * OTSolver must be enabled for your account before you can use it.
     *
     * @return boolean
     */
    public function getUseOTSolver()
    {
        return $this->useOTSolver;
    }

    /**
     * Whether to use OTSolver instead of TSDK
       * 
       * OTSolver is the new optimization engine behind Toursolver. It behaves
       * better with big problems (more than 1000 visits). This is still a beta
       * version and all the constraints supported by TSDK are not supported yet
       * but they will be implemented as soon as possible.
       * 
       * OTSolver must be enabled for your account before you can use it.
     *
     * @param boolean $useOTSolver
     */
    public function setUseOTSolver($useOTSolver)
    {
        $this->useOTSolver = $useOTSolver;
    }
    /**
     * Route plans balancing type
       * 
       * 
       * * NONE : no balancing
       * 
       * * ORDERS : balance the number of orders (to be used with balanceValue)
       * 
       * * HOURS : balance the route plans duration
       * 
       * * QUANTITY : balance the route plans delivered quantity
       * 
       * Only available with OTSolver
     *
     * @return string
     */
    public function getBalanceType()
    {
        return $this->balanceType;
    }

    /**
     * Route plans balancing type
       * 
       * 
       * * NONE : no balancing
       * 
       * * ORDERS : balance the number of orders (to be used with balanceValue)
       * 
       * * HOURS : balance the route plans duration
       * 
       * * QUANTITY : balance the route plans delivered quantity
       * 
       * Only available with OTSolver
     *
     * @param string $balanceType
     */
    public function setBalanceType($balanceType)
    {
        $this->balanceType = $balanceType;
    }
    /**
     * Route plans balancing target (to be used with balanceType)
       * 
       * Locked route plans are not considered.
       * 
       * Only available with OTSolver
     *
     * @return integer
     */
    public function getBalanceValue()
    {
        return $this->balanceValue;
    }

    /**
     * Route plans balancing target (to be used with balanceType)
       * 
       * Locked route plans are not considered.
       * 
       * Only available with OTSolver
     *
     * @param integer $balanceValue
     */
    public function setBalanceValue($balanceValue)
    {
        $this->balanceValue = $balanceValue;
    }
    /**
     * List of the advanced settings for new engine (OTSolver)
       * 
       * Use this to override the advanced settings set in the UI.
       * 
       * **Type : ** Array of strings
       * 
       * **Example : ** [&quot;FirstSolutionStrategy=NEAREST&quot;, &quot;ParkingTime=30&quot;]
     *
     * @return string[]
     */
    public function getAdvancedSettings()
    {
        return $this->advancedSettings;
    }

    /**
     * List of the advanced settings for new engine (OTSolver)
       * 
       * Use this to override the advanced settings set in the UI.
       * 
       * **Type : ** Array of strings
       * 
       * **Example : ** [&quot;FirstSolutionStrategy=NEAREST&quot;, &quot;ParkingTime=30&quot;]
     *
     * @param string[] $advancedSettings
     */
    public function setAdvancedSettings($advancedSettings)
    {
        $this->advancedSettings = $advancedSettings;
    }

    /**
     * Initializes this TSOptions from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of TSOptions from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'evaluation') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->evaluation = $child;
            $happened = true;
        }
        else if (($xml->localName == 'startFromEvaluationInfo') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->startFromEvaluationInfo = $child;
            $happened = true;
        }
        else if (($xml->localName == 'maxOptimDuration') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->maxOptimDuration = $child;
            $happened = true;
        }
        else if (($xml->localName == 'reloadDuration') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->reloadDuration = $child;
            $happened = true;
        }
        else if (($xml->localName == 'noReload') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->noReload = $child;
            $happened = true;
        }
        else if (($xml->localName == 'distanceType') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->distanceType = $child;
            $happened = true;
        }
        else if (($xml->localName == 'teamId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->teamId = $child;
            $happened = true;
        }
        else if (($xml->localName == 'sendResultToWebhook') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->sendResultToWebhook = $child;
            $happened = true;
        }
        else if (($xml->localName == 'countVisitCostOnceIfSameLocation') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->countVisitCostOnceIfSameLocation = $child;
            $happened = true;
        }
        else if (($xml->localName == 'countDepotsInDeliveryCost') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->countDepotsInDeliveryCost = $child;
            $happened = true;
        }
        else if (($xml->localName == 'excludeVisitCostIfMaxAdditionalCost') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->excludeVisitCostIfMaxAdditionalCost = $child;
            $happened = true;
        }
        else if (($xml->localName == 'routingMethod') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->routingMethod = $child;
            $happened = true;
        }
        else if (($xml->localName == 'allowToll') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->allowToll = $child;
            $happened = true;
        }
        else if (($xml->localName == 'allowTunnel') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->allowTunnel = $child;
            $happened = true;
        }
        else if (($xml->localName == 'allowBridge') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->allowBridge = $child;
            $happened = true;
        }
        else if (($xml->localName == 'allowBoatFerry') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->allowBoatFerry = $child;
            $happened = true;
        }
        else if (($xml->localName == 'vehicleCode') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->vehicleCode = $child;
            $happened = true;
        }
        else if (($xml->localName == 'fuelCode') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->fuelCode = $child;
            $happened = true;
        }
        else if (($xml->localName == 'speedPattern') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->speedPattern = $child;
            $happened = true;
        }
        else if (($xml->localName == 'useForbiddenTransitAreas') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->useForbiddenTransitAreas = $child;
            $happened = true;
        }
        else if (($xml->localName == 'useOTSolver') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->useOTSolver = $child;
            $happened = true;
        }
        else if (($xml->localName == 'balanceType') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->balanceType = $child;
            $happened = true;
        }
        else if (($xml->localName == 'balanceValue') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->balanceValue = $child;
            $happened = true;
        }
        else if (($xml->localName == 'advancedSettings') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->advancedSettings)) {
                $this->advancedSettings = array();
            }
            array_push($this->advancedSettings, $child);
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of TSOptions from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this TSOptions to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->evaluation) {
            $writer->startElementNs(null, 'evaluation', null);
            $writer->text($this->evaluation);
            $writer->endElement();
        }
        if ($this->startFromEvaluationInfo) {
            $writer->startElementNs(null, 'startFromEvaluationInfo', null);
            $writer->text($this->startFromEvaluationInfo);
            $writer->endElement();
        }
        if ($this->maxOptimDuration) {
            $writer->startElementNs(null, 'maxOptimDuration', null);
            $writer->text($this->maxOptimDuration);
            $writer->endElement();
        }
        if ($this->reloadDuration) {
            $writer->startElementNs(null, 'reloadDuration', null);
            $writer->text($this->reloadDuration);
            $writer->endElement();
        }
        if ($this->noReload) {
            $writer->startElementNs(null, 'noReload', null);
            $writer->text($this->noReload);
            $writer->endElement();
        }
        if ($this->distanceType) {
            $writer->startElementNs(null, 'distanceType', null);
            $writer->text($this->distanceType);
            $writer->endElement();
        }
        if ($this->teamId) {
            $writer->startElementNs(null, 'teamId', null);
            $writer->text($this->teamId);
            $writer->endElement();
        }
        if ($this->sendResultToWebhook) {
            $writer->startElementNs(null, 'sendResultToWebhook', null);
            $writer->text($this->sendResultToWebhook);
            $writer->endElement();
        }
        if ($this->countVisitCostOnceIfSameLocation) {
            $writer->startElementNs(null, 'countVisitCostOnceIfSameLocation', null);
            $writer->text($this->countVisitCostOnceIfSameLocation);
            $writer->endElement();
        }
        if ($this->countDepotsInDeliveryCost) {
            $writer->startElementNs(null, 'countDepotsInDeliveryCost', null);
            $writer->text($this->countDepotsInDeliveryCost);
            $writer->endElement();
        }
        if ($this->excludeVisitCostIfMaxAdditionalCost) {
            $writer->startElementNs(null, 'excludeVisitCostIfMaxAdditionalCost', null);
            $writer->text($this->excludeVisitCostIfMaxAdditionalCost);
            $writer->endElement();
        }
        if ($this->routingMethod) {
            $writer->startElementNs(null, 'routingMethod', null);
            $writer->text($this->routingMethod);
            $writer->endElement();
        }
        if ($this->allowToll) {
            $writer->startElementNs(null, 'allowToll', null);
            $writer->text($this->allowToll);
            $writer->endElement();
        }
        if ($this->allowTunnel) {
            $writer->startElementNs(null, 'allowTunnel', null);
            $writer->text($this->allowTunnel);
            $writer->endElement();
        }
        if ($this->allowBridge) {
            $writer->startElementNs(null, 'allowBridge', null);
            $writer->text($this->allowBridge);
            $writer->endElement();
        }
        if ($this->allowBoatFerry) {
            $writer->startElementNs(null, 'allowBoatFerry', null);
            $writer->text($this->allowBoatFerry);
            $writer->endElement();
        }
        if ($this->vehicleCode) {
            $writer->startElementNs(null, 'vehicleCode', null);
            $writer->text($this->vehicleCode);
            $writer->endElement();
        }
        if ($this->fuelCode) {
            $writer->startElementNs(null, 'fuelCode', null);
            $writer->text($this->fuelCode);
            $writer->endElement();
        }
        if ($this->speedPattern) {
            $writer->startElementNs(null, 'speedPattern', null);
            $writer->text($this->speedPattern);
            $writer->endElement();
        }
        if ($this->useForbiddenTransitAreas) {
            $writer->startElementNs(null, 'useForbiddenTransitAreas', null);
            $writer->text($this->useForbiddenTransitAreas);
            $writer->endElement();
        }
        if ($this->useOTSolver) {
            $writer->startElementNs(null, 'useOTSolver', null);
            $writer->text($this->useOTSolver);
            $writer->endElement();
        }
        if ($this->balanceType) {
            $writer->startElementNs(null, 'balanceType', null);
            $writer->text($this->balanceType);
            $writer->endElement();
        }
        if ($this->balanceValue) {
            $writer->startElementNs(null, 'balanceValue', null);
            $writer->text($this->balanceValue);
            $writer->endElement();
        }
        if ($this->advancedSettings) {
            foreach ($this->advancedSettings as $i => $x) {
                $writer->startElementNs(null, 'advancedSettings', null);
                $writer->text($x);
                $writer->endElement();
            }
        }
    }
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Optim;

/**
 * (no documentation provided)
 */
class TSObject
{

    /**
     * Constructs a TSObject from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }


    /**
     * Initializes this TSObject from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of TSObject from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        return false;
    }

    /**
     * Sets a known attribute of TSObject from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this TSObject to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
    }
}

namespace Com\Geoconcept\Toursolver\Imminent\Model;

/**
 * (no documentation provided)
 */
class ImminentOperationalOrderData
{

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Imminent\Model\ImminentOrderSatisfaction
     */
    private $satisfaction;

    /**
     * Constructs a ImminentOperationalOrderData from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Imminent\Model\ImminentOrderSatisfaction
     */
    public function getSatisfaction()
    {
        return $this->satisfaction;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Imminent\Model\ImminentOrderSatisfaction $satisfaction
     */
    public function setSatisfaction($satisfaction)
    {
        $this->satisfaction = $satisfaction;
    }

    /**
     * Initializes this ImminentOperationalOrderData from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of ImminentOperationalOrderData from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'satisfaction') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Imminent\Model\ImminentOrderSatisfaction($xml);
            $this->satisfaction = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of ImminentOperationalOrderData from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this ImminentOperationalOrderData to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->satisfaction) {
            $writer->startElementNs(null, 'satisfaction', null);
            $this->satisfaction->writeXmlContents($writer);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Optim;

/**
 * (no documentation provided)
 */
class TSPause
{

    /**
     * the start
     *
     * @var string
     */
    private $start;

    /**
     * the end
     *
     * @var string
     */
    private $end;

    /**
     * Duration
     * 
     * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
     *
     * @var string
     */
    private $duration;

    /**
     * Constructs a TSPause from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * the start
     *
     * @return string
     */
    public function getStart()
    {
        return $this->start;
    }

    /**
     * the start
     *
     * @param string $start
     */
    public function setStart($start)
    {
        $this->start = $start;
    }
    /**
     * the end
     *
     * @return string
     */
    public function getEnd()
    {
        return $this->end;
    }

    /**
     * the end
     *
     * @param string $end
     */
    public function setEnd($end)
    {
        $this->end = $end;
    }
    /**
     * Duration
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
     *
     * @return string
     */
    public function getDuration()
    {
        return $this->duration;
    }

    /**
     * Duration
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
     *
     * @param string $duration
     */
    public function setDuration($duration)
    {
        $this->duration = $duration;
    }

    /**
     * Initializes this TSPause from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of TSPause from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'start') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->start = $child;
            $happened = true;
        }
        else if (($xml->localName == 'end') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->end = $child;
            $happened = true;
        }
        else if (($xml->localName == 'duration') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->duration = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of TSPause from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes this TSPause to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'pause', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this TSPause to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->start) {
            $writer->startElementNs(null, 'start', null);
            $writer->text($this->start);
            $writer->endElement();
        }
        if ($this->end) {
            $writer->startElementNs(null, 'end', null);
            $writer->text($this->end);
            $writer->endElement();
        }
        if ($this->duration) {
            $writer->startElementNs(null, 'duration', null);
            $writer->text($this->duration);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Optim;

/**
 * (no documentation provided)
 */
class TSPlanned
{

    /**
     * day of the stop
     *
     * @var string
     */
    private $dayId;

    /**
     * The position of the stop in the resource tour.
     *
     * @var integer
     */
    private $stopPosition;

    /**
     * The Y coordinate of the stop.
     *
     * @var double
     */
    private $stopY;

    /**
     * The X coordinate of the stop.
     *
     * @var double
     */
    private $stopX;

    /**
     * the ID of the stop or order
     *
     * @var string
     */
    private $stopId;

    /**
     * The stop type
     * 
     * A tour is composed of stops, which can be either customers visits or
     * breaks, like reload breaks, lunch breaks, or even night breaks.
     * 
     * StopTypeConstants are
     * 
     * * 0 = Visit: The stop is an element of the Orders object.
     * 
     * * 1 = Start: The stop is the initial stage (departure) of the tour,
     * occurring at the resource&#39;s start location.
     * 
     * * 2 = End: The stop is the the last stage (arrival) of the tour,
     * occurring at the resource&#39;s stop location.
     * 
     * * 3 = EndBeforeOvernight: The stop is the the last stage (arrival) of
     * the tour, occurring where the resource stopped for the night.
     * 
     * * 4 = ReloadBreak: The stop is a reload break within the tour,
     * occurring at a depot location.
     * 
     * * 5 = LunchBreak: The stop is the lunch break within the tour,
     * occurring anywhere between two other located stops.
     * 
     * * 6 = RestBreak: The stop is a rest break within the tour, occurring
     * anywhere between two located stops.
     * 
     * * 7 = WaitBreak: The stop is a wait break within the tour, occurring
     * before a visit.
     * 
     * * 8 = StartAfterOvernight: The stop is the last stage (arrival) of
     * the tour, it occurs where the resource stopped for the night.
     * tsStopDriveDistance
     * 
     * * 9 = Briefing: The stop is a briefing break within the tour,
     * occurring right after the departure of the tour.
     * 
     * * 10 = DeBriefing: The stop is a wait break within the tour, occurring
     * right before the arrival of the tour.
     *
     * @var integer
     */
    private $stopType;

    /**
     * The drive time from the previous to the current stop.
     * 
     * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;)
     *
     * @var string
     */
    private $stopDriveTime;

    /**
     * The time the stop starts at.
     * 
     * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;)
     *
     * @var string
     */
    private $stopStartTime;

    /**
     * The duration of the stop.
     * 
     * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;)
     *
     * @var string
     */
    private $stopDuration;

    /**
     * The status of the stop.
     * 
     * An order can be on time, late, waited, impossible (non compliant). It can
     * also be a courier service delivery and not planned. See
     * StopStatusConstants for more information about stop status.
     * 
     * 
     * **Type : ** integer.
     * 
     * * 0 = OnTime: The stop begins into the specified visit time window.
     * 
     * * 1 = Late: The stop begins after the specified visit time window.
     * 
     * * 2 = Waited: The resource waits at the stop for the specified stop
     * start time.
     * 
     * * 3 = Impossible: The stop cannot be planned.
     * 
     * * 4 = BadDay: The stop is planned without respect of frequency.
     * 
     * * NotPlanned: The courier service is in charge of a stop or the stop
     * is not included in the planning process.
     * 
     * * BadPrevious : When the visits are split, the parts should follow
     * one another. This status is that of a part following another visit
     * instead of the previous part of the split visit.
     *
     * @var integer
     */
    private $stopStatus;

    /**
     * The drive distance from the previous to the current stop.
     *
     * @var integer
     */
    private $stopDriveDistance;

    /**
     * The tour cumulated driven distance at the stop.
     *
     * @var integer
     */
    private $stopElapsedDistance;

    /**
     * Assigned resource identifier
     *
     * @var string
     */
    private $resourceId;

    /**
     * Constructs a TSPlanned from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * day of the stop
     *
     * @return string
     */
    public function getDayId()
    {
        return $this->dayId;
    }

    /**
     * day of the stop
     *
     * @param string $dayId
     */
    public function setDayId($dayId)
    {
        $this->dayId = $dayId;
    }
    /**
     * The position of the stop in the resource tour.
     *
     * @return integer
     */
    public function getStopPosition()
    {
        return $this->stopPosition;
    }

    /**
     * The position of the stop in the resource tour.
     *
     * @param integer $stopPosition
     */
    public function setStopPosition($stopPosition)
    {
        $this->stopPosition = $stopPosition;
    }
    /**
     * The Y coordinate of the stop.
     *
     * @return double
     */
    public function getStopY()
    {
        return $this->stopY;
    }

    /**
     * The Y coordinate of the stop.
     *
     * @param double $stopY
     */
    public function setStopY($stopY)
    {
        $this->stopY = $stopY;
    }
    /**
     * The X coordinate of the stop.
     *
     * @return double
     */
    public function getStopX()
    {
        return $this->stopX;
    }

    /**
     * The X coordinate of the stop.
     *
     * @param double $stopX
     */
    public function setStopX($stopX)
    {
        $this->stopX = $stopX;
    }
    /**
     * the ID of the stop or order
     *
     * @return string
     */
    public function getStopId()
    {
        return $this->stopId;
    }

    /**
     * the ID of the stop or order
     *
     * @param string $stopId
     */
    public function setStopId($stopId)
    {
        $this->stopId = $stopId;
    }
    /**
     * The stop type
       * 
       * A tour is composed of stops, which can be either customers visits or
       * breaks, like reload breaks, lunch breaks, or even night breaks.
       * 
       * StopTypeConstants are
       * 
       * * 0 = Visit: The stop is an element of the Orders object.
       * 
       * * 1 = Start: The stop is the initial stage (departure) of the tour,
       * occurring at the resource&#39;s start location.
       * 
       * * 2 = End: The stop is the the last stage (arrival) of the tour,
       * occurring at the resource&#39;s stop location.
       * 
       * * 3 = EndBeforeOvernight: The stop is the the last stage (arrival) of
       * the tour, occurring where the resource stopped for the night.
       * 
       * * 4 = ReloadBreak: The stop is a reload break within the tour,
       * occurring at a depot location.
       * 
       * * 5 = LunchBreak: The stop is the lunch break within the tour,
       * occurring anywhere between two other located stops.
       * 
       * * 6 = RestBreak: The stop is a rest break within the tour, occurring
       * anywhere between two located stops.
       * 
       * * 7 = WaitBreak: The stop is a wait break within the tour, occurring
       * before a visit.
       * 
       * * 8 = StartAfterOvernight: The stop is the last stage (arrival) of
       * the tour, it occurs where the resource stopped for the night.
       * tsStopDriveDistance
       * 
       * * 9 = Briefing: The stop is a briefing break within the tour,
       * occurring right after the departure of the tour.
       * 
       * * 10 = DeBriefing: The stop is a wait break within the tour, occurring
       * right before the arrival of the tour.
     *
     * @return integer
     */
    public function getStopType()
    {
        return $this->stopType;
    }

    /**
     * The stop type
       * 
       * A tour is composed of stops, which can be either customers visits or
       * breaks, like reload breaks, lunch breaks, or even night breaks.
       * 
       * StopTypeConstants are
       * 
       * * 0 = Visit: The stop is an element of the Orders object.
       * 
       * * 1 = Start: The stop is the initial stage (departure) of the tour,
       * occurring at the resource&#39;s start location.
       * 
       * * 2 = End: The stop is the the last stage (arrival) of the tour,
       * occurring at the resource&#39;s stop location.
       * 
       * * 3 = EndBeforeOvernight: The stop is the the last stage (arrival) of
       * the tour, occurring where the resource stopped for the night.
       * 
       * * 4 = ReloadBreak: The stop is a reload break within the tour,
       * occurring at a depot location.
       * 
       * * 5 = LunchBreak: The stop is the lunch break within the tour,
       * occurring anywhere between two other located stops.
       * 
       * * 6 = RestBreak: The stop is a rest break within the tour, occurring
       * anywhere between two located stops.
       * 
       * * 7 = WaitBreak: The stop is a wait break within the tour, occurring
       * before a visit.
       * 
       * * 8 = StartAfterOvernight: The stop is the last stage (arrival) of
       * the tour, it occurs where the resource stopped for the night.
       * tsStopDriveDistance
       * 
       * * 9 = Briefing: The stop is a briefing break within the tour,
       * occurring right after the departure of the tour.
       * 
       * * 10 = DeBriefing: The stop is a wait break within the tour, occurring
       * right before the arrival of the tour.
     *
     * @param integer $stopType
     */
    public function setStopType($stopType)
    {
        $this->stopType = $stopType;
    }
    /**
     * The drive time from the previous to the current stop.
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;)
     *
     * @return string
     */
    public function getStopDriveTime()
    {
        return $this->stopDriveTime;
    }

    /**
     * The drive time from the previous to the current stop.
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;)
     *
     * @param string $stopDriveTime
     */
    public function setStopDriveTime($stopDriveTime)
    {
        $this->stopDriveTime = $stopDriveTime;
    }
    /**
     * The time the stop starts at.
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;)
     *
     * @return string
     */
    public function getStopStartTime()
    {
        return $this->stopStartTime;
    }

    /**
     * The time the stop starts at.
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;)
     *
     * @param string $stopStartTime
     */
    public function setStopStartTime($stopStartTime)
    {
        $this->stopStartTime = $stopStartTime;
    }
    /**
     * The duration of the stop.
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;)
     *
     * @return string
     */
    public function getStopDuration()
    {
        return $this->stopDuration;
    }

    /**
     * The duration of the stop.
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;)
     *
     * @param string $stopDuration
     */
    public function setStopDuration($stopDuration)
    {
        $this->stopDuration = $stopDuration;
    }
    /**
     * The status of the stop.
       * 
       * An order can be on time, late, waited, impossible (non compliant). It can
       * also be a courier service delivery and not planned. See
       * StopStatusConstants for more information about stop status.
       * 
       * 
       * **Type : ** integer.
       * 
       * * 0 = OnTime: The stop begins into the specified visit time window.
       * 
       * * 1 = Late: The stop begins after the specified visit time window.
       * 
       * * 2 = Waited: The resource waits at the stop for the specified stop
       * start time.
       * 
       * * 3 = Impossible: The stop cannot be planned.
       * 
       * * 4 = BadDay: The stop is planned without respect of frequency.
       * 
       * * NotPlanned: The courier service is in charge of a stop or the stop
       * is not included in the planning process.
       * 
       * * BadPrevious : When the visits are split, the parts should follow
       * one another. This status is that of a part following another visit
       * instead of the previous part of the split visit.
     *
     * @return integer
     */
    public function getStopStatus()
    {
        return $this->stopStatus;
    }

    /**
     * The status of the stop.
       * 
       * An order can be on time, late, waited, impossible (non compliant). It can
       * also be a courier service delivery and not planned. See
       * StopStatusConstants for more information about stop status.
       * 
       * 
       * **Type : ** integer.
       * 
       * * 0 = OnTime: The stop begins into the specified visit time window.
       * 
       * * 1 = Late: The stop begins after the specified visit time window.
       * 
       * * 2 = Waited: The resource waits at the stop for the specified stop
       * start time.
       * 
       * * 3 = Impossible: The stop cannot be planned.
       * 
       * * 4 = BadDay: The stop is planned without respect of frequency.
       * 
       * * NotPlanned: The courier service is in charge of a stop or the stop
       * is not included in the planning process.
       * 
       * * BadPrevious : When the visits are split, the parts should follow
       * one another. This status is that of a part following another visit
       * instead of the previous part of the split visit.
     *
     * @param integer $stopStatus
     */
    public function setStopStatus($stopStatus)
    {
        $this->stopStatus = $stopStatus;
    }
    /**
     * The drive distance from the previous to the current stop.
     *
     * @return integer
     */
    public function getStopDriveDistance()
    {
        return $this->stopDriveDistance;
    }

    /**
     * The drive distance from the previous to the current stop.
     *
     * @param integer $stopDriveDistance
     */
    public function setStopDriveDistance($stopDriveDistance)
    {
        $this->stopDriveDistance = $stopDriveDistance;
    }
    /**
     * The tour cumulated driven distance at the stop.
     *
     * @return integer
     */
    public function getStopElapsedDistance()
    {
        return $this->stopElapsedDistance;
    }

    /**
     * The tour cumulated driven distance at the stop.
     *
     * @param integer $stopElapsedDistance
     */
    public function setStopElapsedDistance($stopElapsedDistance)
    {
        $this->stopElapsedDistance = $stopElapsedDistance;
    }
    /**
     * Assigned resource identifier
     *
     * @return string
     */
    public function getResourceId()
    {
        return $this->resourceId;
    }

    /**
     * Assigned resource identifier
     *
     * @param string $resourceId
     */
    public function setResourceId($resourceId)
    {
        $this->resourceId = $resourceId;
    }

    /**
     * Initializes this TSPlanned from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of TSPlanned from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'dayId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->dayId = $child;
            $happened = true;
        }
        else if (($xml->localName == 'stopPosition') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->stopPosition = $child;
            $happened = true;
        }
        else if (($xml->localName == 'stopY') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->stopY = $child;
            $happened = true;
        }
        else if (($xml->localName == 'stopX') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->stopX = $child;
            $happened = true;
        }
        else if (($xml->localName == 'stopId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->stopId = $child;
            $happened = true;
        }
        else if (($xml->localName == 'stopType') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->stopType = $child;
            $happened = true;
        }
        else if (($xml->localName == 'stopDriveTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->stopDriveTime = $child;
            $happened = true;
        }
        else if (($xml->localName == 'stopStartTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->stopStartTime = $child;
            $happened = true;
        }
        else if (($xml->localName == 'stopDuration') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->stopDuration = $child;
            $happened = true;
        }
        else if (($xml->localName == 'stopStatus') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->stopStatus = $child;
            $happened = true;
        }
        else if (($xml->localName == 'stopDriveDistance') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->stopDriveDistance = $child;
            $happened = true;
        }
        else if (($xml->localName == 'stopElapsedDistance') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->stopElapsedDistance = $child;
            $happened = true;
        }
        else if (($xml->localName == 'resourceId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->resourceId = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of TSPlanned from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this TSPlanned to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->dayId) {
            $writer->startElementNs(null, 'dayId', null);
            $writer->text($this->dayId);
            $writer->endElement();
        }
        if ($this->stopPosition) {
            $writer->startElementNs(null, 'stopPosition', null);
            $writer->text($this->stopPosition);
            $writer->endElement();
        }
        if ($this->stopY) {
            $writer->startElementNs(null, 'stopY', null);
            $writer->text($this->stopY);
            $writer->endElement();
        }
        if ($this->stopX) {
            $writer->startElementNs(null, 'stopX', null);
            $writer->text($this->stopX);
            $writer->endElement();
        }
        if ($this->stopId) {
            $writer->startElementNs(null, 'stopId', null);
            $writer->text($this->stopId);
            $writer->endElement();
        }
        if ($this->stopType) {
            $writer->startElementNs(null, 'stopType', null);
            $writer->text($this->stopType);
            $writer->endElement();
        }
        if ($this->stopDriveTime) {
            $writer->startElementNs(null, 'stopDriveTime', null);
            $writer->text($this->stopDriveTime);
            $writer->endElement();
        }
        if ($this->stopStartTime) {
            $writer->startElementNs(null, 'stopStartTime', null);
            $writer->text($this->stopStartTime);
            $writer->endElement();
        }
        if ($this->stopDuration) {
            $writer->startElementNs(null, 'stopDuration', null);
            $writer->text($this->stopDuration);
            $writer->endElement();
        }
        if ($this->stopStatus) {
            $writer->startElementNs(null, 'stopStatus', null);
            $writer->text($this->stopStatus);
            $writer->endElement();
        }
        if ($this->stopDriveDistance) {
            $writer->startElementNs(null, 'stopDriveDistance', null);
            $writer->text($this->stopDriveDistance);
            $writer->endElement();
        }
        if ($this->stopElapsedDistance) {
            $writer->startElementNs(null, 'stopElapsedDistance', null);
            $writer->text($this->stopElapsedDistance);
            $writer->endElement();
        }
        if ($this->resourceId) {
            $writer->startElementNs(null, 'resourceId', null);
            $writer->text($this->resourceId);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Optim;

/**
 * (no documentation provided)
 */
class TSSimulation
{

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSDepot[]
     */
    private $depots;

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSResource[]
     */
    private $resources;

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSOrder[]
     */
    private $orders;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $nbQuantities;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $nbCapacities;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $nbTimeWindows;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $nbExtraTravelPenalties;

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSOptions
     */
    private $options;

    /**
     * Constructs a TSSimulation from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSDepot[]
     */
    public function getDepots()
    {
        return $this->depots;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSDepot[] $depots
     */
    public function setDepots($depots)
    {
        $this->depots = $depots;
    }
    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSResource[]
     */
    public function getResources()
    {
        return $this->resources;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSResource[] $resources
     */
    public function setResources($resources)
    {
        $this->resources = $resources;
    }
    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSOrder[]
     */
    public function getOrders()
    {
        return $this->orders;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSOrder[] $orders
     */
    public function setOrders($orders)
    {
        $this->orders = $orders;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getNbQuantities()
    {
        return $this->nbQuantities;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $nbQuantities
     */
    public function setNbQuantities($nbQuantities)
    {
        $this->nbQuantities = $nbQuantities;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getNbCapacities()
    {
        return $this->nbCapacities;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $nbCapacities
     */
    public function setNbCapacities($nbCapacities)
    {
        $this->nbCapacities = $nbCapacities;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getNbTimeWindows()
    {
        return $this->nbTimeWindows;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $nbTimeWindows
     */
    public function setNbTimeWindows($nbTimeWindows)
    {
        $this->nbTimeWindows = $nbTimeWindows;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getNbExtraTravelPenalties()
    {
        return $this->nbExtraTravelPenalties;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $nbExtraTravelPenalties
     */
    public function setNbExtraTravelPenalties($nbExtraTravelPenalties)
    {
        $this->nbExtraTravelPenalties = $nbExtraTravelPenalties;
    }
    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSOptions
     */
    public function getOptions()
    {
        return $this->options;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSOptions $options
     */
    public function setOptions($options)
    {
        $this->options = $options;
    }

    /**
     * Initializes this TSSimulation from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of TSSimulation from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'depots') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSDepot($xml);
            if (!isset($this->depots)) {
                $this->depots = array();
            }
            array_push($this->depots, $child);
            $happened = true;
        }
        else if (($xml->localName == 'resources') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSResource($xml);
            if (!isset($this->resources)) {
                $this->resources = array();
            }
            array_push($this->resources, $child);
            $happened = true;
        }
        else if (($xml->localName == 'orders') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSOrder($xml);
            if (!isset($this->orders)) {
                $this->orders = array();
            }
            array_push($this->orders, $child);
            $happened = true;
        }
        else if (($xml->localName == 'nbQuantities') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->nbQuantities = $child;
            $happened = true;
        }
        else if (($xml->localName == 'nbCapacities') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->nbCapacities = $child;
            $happened = true;
        }
        else if (($xml->localName == 'nbTimeWindows') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->nbTimeWindows = $child;
            $happened = true;
        }
        else if (($xml->localName == 'nbExtraTravelPenalties') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->nbExtraTravelPenalties = $child;
            $happened = true;
        }
        else if (($xml->localName == 'options') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSOptions($xml);
            $this->options = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of TSSimulation from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this TSSimulation to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->depots) {
            foreach ($this->depots as $i => $x) {
                $writer->startElementNs(null, 'depots', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->resources) {
            foreach ($this->resources as $i => $x) {
                $writer->startElementNs(null, 'resources', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->orders) {
            foreach ($this->orders as $i => $x) {
                $writer->startElementNs(null, 'orders', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->nbQuantities) {
            $writer->startElementNs(null, 'nbQuantities', null);
            $writer->text($this->nbQuantities);
            $writer->endElement();
        }
        if ($this->nbCapacities) {
            $writer->startElementNs(null, 'nbCapacities', null);
            $writer->text($this->nbCapacities);
            $writer->endElement();
        }
        if ($this->nbTimeWindows) {
            $writer->startElementNs(null, 'nbTimeWindows', null);
            $writer->text($this->nbTimeWindows);
            $writer->endElement();
        }
        if ($this->nbExtraTravelPenalties) {
            $writer->startElementNs(null, 'nbExtraTravelPenalties', null);
            $writer->text($this->nbExtraTravelPenalties);
            $writer->endElement();
        }
        if ($this->options) {
            $writer->startElementNs(null, 'options', null);
            $this->options->writeXmlContents($writer);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Optim;

/**
 * (no documentation provided)
 */
class TSTour
{

    /**
     * day of the tour
     *
     * @var string
     */
    private $dayId;

    /**
     * Assigned resource identifier
     *
     * @var string
     */
    private $resourceId;

    /**
     * drive distance for this tour
     *
     * @var integer
     */
    private $travelDistance;

    /**
     * drive duration for this tour
     *
     * @var string
     */
    private $travelDuration;

    /**
     * List of resource capacities
     *
     * @var double[]
     */
    private $resourceCapacities;

    /**
     * List of used capacities
     * 
     * Tour used capacities can exceed resource capacities if the tour contains
     * one or several stops to a depot.
     *
     * @var double[]
     */
    private $usedCapacities;

    /**
     * Total delivery cost of the tour
     * 
     * Delivery cost depends on PenaltyPerVisit defined on resources and
     * configuration specified in options (see countDepotsInDeliveryCost and
     * countVisitCostOnceIfSameLocation)
     *
     * @var double
     */
    private $deliveryCost;

    /**
     * Orders planned in this tour
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSPlanned[]
     */
    private $plannedOrders;

    /**
     * Additional cost
     * 
     * Additional cost depends on additional cost configuration specified on
     * resources and orders
     *
     * @var double
     */
    private $additionalCost;

    /**
     * Total cost
     * 
     * Total cost = (delivery cost) + (additional cost)
     *
     * @var double
     */
    private $totalCost;

    /**
     * ReloadNb
     * 
     * Number of reloads during this tour
     *
     * @var integer
     */
    private $reloadNb;

    /**
     * Constructs a TSTour from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * day of the tour
     *
     * @return string
     */
    public function getDayId()
    {
        return $this->dayId;
    }

    /**
     * day of the tour
     *
     * @param string $dayId
     */
    public function setDayId($dayId)
    {
        $this->dayId = $dayId;
    }
    /**
     * Assigned resource identifier
     *
     * @return string
     */
    public function getResourceId()
    {
        return $this->resourceId;
    }

    /**
     * Assigned resource identifier
     *
     * @param string $resourceId
     */
    public function setResourceId($resourceId)
    {
        $this->resourceId = $resourceId;
    }
    /**
     * drive distance for this tour
     *
     * @return integer
     */
    public function getTravelDistance()
    {
        return $this->travelDistance;
    }

    /**
     * drive distance for this tour
     *
     * @param integer $travelDistance
     */
    public function setTravelDistance($travelDistance)
    {
        $this->travelDistance = $travelDistance;
    }
    /**
     * drive duration for this tour
     *
     * @return string
     */
    public function getTravelDuration()
    {
        return $this->travelDuration;
    }

    /**
     * drive duration for this tour
     *
     * @param string $travelDuration
     */
    public function setTravelDuration($travelDuration)
    {
        $this->travelDuration = $travelDuration;
    }
    /**
     * List of resource capacities
     *
     * @return double[]
     */
    public function getResourceCapacities()
    {
        return $this->resourceCapacities;
    }

    /**
     * List of resource capacities
     *
     * @param double[] $resourceCapacities
     */
    public function setResourceCapacities($resourceCapacities)
    {
        $this->resourceCapacities = $resourceCapacities;
    }
    /**
     * List of used capacities
       * 
       * Tour used capacities can exceed resource capacities if the tour contains
       * one or several stops to a depot.
     *
     * @return double[]
     */
    public function getUsedCapacities()
    {
        return $this->usedCapacities;
    }

    /**
     * List of used capacities
       * 
       * Tour used capacities can exceed resource capacities if the tour contains
       * one or several stops to a depot.
     *
     * @param double[] $usedCapacities
     */
    public function setUsedCapacities($usedCapacities)
    {
        $this->usedCapacities = $usedCapacities;
    }
    /**
     * Total delivery cost of the tour
       * 
       * Delivery cost depends on PenaltyPerVisit defined on resources and
       * configuration specified in options (see countDepotsInDeliveryCost and
       * countVisitCostOnceIfSameLocation)
     *
     * @return double
     */
    public function getDeliveryCost()
    {
        return $this->deliveryCost;
    }

    /**
     * Total delivery cost of the tour
       * 
       * Delivery cost depends on PenaltyPerVisit defined on resources and
       * configuration specified in options (see countDepotsInDeliveryCost and
       * countVisitCostOnceIfSameLocation)
     *
     * @param double $deliveryCost
     */
    public function setDeliveryCost($deliveryCost)
    {
        $this->deliveryCost = $deliveryCost;
    }
    /**
     * Orders planned in this tour
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSPlanned[]
     */
    public function getPlannedOrders()
    {
        return $this->plannedOrders;
    }

    /**
     * Orders planned in this tour
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSPlanned[] $plannedOrders
     */
    public function setPlannedOrders($plannedOrders)
    {
        $this->plannedOrders = $plannedOrders;
    }
    /**
     * Additional cost
       * 
       * Additional cost depends on additional cost configuration specified on
       * resources and orders
     *
     * @return double
     */
    public function getAdditionalCost()
    {
        return $this->additionalCost;
    }

    /**
     * Additional cost
       * 
       * Additional cost depends on additional cost configuration specified on
       * resources and orders
     *
     * @param double $additionalCost
     */
    public function setAdditionalCost($additionalCost)
    {
        $this->additionalCost = $additionalCost;
    }
    /**
     * Total cost
       * 
       * Total cost = (delivery cost) + (additional cost)
     *
     * @return double
     */
    public function getTotalCost()
    {
        return $this->totalCost;
    }

    /**
     * Total cost
       * 
       * Total cost = (delivery cost) + (additional cost)
     *
     * @param double $totalCost
     */
    public function setTotalCost($totalCost)
    {
        $this->totalCost = $totalCost;
    }
    /**
     * ReloadNb
       * 
       * Number of reloads during this tour
     *
     * @return integer
     */
    public function getReloadNb()
    {
        return $this->reloadNb;
    }

    /**
     * ReloadNb
       * 
       * Number of reloads during this tour
     *
     * @param integer $reloadNb
     */
    public function setReloadNb($reloadNb)
    {
        $this->reloadNb = $reloadNb;
    }

    /**
     * Initializes this TSTour from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of TSTour from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'dayId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->dayId = $child;
            $happened = true;
        }
        else if (($xml->localName == 'resourceId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->resourceId = $child;
            $happened = true;
        }
        else if (($xml->localName == 'travelDistance') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->travelDistance = $child;
            $happened = true;
        }
        else if (($xml->localName == 'travelDuration') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->travelDuration = $child;
            $happened = true;
        }
        else if (($xml->localName == 'resourceCapacities') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->resourceCapacities)) {
                $this->resourceCapacities = array();
            }
            array_push($this->resourceCapacities, $child);
            $happened = true;
        }
        else if (($xml->localName == 'usedCapacities') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->usedCapacities)) {
                $this->usedCapacities = array();
            }
            array_push($this->usedCapacities, $child);
            $happened = true;
        }
        else if (($xml->localName == 'deliveryCost') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->deliveryCost = $child;
            $happened = true;
        }
        else if (($xml->localName == 'plannedOrders') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSPlanned($xml);
            if (!isset($this->plannedOrders)) {
                $this->plannedOrders = array();
            }
            array_push($this->plannedOrders, $child);
            $happened = true;
        }
        else if (($xml->localName == 'additionalCost') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->additionalCost = $child;
            $happened = true;
        }
        else if (($xml->localName == 'totalCost') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->totalCost = $child;
            $happened = true;
        }
        else if (($xml->localName == 'reloadNb') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->reloadNb = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of TSTour from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this TSTour to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->dayId) {
            $writer->startElementNs(null, 'dayId', null);
            $writer->text($this->dayId);
            $writer->endElement();
        }
        if ($this->resourceId) {
            $writer->startElementNs(null, 'resourceId', null);
            $writer->text($this->resourceId);
            $writer->endElement();
        }
        if ($this->travelDistance) {
            $writer->startElementNs(null, 'travelDistance', null);
            $writer->text($this->travelDistance);
            $writer->endElement();
        }
        if ($this->travelDuration) {
            $writer->startElementNs(null, 'travelDuration', null);
            $writer->text($this->travelDuration);
            $writer->endElement();
        }
        if ($this->resourceCapacities) {
            foreach ($this->resourceCapacities as $i => $x) {
                $writer->startElementNs(null, 'resourceCapacities', null);
                $writer->text($x);
                $writer->endElement();
            }
        }
        if ($this->usedCapacities) {
            foreach ($this->usedCapacities as $i => $x) {
                $writer->startElementNs(null, 'usedCapacities', null);
                $writer->text($x);
                $writer->endElement();
            }
        }
        if ($this->deliveryCost) {
            $writer->startElementNs(null, 'deliveryCost', null);
            $writer->text($this->deliveryCost);
            $writer->endElement();
        }
        if ($this->plannedOrders) {
            foreach ($this->plannedOrders as $i => $x) {
                $writer->startElementNs(null, 'plannedOrders', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->additionalCost) {
            $writer->startElementNs(null, 'additionalCost', null);
            $writer->text($this->additionalCost);
            $writer->endElement();
        }
        if ($this->totalCost) {
            $writer->startElementNs(null, 'totalCost', null);
            $writer->text($this->totalCost);
            $writer->endElement();
        }
        if ($this->reloadNb) {
            $writer->startElementNs(null, 'reloadNb', null);
            $writer->text($this->reloadNb);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Optim;

/**
 * (no documentation provided)
 */
class TSTravelTimeModifier
{

    /**
     * Indicates the offset of the travel time modifier.
     * 
     * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
     * 
     * **Default : ** 0
     *
     * @var string
     */
    private $offset;

    /**
     * Indicates the value of the travel time modifier.
     * 
     * When reaching a location situated in a large city, one may want to take
     * into account driving difficulties, such as narrow streets and congestion.
     * The travel time modifier enables to increase the travel times around a
     * location. It is describes by three values. The value by which multiply the
     * travel times around the location (tsDepotTravelTimeModifierValue), the
     * portion of the travel time on which the modifier applies (*length*)
     * an offset to add to any travel duration leaving
     * or reaching the location (*offSet*).
     * 
     * **Example : **
     * 
     * * Set tsResource TravelTimeModifier Value to 1.5, tsResource TravelTime Modifier Length to 300
     * and tsResource TravelTimeModifier OffSet to 60 for Resource 1
     * 
     * * Set tsDepot TravelTimeModifier Value to 2, tsDepot TravelTimeModifier Length to 420 and
     * tsDepot TravelTimeModifier OffSet to 0 for Depot 1
     * 
     * If the initial travel duration between Resource 1 and Depot 1
     * was 1000, one obtains a travel time 360 * 1.5 + 60 + 280 + 420 * 2 + 0 = 1660
     * 
     * **Type : ** float **Default : ** 1
     *
     * @var double
     */
    private $value;

    /**
     * Indicates the duration on which to apply the travel time modifier.
     * 
     * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
     * 
     * **Default : ** 0
     *
     * @var string
     */
    private $length;

    /**
     * Constructs a TSTravelTimeModifier from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * Indicates the offset of the travel time modifier.
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
       * 
       * **Default : ** 0
     *
     * @return string
     */
    public function getOffset()
    {
        return $this->offset;
    }

    /**
     * Indicates the offset of the travel time modifier.
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
       * 
       * **Default : ** 0
     *
     * @param string $offset
     */
    public function setOffset($offset)
    {
        $this->offset = $offset;
    }
    /**
     * Indicates the value of the travel time modifier.
       * 
       * When reaching a location situated in a large city, one may want to take
       * into account driving difficulties, such as narrow streets and congestion.
       * The travel time modifier enables to increase the travel times around a
       * location. It is describes by three values. The value by which multiply the
       * travel times around the location (tsDepotTravelTimeModifierValue), the
       * portion of the travel time on which the modifier applies (*length*)
       * an offset to add to any travel duration leaving
       * or reaching the location (*offSet*).
       * 
       * **Example : **
       * 
       * * Set tsResource TravelTimeModifier Value to 1.5, tsResource TravelTime Modifier Length to 300
       * and tsResource TravelTimeModifier OffSet to 60 for Resource 1
       * 
       * * Set tsDepot TravelTimeModifier Value to 2, tsDepot TravelTimeModifier Length to 420 and
       * tsDepot TravelTimeModifier OffSet to 0 for Depot 1
       * 
       * If the initial travel duration between Resource 1 and Depot 1
       * was 1000, one obtains a travel time 360 * 1.5 + 60 + 280 + 420 * 2 + 0 = 1660
       * 
       * **Type : ** float **Default : ** 1
     *
     * @return double
     */
    public function getValue()
    {
        return $this->value;
    }

    /**
     * Indicates the value of the travel time modifier.
       * 
       * When reaching a location situated in a large city, one may want to take
       * into account driving difficulties, such as narrow streets and congestion.
       * The travel time modifier enables to increase the travel times around a
       * location. It is describes by three values. The value by which multiply the
       * travel times around the location (tsDepotTravelTimeModifierValue), the
       * portion of the travel time on which the modifier applies (*length*)
       * an offset to add to any travel duration leaving
       * or reaching the location (*offSet*).
       * 
       * **Example : **
       * 
       * * Set tsResource TravelTimeModifier Value to 1.5, tsResource TravelTime Modifier Length to 300
       * and tsResource TravelTimeModifier OffSet to 60 for Resource 1
       * 
       * * Set tsDepot TravelTimeModifier Value to 2, tsDepot TravelTimeModifier Length to 420 and
       * tsDepot TravelTimeModifier OffSet to 0 for Depot 1
       * 
       * If the initial travel duration between Resource 1 and Depot 1
       * was 1000, one obtains a travel time 360 * 1.5 + 60 + 280 + 420 * 2 + 0 = 1660
       * 
       * **Type : ** float **Default : ** 1
     *
     * @param double $value
     */
    public function setValue($value)
    {
        $this->value = $value;
    }
    /**
     * Indicates the duration on which to apply the travel time modifier.
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
       * 
       * **Default : ** 0
     *
     * @return string
     */
    public function getLength()
    {
        return $this->length;
    }

    /**
     * Indicates the duration on which to apply the travel time modifier.
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
       * 
       * **Default : ** 0
     *
     * @param string $length
     */
    public function setLength($length)
    {
        $this->length = $length;
    }

    /**
     * Initializes this TSTravelTimeModifier from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of TSTravelTimeModifier from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'offset') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->offset = $child;
            $happened = true;
        }
        else if (($xml->localName == 'value') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->value = $child;
            $happened = true;
        }
        else if (($xml->localName == 'length') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->length = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of TSTravelTimeModifier from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this TSTravelTimeModifier to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->offset) {
            $writer->startElementNs(null, 'offset', null);
            $writer->text($this->offset);
            $writer->endElement();
        }
        if ($this->value) {
            $writer->startElementNs(null, 'value', null);
            $writer->text($this->value);
            $writer->endElement();
        }
        if ($this->length) {
            $writer->startElementNs(null, 'length', null);
            $writer->text($this->length);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Optim;

/**
 * (no documentation provided)
 */
class TSWarning
{

    /**
     * type of object causing the warning
     *
     * @var string
     */
    private $objectType;

    /**
     * if of object causing the warning
     *
     * @var string
     */
    private $id;

    /**
     * id of constraint causing the warning
     *
     * @var integer
     */
    private $constraint;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $value;

    /**
     * warning message
     *
     * @var string
     */
    private $message;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $messageId;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $i18nMessageCode;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $constraintName;

    /**
     * Constructs a TSWarning from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * type of object causing the warning
     *
     * @return string
     */
    public function getObjectType()
    {
        return $this->objectType;
    }

    /**
     * type of object causing the warning
     *
     * @param string $objectType
     */
    public function setObjectType($objectType)
    {
        $this->objectType = $objectType;
    }
    /**
     * if of object causing the warning
     *
     * @return string
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * if of object causing the warning
     *
     * @param string $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }
    /**
     * id of constraint causing the warning
     *
     * @return integer
     */
    public function getConstraint()
    {
        return $this->constraint;
    }

    /**
     * id of constraint causing the warning
     *
     * @param integer $constraint
     */
    public function setConstraint($constraint)
    {
        $this->constraint = $constraint;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getValue()
    {
        return $this->value;
    }

    /**
     * (no documentation provided)
     *
     * @param string $value
     */
    public function setValue($value)
    {
        $this->value = $value;
    }
    /**
     * warning message
     *
     * @return string
     */
    public function getMessage()
    {
        return $this->message;
    }

    /**
     * warning message
     *
     * @param string $message
     */
    public function setMessage($message)
    {
        $this->message = $message;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getMessageId()
    {
        return $this->messageId;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $messageId
     */
    public function setMessageId($messageId)
    {
        $this->messageId = $messageId;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getI18nMessageCode()
    {
        return $this->i18nMessageCode;
    }

    /**
     * (no documentation provided)
     *
     * @param string $i18nMessageCode
     */
    public function setI18nMessageCode($i18nMessageCode)
    {
        $this->i18nMessageCode = $i18nMessageCode;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getConstraintName()
    {
        return $this->constraintName;
    }

    /**
     * (no documentation provided)
     *
     * @param string $constraintName
     */
    public function setConstraintName($constraintName)
    {
        $this->constraintName = $constraintName;
    }

    /**
     * Initializes this TSWarning from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of TSWarning from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'objectType') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->objectType = $child;
            $happened = true;
        }
        else if (($xml->localName == 'id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'constraint') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->constraint = $child;
            $happened = true;
        }
        else if (($xml->localName == 'value') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->value = $child;
            $happened = true;
        }
        else if (($xml->localName == 'message') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->message = $child;
            $happened = true;
        }
        else if (($xml->localName == 'messageId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->messageId = $child;
            $happened = true;
        }
        else if (($xml->localName == 'i18nMessageCode') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->i18nMessageCode = $child;
            $happened = true;
        }
        else if (($xml->localName == 'constraintName') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->constraintName = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of TSWarning from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this TSWarning to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->objectType) {
            $writer->startElementNs(null, 'objectType', null);
            $writer->text($this->objectType);
            $writer->endElement();
        }
        if ($this->id) {
            $writer->startElementNs(null, 'id', null);
            $writer->text($this->id);
            $writer->endElement();
        }
        if ($this->constraint) {
            $writer->startElementNs(null, 'constraint', null);
            $writer->text($this->constraint);
            $writer->endElement();
        }
        if ($this->value) {
            $writer->startElementNs(null, 'value', null);
            $writer->text($this->value);
            $writer->endElement();
        }
        if ($this->message) {
            $writer->startElementNs(null, 'message', null);
            $writer->text($this->message);
            $writer->endElement();
        }
        if ($this->messageId) {
            $writer->startElementNs(null, 'messageId', null);
            $writer->text($this->messageId);
            $writer->endElement();
        }
        if ($this->i18nMessageCode) {
            $writer->startElementNs(null, 'i18nMessageCode', null);
            $writer->text($this->i18nMessageCode);
            $writer->endElement();
        }
        if ($this->constraintName) {
            $writer->startElementNs(null, 'constraintName', null);
            $writer->text($this->constraintName);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Resource;

/**
 * (no documentation provided)
 */
class DayOff
{

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Resource\SimpleDate
     */
    private $start;

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Resource\SimpleDate
     */
    private $end;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $reason;

    /**
     * Constructs a DayOff from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Resource\SimpleDate
     */
    public function getStart()
    {
        return $this->start;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Resource\SimpleDate $start
     */
    public function setStart($start)
    {
        $this->start = $start;
    }
    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Resource\SimpleDate
     */
    public function getEnd()
    {
        return $this->end;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Resource\SimpleDate $end
     */
    public function setEnd($end)
    {
        $this->end = $end;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getReason()
    {
        return $this->reason;
    }

    /**
     * (no documentation provided)
     *
     * @param string $reason
     */
    public function setReason($reason)
    {
        $this->reason = $reason;
    }

    /**
     * Initializes this DayOff from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of DayOff from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'start') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Resource\SimpleDate($xml);
            $this->start = $child;
            $happened = true;
        }
        else if (($xml->localName == 'end') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Resource\SimpleDate($xml);
            $this->end = $child;
            $happened = true;
        }
        else if (($xml->localName == 'reason') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->reason = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of DayOff from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this DayOff to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->start) {
            $writer->startElementNs(null, 'start', null);
            $this->start->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->end) {
            $writer->startElementNs(null, 'end', null);
            $this->end->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->reason) {
            $writer->startElementNs(null, 'reason', null);
            $writer->text($this->reason);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class AddClientsRequest
{

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Mycustomers\Api\Model\ClientEntity[]
     */
    private $clients;

    /**
     * Constructs a AddClientsRequest from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Mycustomers\Api\Model\ClientEntity[]
     */
    public function getClients()
    {
        return $this->clients;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Mycustomers\Api\Model\ClientEntity[] $clients
     */
    public function setClients($clients)
    {
        $this->clients = $clients;
    }

    /**
     * Initializes this AddClientsRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of AddClientsRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'clients') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Mycustomers\Api\Model\ClientEntity($xml);
            if (!isset($this->clients)) {
                $this->clients = array();
            }
            array_push($this->clients, $child);
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of AddClientsRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this AddClientsRequest to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->clients) {
            foreach ($this->clients as $i => $x) {
                $writer->startElementNs(null, 'clients', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class AddOperationalOrdersRequest
{

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Export\OperationalOrder[]
     */
    private $orders;

    /**
     * Constructs a AddOperationalOrdersRequest from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Export\OperationalOrder[]
     */
    public function getOrders()
    {
        return $this->orders;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Export\OperationalOrder[] $orders
     */
    public function setOrders($orders)
    {
        $this->orders = $orders;
    }

    /**
     * Initializes this AddOperationalOrdersRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of AddOperationalOrdersRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'orders') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Export\OperationalOrder($xml);
            if (!isset($this->orders)) {
                $this->orders = array();
            }
            array_push($this->orders, $child);
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of AddOperationalOrdersRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this AddOperationalOrdersRequest to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->orders) {
            foreach ($this->orders as $i => $x) {
                $writer->startElementNs(null, 'orders', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class AddPositionsRequest
{

    /**
     * list of positions
     *
     * @var \Com\Geoconcept\Toursolver\Export\GpsPosition[]
     */
    private $positions;

    /**
     * Mobile user login
     *
     * @var string
     */
    private $userLogin;

    /**
     * Constructs a AddPositionsRequest from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * list of positions
     *
     * @return \Com\Geoconcept\Toursolver\Export\GpsPosition[]
     */
    public function getPositions()
    {
        return $this->positions;
    }

    /**
     * list of positions
     *
     * @param \Com\Geoconcept\Toursolver\Export\GpsPosition[] $positions
     */
    public function setPositions($positions)
    {
        $this->positions = $positions;
    }
    /**
     * Mobile user login
     *
     * @return string
     */
    public function getUserLogin()
    {
        return $this->userLogin;
    }

    /**
     * Mobile user login
     *
     * @param string $userLogin
     */
    public function setUserLogin($userLogin)
    {
        $this->userLogin = $userLogin;
    }

    /**
     * Initializes this AddPositionsRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of AddPositionsRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'positions') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Export\GpsPosition($xml);
            if (!isset($this->positions)) {
                $this->positions = array();
            }
            array_push($this->positions, $child);
            $happened = true;
        }
        else if (($xml->localName == 'userLogin') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->userLogin = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of AddPositionsRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes this AddPositionsRequest to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'addPositionsRequest', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this AddPositionsRequest to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->positions) {
            foreach ($this->positions as $i => $x) {
                $writer->startElementNs(null, 'positions', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->userLogin) {
            $writer->startElementNs(null, 'userLogin', null);
            $writer->text($this->userLogin);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class AddVisitsResult
{

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $status;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $message;

    /**
     * Constructs a AddVisitsResult from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getStatus()
    {
        return $this->status;
    }

    /**
     * (no documentation provided)
     *
     * @param string $status
     */
    public function setStatus($status)
    {
        $this->status = $status;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getMessage()
    {
        return $this->message;
    }

    /**
     * (no documentation provided)
     *
     * @param string $message
     */
    public function setMessage($message)
    {
        $this->message = $message;
    }

    /**
     * Initializes this AddVisitsResult from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of AddVisitsResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'status') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->status = $child;
            $happened = true;
        }
        else if (($xml->localName == 'message') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->message = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of AddVisitsResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes this AddVisitsResult to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'addVisitsResult', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this AddVisitsResult to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->status) {
            $writer->startElementNs(null, 'status', null);
            $writer->text($this->status);
            $writer->endElement();
        }
        if ($this->message) {
            $writer->startElementNs(null, 'message', null);
            $writer->text($this->message);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class CheckScheduleSlots
{

    /**
     * List of slots
     *
     * @var \Com\Geoconcept\Ebooking\Api\Model\ScheduleTimeWindow[]
     */
    private $timeWindows;

    /**
     * Maximum distance in km to closest scheduled order
     * Set it to 0 if you don&#39;t want any limit
     *
     * @var integer
     */
    private $maxDistance;

    /**
     * Latitude of the appointment to reschedule
     *
     * @var double
     */
    private $lat;

    /**
     * Longitude of the appointment to reschedule
     *
     * @var double
     */
    private $lon;

    /**
     * Day date for which you want the slots
     *
     * @var integer
     */
    private $day;

    /**
     * If false compute flying distance between position, otherwise driven distance
     *
     * @var boolean
     */
    private $computeDistances;

    /**
     * Constructs a CheckScheduleSlots from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * List of slots
     *
     * @return \Com\Geoconcept\Ebooking\Api\Model\ScheduleTimeWindow[]
     */
    public function getTimeWindows()
    {
        return $this->timeWindows;
    }

    /**
     * List of slots
     *
     * @param \Com\Geoconcept\Ebooking\Api\Model\ScheduleTimeWindow[] $timeWindows
     */
    public function setTimeWindows($timeWindows)
    {
        $this->timeWindows = $timeWindows;
    }
    /**
     * Maximum distance in km to closest scheduled order
       * Set it to 0 if you don&#39;t want any limit
     *
     * @return integer
     */
    public function getMaxDistance()
    {
        return $this->maxDistance;
    }

    /**
     * Maximum distance in km to closest scheduled order
       * Set it to 0 if you don&#39;t want any limit
     *
     * @param integer $maxDistance
     */
    public function setMaxDistance($maxDistance)
    {
        $this->maxDistance = $maxDistance;
    }
    /**
     * Latitude of the appointment to reschedule
     *
     * @return double
     */
    public function getLat()
    {
        return $this->lat;
    }

    /**
     * Latitude of the appointment to reschedule
     *
     * @param double $lat
     */
    public function setLat($lat)
    {
        $this->lat = $lat;
    }
    /**
     * Longitude of the appointment to reschedule
     *
     * @return double
     */
    public function getLon()
    {
        return $this->lon;
    }

    /**
     * Longitude of the appointment to reschedule
     *
     * @param double $lon
     */
    public function setLon($lon)
    {
        $this->lon = $lon;
    }
    /**
     * Day date for which you want the slots
     *
     * @return integer
     */
    public function getDay()
    {
        return $this->day;
    }

    /**
     * Day date for which you want the slots
     *
     * @param integer $day
     */
    public function setDay($day)
    {
        $this->day = $day;
    }
    /**
     * If false compute flying distance between position, otherwise driven distance
     *
     * @return boolean
     */
    public function getComputeDistances()
    {
        return $this->computeDistances;
    }

    /**
     * If false compute flying distance between position, otherwise driven distance
     *
     * @param boolean $computeDistances
     */
    public function setComputeDistances($computeDistances)
    {
        $this->computeDistances = $computeDistances;
    }

    /**
     * Initializes this CheckScheduleSlots from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of CheckScheduleSlots from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'timeWindows') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Ebooking\Api\Model\ScheduleTimeWindow($xml);
            if (!isset($this->timeWindows)) {
                $this->timeWindows = array();
            }
            array_push($this->timeWindows, $child);
            $happened = true;
        }
        else if (($xml->localName == 'maxDistance') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->maxDistance = $child;
            $happened = true;
        }
        else if (($xml->localName == 'lat') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->lat = $child;
            $happened = true;
        }
        else if (($xml->localName == 'lon') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->lon = $child;
            $happened = true;
        }
        else if (($xml->localName == 'day') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->day = $child;
            $happened = true;
        }
        else if (($xml->localName == 'computeDistances') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->computeDistances = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of CheckScheduleSlots from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this CheckScheduleSlots to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->timeWindows) {
            foreach ($this->timeWindows as $i => $x) {
                $writer->startElementNs(null, 'timeWindows', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->maxDistance) {
            $writer->startElementNs(null, 'maxDistance', null);
            $writer->text($this->maxDistance);
            $writer->endElement();
        }
        if ($this->lat) {
            $writer->startElementNs(null, 'lat', null);
            $writer->text($this->lat);
            $writer->endElement();
        }
        if ($this->lon) {
            $writer->startElementNs(null, 'lon', null);
            $writer->text($this->lon);
            $writer->endElement();
        }
        if ($this->day) {
            $writer->startElementNs(null, 'day', null);
            $writer->text($this->day);
            $writer->endElement();
        }
        if ($this->computeDistances) {
            $writer->startElementNs(null, 'computeDistances', null);
            $writer->text($this->computeDistances);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class DeleteClientsRequest
{

    /**
     * (no documentation provided)
     *
     * @var string[]
     */
    private $clientsExternRefs;

    /**
     * (no documentation provided)
     *
     * @var string[]
     */
    private $ids;

    /**
     * Constructs a DeleteClientsRequest from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return string[]
     */
    public function getClientsExternRefs()
    {
        return $this->clientsExternRefs;
    }

    /**
     * (no documentation provided)
     *
     * @param string[] $clientsExternRefs
     */
    public function setClientsExternRefs($clientsExternRefs)
    {
        $this->clientsExternRefs = $clientsExternRefs;
    }
    /**
     * (no documentation provided)
     *
     * @return string[]
     */
    public function getIds()
    {
        return $this->ids;
    }

    /**
     * (no documentation provided)
     *
     * @param string[] $ids
     */
    public function setIds($ids)
    {
        $this->ids = $ids;
    }

    /**
     * Initializes this DeleteClientsRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of DeleteClientsRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'clientsExternRefs') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->clientsExternRefs)) {
                $this->clientsExternRefs = array();
            }
            array_push($this->clientsExternRefs, $child);
            $happened = true;
        }
        else if (($xml->localName == 'ids') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->ids)) {
                $this->ids = array();
            }
            array_push($this->ids, $child);
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of DeleteClientsRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this DeleteClientsRequest to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->clientsExternRefs) {
            foreach ($this->clientsExternRefs as $i => $x) {
                $writer->startElementNs(null, 'clientsExternRefs', null);
                $writer->text($x);
                $writer->endElement();
            }
        }
        if ($this->ids) {
            foreach ($this->ids as $i => $x) {
                $writer->startElementNs(null, 'ids', null);
                $writer->text($x);
                $writer->endElement();
            }
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class DeleteOperationalOrdersRequest
{

    /**
     * (no documentation provided)
     *
     * @var string[]
     */
    private $ordersIds;

    /**
     * Constructs a DeleteOperationalOrdersRequest from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return string[]
     */
    public function getOrdersIds()
    {
        return $this->ordersIds;
    }

    /**
     * (no documentation provided)
     *
     * @param string[] $ordersIds
     */
    public function setOrdersIds($ordersIds)
    {
        $this->ordersIds = $ordersIds;
    }

    /**
     * Initializes this DeleteOperationalOrdersRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of DeleteOperationalOrdersRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'ordersIds') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->ordersIds)) {
                $this->ordersIds = array();
            }
            array_push($this->ordersIds, $child);
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of DeleteOperationalOrdersRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this DeleteOperationalOrdersRequest to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->ordersIds) {
            foreach ($this->ordersIds as $i => $x) {
                $writer->startElementNs(null, 'ordersIds', null);
                $writer->text($x);
                $writer->endElement();
            }
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class FindClientsRequest
{

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $maxResults;

    /**
     * (no documentation provided)
     *
     * @var array
     */
    private $filters;

    /**
     * Constructs a FindClientsRequest from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getMaxResults()
    {
        return $this->maxResults;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $maxResults
     */
    public function setMaxResults($maxResults)
    {
        $this->maxResults = $maxResults;
    }
    /**
     * (no documentation provided)
     *
     * @return array
     */
    public function getFilters()
    {
        return $this->filters;
    }

    /**
     * (no documentation provided)
     *
     * @param array $filters
     */
    public function setFilters($filters)
    {
        $this->filters = $filters;
    }

    /**
     * Initializes this FindClientsRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of FindClientsRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'maxResults') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->maxResults = $child;
            $happened = true;
        }
        else if (($xml->localName == 'filters') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->filters = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of FindClientsRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this FindClientsRequest to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->maxResults) {
            $writer->startElementNs(null, 'maxResults', null);
            $writer->text($this->maxResults);
            $writer->endElement();
        }
        if ($this->filters) {
            $writer->startElementNs(null, 'filters', null);
            $writer->text($this->filters);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class AddVisitsRequest
{

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $id;

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSOrder[]
     */
    private $orders;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $language;

    /**
     * Constructs a AddVisitsRequest from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * (no documentation provided)
     *
     * @param string $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }
    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSOrder[]
     */
    public function getOrders()
    {
        return $this->orders;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSOrder[] $orders
     */
    public function setOrders($orders)
    {
        $this->orders = $orders;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getLanguage()
    {
        return $this->language;
    }

    /**
     * (no documentation provided)
     *
     * @param string $language
     */
    public function setLanguage($language)
    {
        $this->language = $language;
    }

    /**
     * Initializes this AddVisitsRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of AddVisitsRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'orders') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSOrder($xml);
            if (!isset($this->orders)) {
                $this->orders = array();
            }
            array_push($this->orders, $child);
            $happened = true;
        }
        else if (($xml->localName == 'language') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->language = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of AddVisitsRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this AddVisitsRequest to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->id) {
            $writer->startElementNs(null, 'id', null);
            $writer->text($this->id);
            $writer->endElement();
        }
        if ($this->orders) {
            foreach ($this->orders as $i => $x) {
                $writer->startElementNs(null, 'orders', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->language) {
            $writer->startElementNs(null, 'language', null);
            $writer->text($this->language);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class OperationalExportRequest
{

    /**
     * List of MobileResourceMapping defining relation between resource identifier in optimize request and real mobile resource identifier
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\OperationalResourceMapping[]
     */
    private $resourceMapping;

    /**
     * real date corresponding to day 1 of optimize request data
     *
     * @var integer
     */
    private $startDate;

    /**
     * if true, any existing operational planning will be replaced
     * if false and if optimization period overlaps any existing operational planning, export will fail.
     *
     * @var boolean
     */
    private $force;

    /**
     * Task identifier. Must point to a completed optimization.
     *
     * @var string
     */
    private $taskId;

    /**
     * (no documentation provided)
     *
     * @var integer[]
     */
    private $dayNums;

    /**
     * Constructs a OperationalExportRequest from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * List of MobileResourceMapping defining relation between resource identifier in optimize request and real mobile resource identifier
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\OperationalResourceMapping[]
     */
    public function getResourceMapping()
    {
        return $this->resourceMapping;
    }

    /**
     * List of MobileResourceMapping defining relation between resource identifier in optimize request and real mobile resource identifier
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\OperationalResourceMapping[] $resourceMapping
     */
    public function setResourceMapping($resourceMapping)
    {
        $this->resourceMapping = $resourceMapping;
    }
    /**
     * real date corresponding to day 1 of optimize request data
     *
     * @return integer
     */
    public function getStartDate()
    {
        return $this->startDate;
    }

    /**
     * real date corresponding to day 1 of optimize request data
     *
     * @param integer $startDate
     */
    public function setStartDate($startDate)
    {
        $this->startDate = $startDate;
    }
    /**
     * if true, any existing operational planning will be replaced
       * if false and if optimization period overlaps any existing operational planning, export will fail.
     *
     * @return boolean
     */
    public function getForce()
    {
        return $this->force;
    }

    /**
     * if true, any existing operational planning will be replaced
       * if false and if optimization period overlaps any existing operational planning, export will fail.
     *
     * @param boolean $force
     */
    public function setForce($force)
    {
        $this->force = $force;
    }
    /**
     * Task identifier. Must point to a completed optimization.
     *
     * @return string
     */
    public function getTaskId()
    {
        return $this->taskId;
    }

    /**
     * Task identifier. Must point to a completed optimization.
     *
     * @param string $taskId
     */
    public function setTaskId($taskId)
    {
        $this->taskId = $taskId;
    }
    /**
     * (no documentation provided)
     *
     * @return integer[]
     */
    public function getDayNums()
    {
        return $this->dayNums;
    }

    /**
     * (no documentation provided)
     *
     * @param integer[] $dayNums
     */
    public function setDayNums($dayNums)
    {
        $this->dayNums = $dayNums;
    }

    /**
     * Initializes this OperationalExportRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of OperationalExportRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'resourceMapping') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\OperationalResourceMapping($xml);
            if (!isset($this->resourceMapping)) {
                $this->resourceMapping = array();
            }
            array_push($this->resourceMapping, $child);
            $happened = true;
        }
        else if (($xml->localName == 'startDate') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->startDate = $child;
            $happened = true;
        }
        else if (($xml->localName == 'force') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->force = $child;
            $happened = true;
        }
        else if (($xml->localName == 'taskId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->taskId = $child;
            $happened = true;
        }
        else if (($xml->localName == 'dayNums') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->dayNums)) {
                $this->dayNums = array();
            }
            array_push($this->dayNums, $child);
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of OperationalExportRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes this OperationalExportRequest to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'operationalExportRequest', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this OperationalExportRequest to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->resourceMapping) {
            foreach ($this->resourceMapping as $i => $x) {
                $writer->startElementNs(null, 'resourceMapping', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->startDate) {
            $writer->startElementNs(null, 'startDate', null);
            $writer->text($this->startDate);
            $writer->endElement();
        }
        if ($this->force) {
            $writer->startElementNs(null, 'force', null);
            $writer->text($this->force);
            $writer->endElement();
        }
        if ($this->taskId) {
            $writer->startElementNs(null, 'taskId', null);
            $writer->text($this->taskId);
            $writer->endElement();
        }
        if ($this->dayNums) {
            foreach ($this->dayNums as $i => $x) {
                $writer->startElementNs(null, 'dayNums', null);
                $writer->text($x);
                $writer->endElement();
            }
        }
    }
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Resource;

/**
 * (no documentation provided)
 */
class SimpleDate
{

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $day;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $month;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $year;

    /**
     * Constructs a SimpleDate from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getDay()
    {
        return $this->day;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $day
     */
    public function setDay($day)
    {
        $this->day = $day;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getMonth()
    {
        return $this->month;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $month
     */
    public function setMonth($month)
    {
        $this->month = $month;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getYear()
    {
        return $this->year;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $year
     */
    public function setYear($year)
    {
        $this->year = $year;
    }

    /**
     * Initializes this SimpleDate from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of SimpleDate from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'day') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->day = $child;
            $happened = true;
        }
        else if (($xml->localName == 'month') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->month = $child;
            $happened = true;
        }
        else if (($xml->localName == 'year') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->year = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of SimpleDate from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this SimpleDate to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->day) {
            $writer->startElementNs(null, 'day', null);
            $writer->text($this->day);
            $writer->endElement();
        }
        if ($this->month) {
            $writer->startElementNs(null, 'month', null);
            $writer->text($this->month);
            $writer->endElement();
        }
        if ($this->year) {
            $writer->startElementNs(null, 'year', null);
            $writer->text($this->year);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class OptimizeRequest
{

    /**
     * list of depots (for reloading or starting tours)
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSDepot[]
     */
    private $depots;

    /**
     * list of orders (visits to do)
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSOrder[]
     */
    private $orders;

    /**
     * collection of resources, the elements which will perform deliveries,
     * pick-ups, commercial visit, etc.
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSResource[]
     */
    private $resources;

    /**
     * the optimize task options
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSOptions
     */
    private $options;

    /**
     * Main country code used to route the optimization to the good optimization
     * server farm.
     *
     * @var string
     */
    private $countryCode;

    /**
     * Simulation name
     * 
     * Optional : generated automatically if not provided
     *
     * @var string
     */
    private $simulationName;

    /**
     * Language to use for message localization
     *
     * @var string
     */
    private $language;

    /**
     * This date will be used if you try to export the optimization result
     * through TsCloud GUI.
     * 
     * **Format : ** YYYY-MM-DD
     * 
     * **Default : ** day+1.
     *
     * @var integer
     */
    private $beginDate;

    /**
     * In multi-user content, you can specify a user login you. The simulation
     * will be owned by this user. By default, the owner of the simulation is
     * the default user of the account.
     *
     * @var string
     */
    private $userLogin;

    /**
     * In multi-user content, you generally create various organizations that
     * allows to define who sees what. If you set the organization here, only
     * users that can see this organization will see the result of this
     * optimization in the UI.
     * 
     * Note that if you specified a teamId instead of sending the resources in
     * the optimization data, the organization will be guessed from the team.
     * 
     * If no organization is set, all users will see the result.
     *
     * @var string
     */
    private $organization;

    /**
     * Constructs a OptimizeRequest from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * list of depots (for reloading or starting tours)
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSDepot[]
     */
    public function getDepots()
    {
        return $this->depots;
    }

    /**
     * list of depots (for reloading or starting tours)
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSDepot[] $depots
     */
    public function setDepots($depots)
    {
        $this->depots = $depots;
    }
    /**
     * list of orders (visits to do)
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSOrder[]
     */
    public function getOrders()
    {
        return $this->orders;
    }

    /**
     * list of orders (visits to do)
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSOrder[] $orders
     */
    public function setOrders($orders)
    {
        $this->orders = $orders;
    }
    /**
     * collection of resources, the elements which will perform deliveries,
       * pick-ups, commercial visit, etc.
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSResource[]
     */
    public function getResources()
    {
        return $this->resources;
    }

    /**
     * collection of resources, the elements which will perform deliveries,
       * pick-ups, commercial visit, etc.
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSResource[] $resources
     */
    public function setResources($resources)
    {
        $this->resources = $resources;
    }
    /**
     * the optimize task options
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSOptions
     */
    public function getOptions()
    {
        return $this->options;
    }

    /**
     * the optimize task options
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSOptions $options
     */
    public function setOptions($options)
    {
        $this->options = $options;
    }
    /**
     * Main country code used to route the optimization to the good optimization
       * server farm.
     *
     * @return string
     */
    public function getCountryCode()
    {
        return $this->countryCode;
    }

    /**
     * Main country code used to route the optimization to the good optimization
       * server farm.
     *
     * @param string $countryCode
     */
    public function setCountryCode($countryCode)
    {
        $this->countryCode = $countryCode;
    }
    /**
     * Simulation name
       * 
       * Optional : generated automatically if not provided
     *
     * @return string
     */
    public function getSimulationName()
    {
        return $this->simulationName;
    }

    /**
     * Simulation name
       * 
       * Optional : generated automatically if not provided
     *
     * @param string $simulationName
     */
    public function setSimulationName($simulationName)
    {
        $this->simulationName = $simulationName;
    }
    /**
     * Language to use for message localization
     *
     * @return string
     */
    public function getLanguage()
    {
        return $this->language;
    }

    /**
     * Language to use for message localization
     *
     * @param string $language
     */
    public function setLanguage($language)
    {
        $this->language = $language;
    }
    /**
     * This date will be used if you try to export the optimization result
       * through TsCloud GUI.
       * 
       * **Format : ** YYYY-MM-DD
       * 
       * **Default : ** day+1.
     *
     * @return integer
     */
    public function getBeginDate()
    {
        return $this->beginDate;
    }

    /**
     * This date will be used if you try to export the optimization result
       * through TsCloud GUI.
       * 
       * **Format : ** YYYY-MM-DD
       * 
       * **Default : ** day+1.
     *
     * @param integer $beginDate
     */
    public function setBeginDate($beginDate)
    {
        $this->beginDate = $beginDate;
    }
    /**
     * In multi-user content, you can specify a user login you. The simulation
       * will be owned by this user. By default, the owner of the simulation is
       * the default user of the account.
     *
     * @return string
     */
    public function getUserLogin()
    {
        return $this->userLogin;
    }

    /**
     * In multi-user content, you can specify a user login you. The simulation
       * will be owned by this user. By default, the owner of the simulation is
       * the default user of the account.
     *
     * @param string $userLogin
     */
    public function setUserLogin($userLogin)
    {
        $this->userLogin = $userLogin;
    }
    /**
     * In multi-user content, you generally create various organizations that
       * allows to define who sees what. If you set the organization here, only
       * users that can see this organization will see the result of this
       * optimization in the UI.
       * 
       * Note that if you specified a teamId instead of sending the resources in
       * the optimization data, the organization will be guessed from the team.
       * 
       * If no organization is set, all users will see the result.
     *
     * @return string
     */
    public function getOrganization()
    {
        return $this->organization;
    }

    /**
     * In multi-user content, you generally create various organizations that
       * allows to define who sees what. If you set the organization here, only
       * users that can see this organization will see the result of this
       * optimization in the UI.
       * 
       * Note that if you specified a teamId instead of sending the resources in
       * the optimization data, the organization will be guessed from the team.
       * 
       * If no organization is set, all users will see the result.
     *
     * @param string $organization
     */
    public function setOrganization($organization)
    {
        $this->organization = $organization;
    }

    /**
     * Initializes this OptimizeRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of OptimizeRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'depots') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSDepot($xml);
            if (!isset($this->depots)) {
                $this->depots = array();
            }
            array_push($this->depots, $child);
            $happened = true;
        }
        else if (($xml->localName == 'orders') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSOrder($xml);
            if (!isset($this->orders)) {
                $this->orders = array();
            }
            array_push($this->orders, $child);
            $happened = true;
        }
        else if (($xml->localName == 'resources') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSResource($xml);
            if (!isset($this->resources)) {
                $this->resources = array();
            }
            array_push($this->resources, $child);
            $happened = true;
        }
        else if (($xml->localName == 'options') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSOptions($xml);
            $this->options = $child;
            $happened = true;
        }
        else if (($xml->localName == 'countryCode') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->countryCode = $child;
            $happened = true;
        }
        else if (($xml->localName == 'simulationName') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->simulationName = $child;
            $happened = true;
        }
        else if (($xml->localName == 'language') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->language = $child;
            $happened = true;
        }
        else if (($xml->localName == 'beginDate') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->beginDate = $child;
            $happened = true;
        }
        else if (($xml->localName == 'userLogin') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->userLogin = $child;
            $happened = true;
        }
        else if (($xml->localName == 'organization') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->organization = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of OptimizeRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes this OptimizeRequest to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'optimizeRequest', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this OptimizeRequest to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->depots) {
            foreach ($this->depots as $i => $x) {
                $writer->startElementNs(null, 'depots', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->orders) {
            foreach ($this->orders as $i => $x) {
                $writer->startElementNs(null, 'orders', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->resources) {
            foreach ($this->resources as $i => $x) {
                $writer->startElementNs(null, 'resources', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->options) {
            $writer->startElementNs(null, 'options', null);
            $this->options->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->countryCode) {
            $writer->startElementNs(null, 'countryCode', null);
            $writer->text($this->countryCode);
            $writer->endElement();
        }
        if ($this->simulationName) {
            $writer->startElementNs(null, 'simulationName', null);
            $writer->text($this->simulationName);
            $writer->endElement();
        }
        if ($this->language) {
            $writer->startElementNs(null, 'language', null);
            $writer->text($this->language);
            $writer->endElement();
        }
        if ($this->beginDate) {
            $writer->startElementNs(null, 'beginDate', null);
            $writer->text($this->beginDate);
            $writer->endElement();
        }
        if ($this->userLogin) {
            $writer->startElementNs(null, 'userLogin', null);
            $writer->text($this->userLogin);
            $writer->endElement();
        }
        if ($this->organization) {
            $writer->startElementNs(null, 'organization', null);
            $writer->text($this->organization);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Optim;

/**
 * (no documentation provided)
 */
class TSUnplanned
{

    /**
     * The id of the stop.
     *
     * @var string
     */
    private $stopID;

    /**
     * the reason why it what not planned
     *
     * @var string
     */
    private $reason;

    /**
     * Constructs a TSUnplanned from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * The id of the stop.
     *
     * @return string
     */
    public function getStopID()
    {
        return $this->stopID;
    }

    /**
     * The id of the stop.
     *
     * @param string $stopID
     */
    public function setStopID($stopID)
    {
        $this->stopID = $stopID;
    }
    /**
     * the reason why it what not planned
     *
     * @return string
     */
    public function getReason()
    {
        return $this->reason;
    }

    /**
     * the reason why it what not planned
     *
     * @param string $reason
     */
    public function setReason($reason)
    {
        $this->reason = $reason;
    }

    /**
     * Initializes this TSUnplanned from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of TSUnplanned from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'stopID') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->stopID = $child;
            $happened = true;
        }
        else if (($xml->localName == 'reason') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->reason = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of TSUnplanned from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this TSUnplanned to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->stopID) {
            $writer->startElementNs(null, 'stopID', null);
            $writer->text($this->stopID);
            $writer->endElement();
        }
        if ($this->reason) {
            $writer->startElementNs(null, 'reason', null);
            $writer->text($this->reason);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class ToursolverServiceResult
{

    /**
     * error message
     *
     * @var string
     */
    private $message;

    /**
     * response status, OK or ERROR
     *
     * @var string
     */
    private $status;

    /**
     * Constructs a ToursolverServiceResult from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * error message
     *
     * @return string
     */
    public function getMessage()
    {
        return $this->message;
    }

    /**
     * error message
     *
     * @param string $message
     */
    public function setMessage($message)
    {
        $this->message = $message;
    }
    /**
     * response status, OK or ERROR
     *
     * @return string
     */
    public function getStatus()
    {
        return $this->status;
    }

    /**
     * response status, OK or ERROR
     *
     * @param string $status
     */
    public function setStatus($status)
    {
        $this->status = $status;
    }

    /**
     * Initializes this ToursolverServiceResult from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of ToursolverServiceResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'message') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->message = $child;
            $happened = true;
        }
        else if (($xml->localName == 'status') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->status = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of ToursolverServiceResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes this ToursolverServiceResult to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'toursolverServiceResult', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this ToursolverServiceResult to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->message) {
            $writer->startElementNs(null, 'message', null);
            $writer->text($this->message);
            $writer->endElement();
        }
        if ($this->status) {
            $writer->startElementNs(null, 'status', null);
            $writer->text($this->status);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class UpdateClientsRequest
{

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Mycustomers\Api\Model\ClientEntity[]
     */
    private $clients;

    /**
     * Constructs a UpdateClientsRequest from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Mycustomers\Api\Model\ClientEntity[]
     */
    public function getClients()
    {
        return $this->clients;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Mycustomers\Api\Model\ClientEntity[] $clients
     */
    public function setClients($clients)
    {
        $this->clients = $clients;
    }

    /**
     * Initializes this UpdateClientsRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of UpdateClientsRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'clients') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Mycustomers\Api\Model\ClientEntity($xml);
            if (!isset($this->clients)) {
                $this->clients = array();
            }
            array_push($this->clients, $child);
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of UpdateClientsRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this UpdateClientsRequest to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->clients) {
            foreach ($this->clients as $i => $x) {
                $writer->startElementNs(null, 'clients', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class UpdateOperationalOrderRequest
{

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $operationalOrderId;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $status;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $achievedStartDate;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $achievedEndDate;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $achievedStartPositionLat;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $achievedStartPositionLon;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $achievedEndPositionLat;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $achievedEndPositionLon;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $svgSignature;

    /**
     * (no documentation provided)
     *
     * @var array
     */
    private $data;

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Model\ScanItemAchievement[]
     */
    private $scans;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $userLogin;

    /**
     * Constructs a UpdateOperationalOrderRequest from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getOperationalOrderId()
    {
        return $this->operationalOrderId;
    }

    /**
     * (no documentation provided)
     *
     * @param string $operationalOrderId
     */
    public function setOperationalOrderId($operationalOrderId)
    {
        $this->operationalOrderId = $operationalOrderId;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getStatus()
    {
        return $this->status;
    }

    /**
     * (no documentation provided)
     *
     * @param string $status
     */
    public function setStatus($status)
    {
        $this->status = $status;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getAchievedStartDate()
    {
        return $this->achievedStartDate;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $achievedStartDate
     */
    public function setAchievedStartDate($achievedStartDate)
    {
        $this->achievedStartDate = $achievedStartDate;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getAchievedEndDate()
    {
        return $this->achievedEndDate;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $achievedEndDate
     */
    public function setAchievedEndDate($achievedEndDate)
    {
        $this->achievedEndDate = $achievedEndDate;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getAchievedStartPositionLat()
    {
        return $this->achievedStartPositionLat;
    }

    /**
     * (no documentation provided)
     *
     * @param double $achievedStartPositionLat
     */
    public function setAchievedStartPositionLat($achievedStartPositionLat)
    {
        $this->achievedStartPositionLat = $achievedStartPositionLat;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getAchievedStartPositionLon()
    {
        return $this->achievedStartPositionLon;
    }

    /**
     * (no documentation provided)
     *
     * @param double $achievedStartPositionLon
     */
    public function setAchievedStartPositionLon($achievedStartPositionLon)
    {
        $this->achievedStartPositionLon = $achievedStartPositionLon;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getAchievedEndPositionLat()
    {
        return $this->achievedEndPositionLat;
    }

    /**
     * (no documentation provided)
     *
     * @param double $achievedEndPositionLat
     */
    public function setAchievedEndPositionLat($achievedEndPositionLat)
    {
        $this->achievedEndPositionLat = $achievedEndPositionLat;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getAchievedEndPositionLon()
    {
        return $this->achievedEndPositionLon;
    }

    /**
     * (no documentation provided)
     *
     * @param double $achievedEndPositionLon
     */
    public function setAchievedEndPositionLon($achievedEndPositionLon)
    {
        $this->achievedEndPositionLon = $achievedEndPositionLon;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getSvgSignature()
    {
        return $this->svgSignature;
    }

    /**
     * (no documentation provided)
     *
     * @param string $svgSignature
     */
    public function setSvgSignature($svgSignature)
    {
        $this->svgSignature = $svgSignature;
    }
    /**
     * (no documentation provided)
     *
     * @return array
     */
    public function getData()
    {
        return $this->data;
    }

    /**
     * (no documentation provided)
     *
     * @param array $data
     */
    public function setData($data)
    {
        $this->data = $data;
    }
    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Model\ScanItemAchievement[]
     */
    public function getScans()
    {
        return $this->scans;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Model\ScanItemAchievement[] $scans
     */
    public function setScans($scans)
    {
        $this->scans = $scans;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getUserLogin()
    {
        return $this->userLogin;
    }

    /**
     * (no documentation provided)
     *
     * @param string $userLogin
     */
    public function setUserLogin($userLogin)
    {
        $this->userLogin = $userLogin;
    }

    /**
     * Initializes this UpdateOperationalOrderRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of UpdateOperationalOrderRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'operationalOrderId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->operationalOrderId = $child;
            $happened = true;
        }
        else if (($xml->localName == 'status') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->status = $child;
            $happened = true;
        }
        else if (($xml->localName == 'achievedStartDate') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->achievedStartDate = $child;
            $happened = true;
        }
        else if (($xml->localName == 'achievedEndDate') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->achievedEndDate = $child;
            $happened = true;
        }
        else if (($xml->localName == 'achievedStartPositionLat') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->achievedStartPositionLat = $child;
            $happened = true;
        }
        else if (($xml->localName == 'achievedStartPositionLon') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->achievedStartPositionLon = $child;
            $happened = true;
        }
        else if (($xml->localName == 'achievedEndPositionLat') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->achievedEndPositionLat = $child;
            $happened = true;
        }
        else if (($xml->localName == 'achievedEndPositionLon') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->achievedEndPositionLon = $child;
            $happened = true;
        }
        else if (($xml->localName == 'svgSignature') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->svgSignature = $child;
            $happened = true;
        }
        else if (($xml->localName == 'data') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->data = $child;
            $happened = true;
        }
        else if (($xml->localName == 'scans') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\ScanItemAchievement($xml);
            if (!isset($this->scans)) {
                $this->scans = array();
            }
            array_push($this->scans, $child);
            $happened = true;
        }
        else if (($xml->localName == 'userLogin') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->userLogin = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of UpdateOperationalOrderRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this UpdateOperationalOrderRequest to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->operationalOrderId) {
            $writer->startElementNs(null, 'operationalOrderId', null);
            $writer->text($this->operationalOrderId);
            $writer->endElement();
        }
        if ($this->status) {
            $writer->startElementNs(null, 'status', null);
            $writer->text($this->status);
            $writer->endElement();
        }
        if ($this->achievedStartDate) {
            $writer->startElementNs(null, 'achievedStartDate', null);
            $writer->text($this->achievedStartDate);
            $writer->endElement();
        }
        if ($this->achievedEndDate) {
            $writer->startElementNs(null, 'achievedEndDate', null);
            $writer->text($this->achievedEndDate);
            $writer->endElement();
        }
        if ($this->achievedStartPositionLat) {
            $writer->startElementNs(null, 'achievedStartPositionLat', null);
            $writer->text($this->achievedStartPositionLat);
            $writer->endElement();
        }
        if ($this->achievedStartPositionLon) {
            $writer->startElementNs(null, 'achievedStartPositionLon', null);
            $writer->text($this->achievedStartPositionLon);
            $writer->endElement();
        }
        if ($this->achievedEndPositionLat) {
            $writer->startElementNs(null, 'achievedEndPositionLat', null);
            $writer->text($this->achievedEndPositionLat);
            $writer->endElement();
        }
        if ($this->achievedEndPositionLon) {
            $writer->startElementNs(null, 'achievedEndPositionLon', null);
            $writer->text($this->achievedEndPositionLon);
            $writer->endElement();
        }
        if ($this->svgSignature) {
            $writer->startElementNs(null, 'svgSignature', null);
            $writer->text($this->svgSignature);
            $writer->endElement();
        }
        if ($this->data) {
            $writer->startElementNs(null, 'data', null);
            $writer->text($this->data);
            $writer->endElement();
        }
        if ($this->scans) {
            foreach ($this->scans as $i => $x) {
                $writer->startElementNs(null, 'scans', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->userLogin) {
            $writer->startElementNs(null, 'userLogin', null);
            $writer->text($this->userLogin);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Mobile;

/**
 * (no documentation provided)
 */
class Data
{

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Mobile\DataItem[]
     */
    private $dataItem;

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Mobile\DetailSet[]
     */
    private $detailSet;

    /**
     * Constructs a Data from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Mobile\DataItem[]
     */
    public function getDataItem()
    {
        return $this->dataItem;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Mobile\DataItem[] $dataItem
     */
    public function setDataItem($dataItem)
    {
        $this->dataItem = $dataItem;
    }
    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Mobile\DetailSet[]
     */
    public function getDetailSet()
    {
        return $this->detailSet;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Mobile\DetailSet[] $detailSet
     */
    public function setDetailSet($detailSet)
    {
        $this->detailSet = $detailSet;
    }

    /**
     * Initializes this Data from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of Data from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'DataItem') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = new \Com\Geoconcept\Toursolver\Mobile\DataItem($xml);
            if (!isset($this->dataItem)) {
                $this->dataItem = array();
            }
            array_push($this->dataItem, $child);
            $happened = true;
        }
        else if (($xml->localName == 'DetailSet') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = new \Com\Geoconcept\Toursolver\Mobile\DetailSet($xml);
            if (!isset($this->detailSet)) {
                $this->detailSet = array();
            }
            array_push($this->detailSet, $child);
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of Data from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this Data to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->dataItem) {
            foreach ($this->dataItem as $i => $x) {
                $writer->startElementNs('ns1', 'DataItem', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->detailSet) {
            foreach ($this->detailSet as $i => $x) {
                $writer->startElementNs('ns1', 'DetailSet', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
    }
}

namespace Com\Geoconcept\Toursolver\Mobile;

/**
 * (no documentation provided)
 */
class DataItem
{

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $id;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $name;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $label;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $value;

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Mobile\TaskTypes
     */
    private $taskTypes;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $type;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $standardHandling;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $onCreateHandling;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $onStartHandling;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $onEndHandling;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $onCancelHandling;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $onRejectHandling;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $onPlanningHandling;

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Mobile\PossibleValues
     */
    private $possibleValues;

    /**
     * Constructs a DataItem from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * (no documentation provided)
     *
     * @param string $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * (no documentation provided)
     *
     * @param string $name
     */
    public function setName($name)
    {
        $this->name = $name;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getLabel()
    {
        return $this->label;
    }

    /**
     * (no documentation provided)
     *
     * @param string $label
     */
    public function setLabel($label)
    {
        $this->label = $label;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getValue()
    {
        return $this->value;
    }

    /**
     * (no documentation provided)
     *
     * @param string $value
     */
    public function setValue($value)
    {
        $this->value = $value;
    }
    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Mobile\TaskTypes
     */
    public function getTaskTypes()
    {
        return $this->taskTypes;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Mobile\TaskTypes $taskTypes
     */
    public function setTaskTypes($taskTypes)
    {
        $this->taskTypes = $taskTypes;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getType()
    {
        return $this->type;
    }

    /**
     * (no documentation provided)
     *
     * @param string $type
     */
    public function setType($type)
    {
        $this->type = $type;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getStandardHandling()
    {
        return $this->standardHandling;
    }

    /**
     * (no documentation provided)
     *
     * @param string $standardHandling
     */
    public function setStandardHandling($standardHandling)
    {
        $this->standardHandling = $standardHandling;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getOnCreateHandling()
    {
        return $this->onCreateHandling;
    }

    /**
     * (no documentation provided)
     *
     * @param string $onCreateHandling
     */
    public function setOnCreateHandling($onCreateHandling)
    {
        $this->onCreateHandling = $onCreateHandling;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getOnStartHandling()
    {
        return $this->onStartHandling;
    }

    /**
     * (no documentation provided)
     *
     * @param string $onStartHandling
     */
    public function setOnStartHandling($onStartHandling)
    {
        $this->onStartHandling = $onStartHandling;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getOnEndHandling()
    {
        return $this->onEndHandling;
    }

    /**
     * (no documentation provided)
     *
     * @param string $onEndHandling
     */
    public function setOnEndHandling($onEndHandling)
    {
        $this->onEndHandling = $onEndHandling;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getOnCancelHandling()
    {
        return $this->onCancelHandling;
    }

    /**
     * (no documentation provided)
     *
     * @param string $onCancelHandling
     */
    public function setOnCancelHandling($onCancelHandling)
    {
        $this->onCancelHandling = $onCancelHandling;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getOnRejectHandling()
    {
        return $this->onRejectHandling;
    }

    /**
     * (no documentation provided)
     *
     * @param string $onRejectHandling
     */
    public function setOnRejectHandling($onRejectHandling)
    {
        $this->onRejectHandling = $onRejectHandling;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getOnPlanningHandling()
    {
        return $this->onPlanningHandling;
    }

    /**
     * (no documentation provided)
     *
     * @param string $onPlanningHandling
     */
    public function setOnPlanningHandling($onPlanningHandling)
    {
        $this->onPlanningHandling = $onPlanningHandling;
    }
    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Mobile\PossibleValues
     */
    public function getPossibleValues()
    {
        return $this->possibleValues;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Mobile\PossibleValues $possibleValues
     */
    public function setPossibleValues($possibleValues)
    {
        $this->possibleValues = $possibleValues;
    }

    /**
     * Initializes this DataItem from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of DataItem from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'Id') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'Name') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->name = $child;
            $happened = true;
        }
        else if (($xml->localName == 'Label') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->label = $child;
            $happened = true;
        }
        else if (($xml->localName == 'Value') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->value = $child;
            $happened = true;
        }
        else if (($xml->localName == 'TaskTypes') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = new \Com\Geoconcept\Toursolver\Mobile\TaskTypes($xml);
            $this->taskTypes = $child;
            $happened = true;
        }
        else if (($xml->localName == 'Type') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->type = $child;
            $happened = true;
        }
        else if (($xml->localName == 'StandardHandling') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->standardHandling = $child;
            $happened = true;
        }
        else if (($xml->localName == 'OnCreateHandling') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->onCreateHandling = $child;
            $happened = true;
        }
        else if (($xml->localName == 'OnStartHandling') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->onStartHandling = $child;
            $happened = true;
        }
        else if (($xml->localName == 'OnEndHandling') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->onEndHandling = $child;
            $happened = true;
        }
        else if (($xml->localName == 'OnCancelHandling') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->onCancelHandling = $child;
            $happened = true;
        }
        else if (($xml->localName == 'OnRejectHandling') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->onRejectHandling = $child;
            $happened = true;
        }
        else if (($xml->localName == 'OnPlanningHandling') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->onPlanningHandling = $child;
            $happened = true;
        }
        else if (($xml->localName == 'PossibleValues') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = new \Com\Geoconcept\Toursolver\Mobile\PossibleValues($xml);
            $this->possibleValues = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of DataItem from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this DataItem to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->id) {
            $writer->startElementNs('ns1', 'Id', null);
            $writer->text($this->id);
            $writer->endElement();
        }
        if ($this->name) {
            $writer->startElementNs('ns1', 'Name', null);
            $writer->text($this->name);
            $writer->endElement();
        }
        if ($this->label) {
            $writer->startElementNs('ns1', 'Label', null);
            $writer->text($this->label);
            $writer->endElement();
        }
        if ($this->value) {
            $writer->startElementNs('ns1', 'Value', null);
            $writer->text($this->value);
            $writer->endElement();
        }
        if ($this->taskTypes) {
            $writer->startElementNs('ns1', 'TaskTypes', null);
            $this->taskTypes->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->type) {
            $writer->startElementNs('ns1', 'Type', null);
            $writer->text($this->type);
            $writer->endElement();
        }
        if ($this->standardHandling) {
            $writer->startElementNs('ns1', 'StandardHandling', null);
            $writer->text($this->standardHandling);
            $writer->endElement();
        }
        if ($this->onCreateHandling) {
            $writer->startElementNs('ns1', 'OnCreateHandling', null);
            $writer->text($this->onCreateHandling);
            $writer->endElement();
        }
        if ($this->onStartHandling) {
            $writer->startElementNs('ns1', 'OnStartHandling', null);
            $writer->text($this->onStartHandling);
            $writer->endElement();
        }
        if ($this->onEndHandling) {
            $writer->startElementNs('ns1', 'OnEndHandling', null);
            $writer->text($this->onEndHandling);
            $writer->endElement();
        }
        if ($this->onCancelHandling) {
            $writer->startElementNs('ns1', 'OnCancelHandling', null);
            $writer->text($this->onCancelHandling);
            $writer->endElement();
        }
        if ($this->onRejectHandling) {
            $writer->startElementNs('ns1', 'OnRejectHandling', null);
            $writer->text($this->onRejectHandling);
            $writer->endElement();
        }
        if ($this->onPlanningHandling) {
            $writer->startElementNs('ns1', 'OnPlanningHandling', null);
            $writer->text($this->onPlanningHandling);
            $writer->endElement();
        }
        if ($this->possibleValues) {
            $writer->startElementNs('ns1', 'PossibleValues', null);
            $this->possibleValues->writeXmlContents($writer);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Mobile;

/**
 * (no documentation provided)
 */
class DetailSet
{

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $kind;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $displayMode;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $title;

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Mobile\DetailSetField[]
     */
    private $fields;

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Mobile\DetailSetItem[]
     */
    private $items;

    /**
     * Constructs a DetailSet from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getKind()
    {
        return $this->kind;
    }

    /**
     * (no documentation provided)
     *
     * @param string $kind
     */
    public function setKind($kind)
    {
        $this->kind = $kind;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getDisplayMode()
    {
        return $this->displayMode;
    }

    /**
     * (no documentation provided)
     *
     * @param string $displayMode
     */
    public function setDisplayMode($displayMode)
    {
        $this->displayMode = $displayMode;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getTitle()
    {
        return $this->title;
    }

    /**
     * (no documentation provided)
     *
     * @param string $title
     */
    public function setTitle($title)
    {
        $this->title = $title;
    }
    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Mobile\DetailSetField[]
     */
    public function getFields()
    {
        return $this->fields;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Mobile\DetailSetField[] $fields
     */
    public function setFields($fields)
    {
        $this->fields = $fields;
    }
    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Mobile\DetailSetItem[]
     */
    public function getItems()
    {
        return $this->items;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Mobile\DetailSetItem[] $items
     */
    public function setItems($items)
    {
        $this->items = $items;
    }

    /**
     * Initializes this DetailSet from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of DetailSet from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'Kind') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->kind = $child;
            $happened = true;
        }
        else if (($xml->localName == 'DisplayMode') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->displayMode = $child;
            $happened = true;
        }
        else if (($xml->localName == 'Title') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->title = $child;
            $happened = true;
        }
        else if (($xml->localName == 'Fields') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = new \Com\Geoconcept\Toursolver\Mobile\DetailSetField($xml);
            if (!isset($this->fields)) {
                $this->fields = array();
            }
            array_push($this->fields, $child);
            $happened = true;
        }
        else if (($xml->localName == 'Items') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = new \Com\Geoconcept\Toursolver\Mobile\DetailSetItem($xml);
            if (!isset($this->items)) {
                $this->items = array();
            }
            array_push($this->items, $child);
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of DetailSet from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this DetailSet to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->kind) {
            $writer->startElementNs('ns1', 'Kind', null);
            $writer->text($this->kind);
            $writer->endElement();
        }
        if ($this->displayMode) {
            $writer->startElementNs('ns1', 'DisplayMode', null);
            $writer->text($this->displayMode);
            $writer->endElement();
        }
        if ($this->title) {
            $writer->startElementNs('ns1', 'Title', null);
            $writer->text($this->title);
            $writer->endElement();
        }
        if ($this->fields) {
            foreach ($this->fields as $i => $x) {
                $writer->startElementNs('ns1', 'Fields', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->items) {
            foreach ($this->items as $i => $x) {
                $writer->startElementNs('ns1', 'Items', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
    }
}

namespace Com\Geoconcept\Toursolver\Mobile;

/**
 * (no documentation provided)
 */
class DetailSetItem
{

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $id;

    /**
     * (no documentation provided)
     *
     * @var boolean
     */
    private $isActive;

    /**
     * (no documentation provided)
     *
     * @var boolean
     */
    private $deleteAction;

    /**
     * (no documentation provided)
     *
     * @var string[]
     */
    private $values;

    /**
     * Constructs a DetailSetItem from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * (no documentation provided)
     *
     * @param string $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }
    /**
     * (no documentation provided)
     *
     * @return boolean
     */
    public function getIsActive()
    {
        return $this->isActive;
    }

    /**
     * (no documentation provided)
     *
     * @param boolean $isActive
     */
    public function setIsActive($isActive)
    {
        $this->isActive = $isActive;
    }
    /**
     * (no documentation provided)
     *
     * @return boolean
     */
    public function getDeleteAction()
    {
        return $this->deleteAction;
    }

    /**
     * (no documentation provided)
     *
     * @param boolean $deleteAction
     */
    public function setDeleteAction($deleteAction)
    {
        $this->deleteAction = $deleteAction;
    }
    /**
     * (no documentation provided)
     *
     * @return string[]
     */
    public function getValues()
    {
        return $this->values;
    }

    /**
     * (no documentation provided)
     *
     * @param string[] $values
     */
    public function setValues($values)
    {
        $this->values = $values;
    }

    /**
     * Initializes this DetailSetItem from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of DetailSetItem from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'Id') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'IsActive') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->isActive = $child;
            $happened = true;
        }
        else if (($xml->localName == 'DeleteAction') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->deleteAction = $child;
            $happened = true;
        }
        else if (($xml->localName == 'Values') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->values)) {
                $this->values = array();
            }
            array_push($this->values, $child);
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of DetailSetItem from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this DetailSetItem to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->id) {
            $writer->startElementNs('ns1', 'Id', null);
            $writer->text($this->id);
            $writer->endElement();
        }
        if ($this->isActive) {
            $writer->startElementNs('ns1', 'IsActive', null);
            $writer->text($this->isActive);
            $writer->endElement();
        }
        if ($this->deleteAction) {
            $writer->startElementNs('ns1', 'DeleteAction', null);
            $writer->text($this->deleteAction);
            $writer->endElement();
        }
        if ($this->values) {
            foreach ($this->values as $i => $x) {
                $writer->startElementNs('ns1', 'Values', null);
                $writer->text($x);
                $writer->endElement();
            }
        }
    }
}

namespace Com\Geoconcept\Toursolver\Mobile;

/**
 * (no documentation provided)
 */
class DetailSetField
{

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $kind;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $id;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $name;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $label;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $datatype;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $access;

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Mobile\PossibleValues
     */
    private $possibleValues;

    /**
     * Constructs a DetailSetField from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getKind()
    {
        return $this->kind;
    }

    /**
     * (no documentation provided)
     *
     * @param string $kind
     */
    public function setKind($kind)
    {
        $this->kind = $kind;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * (no documentation provided)
     *
     * @param string $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * (no documentation provided)
     *
     * @param string $name
     */
    public function setName($name)
    {
        $this->name = $name;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getLabel()
    {
        return $this->label;
    }

    /**
     * (no documentation provided)
     *
     * @param string $label
     */
    public function setLabel($label)
    {
        $this->label = $label;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getDatatype()
    {
        return $this->datatype;
    }

    /**
     * (no documentation provided)
     *
     * @param string $datatype
     */
    public function setDatatype($datatype)
    {
        $this->datatype = $datatype;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getAccess()
    {
        return $this->access;
    }

    /**
     * (no documentation provided)
     *
     * @param string $access
     */
    public function setAccess($access)
    {
        $this->access = $access;
    }
    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Mobile\PossibleValues
     */
    public function getPossibleValues()
    {
        return $this->possibleValues;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Mobile\PossibleValues $possibleValues
     */
    public function setPossibleValues($possibleValues)
    {
        $this->possibleValues = $possibleValues;
    }

    /**
     * Initializes this DetailSetField from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of DetailSetField from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'Kind') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->kind = $child;
            $happened = true;
        }
        else if (($xml->localName == 'Id') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'Name') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->name = $child;
            $happened = true;
        }
        else if (($xml->localName == 'Label') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->label = $child;
            $happened = true;
        }
        else if (($xml->localName == 'Datatype') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->datatype = $child;
            $happened = true;
        }
        else if (($xml->localName == 'Access') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->access = $child;
            $happened = true;
        }
        else if (($xml->localName == 'PossibleValues') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = new \Com\Geoconcept\Toursolver\Mobile\PossibleValues($xml);
            $this->possibleValues = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of DetailSetField from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this DetailSetField to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->kind) {
            $writer->startElementNs('ns1', 'Kind', null);
            $writer->text($this->kind);
            $writer->endElement();
        }
        if ($this->id) {
            $writer->startElementNs('ns1', 'Id', null);
            $writer->text($this->id);
            $writer->endElement();
        }
        if ($this->name) {
            $writer->startElementNs('ns1', 'Name', null);
            $writer->text($this->name);
            $writer->endElement();
        }
        if ($this->label) {
            $writer->startElementNs('ns1', 'Label', null);
            $writer->text($this->label);
            $writer->endElement();
        }
        if ($this->datatype) {
            $writer->startElementNs('ns1', 'Datatype', null);
            $writer->text($this->datatype);
            $writer->endElement();
        }
        if ($this->access) {
            $writer->startElementNs('ns1', 'Access', null);
            $writer->text($this->access);
            $writer->endElement();
        }
        if ($this->possibleValues) {
            $writer->startElementNs('ns1', 'PossibleValues', null);
            $this->possibleValues->writeXmlContents($writer);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Mobile;

/**
 * (no documentation provided)
 */
class PossibleValues
{

    /**
     * (no documentation provided)
     *
     * @var string[]
     */
    private $value;

    /**
     * Constructs a PossibleValues from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return string[]
     */
    public function getValue()
    {
        return $this->value;
    }

    /**
     * (no documentation provided)
     *
     * @param string[] $value
     */
    public function setValue($value)
    {
        $this->value = $value;
    }

    /**
     * Initializes this PossibleValues from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of PossibleValues from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'Value') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->value)) {
                $this->value = array();
            }
            array_push($this->value, $child);
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of PossibleValues from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this PossibleValues to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->value) {
            foreach ($this->value as $i => $x) {
                $writer->startElementNs('ns1', 'Value', null);
                $writer->text($x);
                $writer->endElement();
            }
        }
    }
}

namespace Com\Geoconcept\Toursolver\Mobile;

/**
 * (no documentation provided)
 */
class TaskType
{

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $taskTypeId;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $taskTypeName;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $defaultDuration;

    /**
     * (no documentation provided)
     *
     * @var boolean
     */
    private $isInProject;

    /**
     * Constructs a TaskType from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getTaskTypeId()
    {
        return $this->taskTypeId;
    }

    /**
     * (no documentation provided)
     *
     * @param string $taskTypeId
     */
    public function setTaskTypeId($taskTypeId)
    {
        $this->taskTypeId = $taskTypeId;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getTaskTypeName()
    {
        return $this->taskTypeName;
    }

    /**
     * (no documentation provided)
     *
     * @param string $taskTypeName
     */
    public function setTaskTypeName($taskTypeName)
    {
        $this->taskTypeName = $taskTypeName;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getDefaultDuration()
    {
        return $this->defaultDuration;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $defaultDuration
     */
    public function setDefaultDuration($defaultDuration)
    {
        $this->defaultDuration = $defaultDuration;
    }
    /**
     * (no documentation provided)
     *
     * @return boolean
     */
    public function getIsInProject()
    {
        return $this->isInProject;
    }

    /**
     * (no documentation provided)
     *
     * @param boolean $isInProject
     */
    public function setIsInProject($isInProject)
    {
        $this->isInProject = $isInProject;
    }

    /**
     * Initializes this TaskType from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of TaskType from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'TaskTypeId') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->taskTypeId = $child;
            $happened = true;
        }
        else if (($xml->localName == 'TaskTypeName') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->taskTypeName = $child;
            $happened = true;
        }
        else if (($xml->localName == 'DefaultDuration') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->defaultDuration = $child;
            $happened = true;
        }
        else if (($xml->localName == 'IsInProject') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->isInProject = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of TaskType from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this TaskType to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->taskTypeId) {
            $writer->startElementNs('ns1', 'TaskTypeId', null);
            $writer->text($this->taskTypeId);
            $writer->endElement();
        }
        if ($this->taskTypeName) {
            $writer->startElementNs('ns1', 'TaskTypeName', null);
            $writer->text($this->taskTypeName);
            $writer->endElement();
        }
        if ($this->defaultDuration) {
            $writer->startElementNs('ns1', 'DefaultDuration', null);
            $writer->text($this->defaultDuration);
            $writer->endElement();
        }
        if ($this->isInProject) {
            $writer->startElementNs('ns1', 'IsInProject', null);
            $writer->text($this->isInProject);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Mobile;

/**
 * (no documentation provided)
 */
class TaskTypes
{

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Mobile\TaskType[]
     */
    private $taskType;

    /**
     * Constructs a TaskTypes from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Mobile\TaskType[]
     */
    public function getTaskType()
    {
        return $this->taskType;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Mobile\TaskType[] $taskType
     */
    public function setTaskType($taskType)
    {
        $this->taskType = $taskType;
    }

    /**
     * Initializes this TaskTypes from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of TaskTypes from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'TaskType') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = new \Com\Geoconcept\Toursolver\Mobile\TaskType($xml);
            if (!isset($this->taskType)) {
                $this->taskType = array();
            }
            array_push($this->taskType, $child);
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of TaskTypes from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this TaskTypes to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->taskType) {
            foreach ($this->taskType as $i => $x) {
                $writer->startElementNs('ns1', 'TaskType', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class UpdateOperationalOrdersRequest
{

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Export\OperationalOrder[]
     */
    private $orders;

    /**
     * Constructs a UpdateOperationalOrdersRequest from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Export\OperationalOrder[]
     */
    public function getOrders()
    {
        return $this->orders;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Export\OperationalOrder[] $orders
     */
    public function setOrders($orders)
    {
        $this->orders = $orders;
    }

    /**
     * Initializes this UpdateOperationalOrdersRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of UpdateOperationalOrdersRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'orders') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Export\OperationalOrder($xml);
            if (!isset($this->orders)) {
                $this->orders = array();
            }
            array_push($this->orders, $child);
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of UpdateOperationalOrdersRequest from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this UpdateOperationalOrdersRequest to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->orders) {
            foreach ($this->orders as $i => $x) {
                $writer->startElementNs(null, 'orders', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
    }
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Optim;

/**
 * (no documentation provided)
 */
class TSTravelPenalty
{

    /**
     * The driven distance (in the solver&#39;s measurement system unit) from which distance cost will be applied.
     * 
     * Use this constraint when you need to specify a distance cost which can vary according to the covered distance.
     * Up to 4 different distance costs can be specified. Each one must be related to the corresponding distance threshold,
     * from which it will be applied
     *
     * @var integer
     */
    private $distance;

    /**
     * The cost for a resource of driving for one distance unit.
     * 
     * Use this constraint to specify the average resource taxes (gazoline, wear,...) when driving one distance unit.
     * 
     * **Type : ** float **Default : ** 1.5
     * 
     * **Example : ** if penalty = 0.5 (euro per distance unit) and the driven distance is about 100 unit (km or miles), the total distance cost is 0,5 * 100 = 50 euros.
     *
     * @var double
     */
    private $penalty;

    /**
     * Constructs a TSTravelPenalty from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * The driven distance (in the solver&#39;s measurement system unit) from which distance cost will be applied.
       * 
       * Use this constraint when you need to specify a distance cost which can vary according to the covered distance.
       * Up to 4 different distance costs can be specified. Each one must be related to the corresponding distance threshold,
       * from which it will be applied
     *
     * @return integer
     */
    public function getDistance()
    {
        return $this->distance;
    }

    /**
     * The driven distance (in the solver&#39;s measurement system unit) from which distance cost will be applied.
       * 
       * Use this constraint when you need to specify a distance cost which can vary according to the covered distance.
       * Up to 4 different distance costs can be specified. Each one must be related to the corresponding distance threshold,
       * from which it will be applied
     *
     * @param integer $distance
     */
    public function setDistance($distance)
    {
        $this->distance = $distance;
    }
    /**
     * The cost for a resource of driving for one distance unit.
       * 
       * Use this constraint to specify the average resource taxes (gazoline, wear,...) when driving one distance unit.
       * 
       * **Type : ** float **Default : ** 1.5
       * 
       * **Example : ** if penalty = 0.5 (euro per distance unit) and the driven distance is about 100 unit (km or miles), the total distance cost is 0,5 * 100 = 50 euros.
     *
     * @return double
     */
    public function getPenalty()
    {
        return $this->penalty;
    }

    /**
     * The cost for a resource of driving for one distance unit.
       * 
       * Use this constraint to specify the average resource taxes (gazoline, wear,...) when driving one distance unit.
       * 
       * **Type : ** float **Default : ** 1.5
       * 
       * **Example : ** if penalty = 0.5 (euro per distance unit) and the driven distance is about 100 unit (km or miles), the total distance cost is 0,5 * 100 = 50 euros.
     *
     * @param double $penalty
     */
    public function setPenalty($penalty)
    {
        $this->penalty = $penalty;
    }

    /**
     * Initializes this TSTravelPenalty from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of TSTravelPenalty from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'distance') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->distance = $child;
            $happened = true;
        }
        else if (($xml->localName == 'penalty') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->penalty = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of TSTravelPenalty from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes this TSTravelPenalty to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'TSTravelPenalty', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this TSTravelPenalty to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->distance) {
            $writer->startElementNs(null, 'distance', null);
            $writer->text($this->distance);
            $writer->endElement();
        }
        if ($this->penalty) {
            $writer->startElementNs(null, 'penalty', null);
            $writer->text($this->penalty);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Optim;

/**
 * (no documentation provided)
 */
class TSTimeWindow
{

    /**
     * the minimum begin time
     * 
     * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;)
     *
     * @var string
     */
    private $beginTime;

    /**
     * the maximum end time
     * 
     * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;)
     *
     * @var string
     */
    private $endTime;

    /**
     * Constructs a TSTimeWindow from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * the minimum begin time
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;)
     *
     * @return string
     */
    public function getBeginTime()
    {
        return $this->beginTime;
    }

    /**
     * the minimum begin time
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;)
     *
     * @param string $beginTime
     */
    public function setBeginTime($beginTime)
    {
        $this->beginTime = $beginTime;
    }
    /**
     * the maximum end time
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;)
     *
     * @return string
     */
    public function getEndTime()
    {
        return $this->endTime;
    }

    /**
     * the maximum end time
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;)
     *
     * @param string $endTime
     */
    public function setEndTime($endTime)
    {
        $this->endTime = $endTime;
    }

    /**
     * Initializes this TSTimeWindow from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of TSTimeWindow from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'beginTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->beginTime = $child;
            $happened = true;
        }
        else if (($xml->localName == 'endTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->endTime = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of TSTimeWindow from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes this TSTimeWindow to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'timeWindow', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this TSTimeWindow to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->beginTime) {
            $writer->startElementNs(null, 'beginTime', null);
            $writer->text($this->beginTime);
            $writer->endElement();
        }
        if ($this->endTime) {
            $writer->startElementNs(null, 'endTime', null);
            $writer->text($this->endTime);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Ebooking\Api\Model;

/**
 * (no documentation provided)
 */
class ScheduleTime
{

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $hours;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $seconds;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $timeZone;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $minutes;

    /**
     * Constructs a ScheduleTime from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getHours()
    {
        return $this->hours;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $hours
     */
    public function setHours($hours)
    {
        $this->hours = $hours;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getSeconds()
    {
        return $this->seconds;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $seconds
     */
    public function setSeconds($seconds)
    {
        $this->seconds = $seconds;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getTimeZone()
    {
        return $this->timeZone;
    }

    /**
     * (no documentation provided)
     *
     * @param string $timeZone
     */
    public function setTimeZone($timeZone)
    {
        $this->timeZone = $timeZone;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getMinutes()
    {
        return $this->minutes;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $minutes
     */
    public function setMinutes($minutes)
    {
        $this->minutes = $minutes;
    }

    /**
     * Initializes this ScheduleTime from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of ScheduleTime from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = false;
        if (($xml->localName == 'hours') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->hours = $child;
            $happened = true;
        }
        else if (($xml->localName == 'seconds') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->seconds = $child;
            $happened = true;
        }
        else if (($xml->localName == 'timeZone') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->timeZone = $child;
            $happened = true;
        }
        else if (($xml->localName == 'minutes') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->minutes = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of ScheduleTime from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {

        return false;
    }

    /**
     * Writes the contents of this ScheduleTime to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->hours) {
            $writer->startElementNs(null, 'hours', null);
            $writer->text($this->hours);
            $writer->endElement();
        }
        if ($this->seconds) {
            $writer->startElementNs(null, 'seconds', null);
            $writer->text($this->seconds);
            $writer->endElement();
        }
        if ($this->timeZone) {
            $writer->startElementNs(null, 'timeZone', null);
            $writer->text($this->timeZone);
            $writer->endElement();
        }
        if ($this->minutes) {
            $writer->startElementNs(null, 'minutes', null);
            $writer->text($this->minutes);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Common\Persistence;

/**
 * (no documentation provided)
 */
class PersistentObject
{

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $id;

    /**
     * Constructs a PersistentObject from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * (no documentation provided)
     *
     * @param string $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }

    /**
     * Initializes this PersistentObject from an XML reader.
     *
     * @param \XMLReader $xml The reader to use to initialize this object.
     */
    public function initFromReader($xml)
    {
        $empty = $xml->isEmptyElement;

        if ($xml->hasAttributes) {
            $moreAttributes = $xml->moveToFirstAttribute();
            while ($moreAttributes) {
                if (!$this->setKnownAttribute($xml)) {
                    //skip unknown attributes...
                }
                $moreAttributes = $xml->moveToNextAttribute();
            }
        }

        if (!$empty) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc.
                }
                else if (!$xml->isEmptyElement && !$this->setKnownChildElement($xml)) {
                    $n = $xml->localName;
                    $ns = $xml->namespaceURI;
                    //skip the unknown element
                    while ($xml->nodeType != \XMLReader::END_ELEMENT && $xml->localName != $n && $xml->namespaceURI != $ns) {
                        $xml->read();
                    }
                }
                $xml->read(); //advance the reader.
            }
        }
    }


    /**
     * Sets a known child element of PersistentObject from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        return false;
    }

    /**
     * Sets a known attribute of PersistentObject from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (($xml->localName == 'id') && (empty($xml->namespaceURI))) {
            $this->id = $xml->value;
            return true;
        }

        return false;
    }

    /**
     * Writes the contents of this PersistentObject to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        if ($this->id) {
            $writer->writeAttribute('id', $this->id);
        }
    }
}

namespace Com\Geoconcept\Toursolver\Export;

/**
 * (no documentation provided)
 */
class OperationalOrderAchievement extends \Com\Geoconcept\Common\Persistence\PersistentObject
{

    /**
     * Mobile resource identifier (mobile app login)
     *
     * @var string
     */
    private $operationalResourceId;

    /**
     * Planned order
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSPlanned
     */
    private $plannedOrder;

    /**
     * Original order
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSOrder
     */
    private $order;

    /**
     * Planning day
     *
     * @var integer
     */
    private $date;

    /**
     * Planned start date and time
     *
     * @var integer
     */
    private $start;

    /**
     * Planned end date and time
     *
     * @var integer
     */
    private $end;

    /**
     * fulfillment status
     *
     * @var string
     */
    private $status;

    /**
     * Event type
     *
     * @var string
     */
    private $type;

    /**
     * Longitude
     *
     * @var double
     */
    private $lon;

    /**
     * Latitude
     *
     * @var double
     */
    private $lat;

    /**
     * Last change from mobile app
     *
     * @var integer
     */
    private $lastSynchroStatusChange;

    /**
     * Sync status
     *
     * @var string
     */
    private $synchroStatus;

    /**
     * Achievement start date and time
     *
     * @var integer
     */
    private $achievementStart;

    /**
     * Achievement end date and time
     *
     * @var integer
     */
    private $achievementEnd;

    /**
     * Achievement comment
     *
     * @var string
     */
    private $achievementComment;

    /**
     * Achievement start latitude
     *
     * @var double
     */
    private $achievementStartLat;

    /**
     * Achievement start longitude
     *
     * @var double
     */
    private $achievementStartLon;

    /**
     * Achievement end latitude
     *
     * @var double
     */
    private $achievementEndLat;

    /**
     * Achievement end longitude
     *
     * @var double
     */
    private $achievementEndLon;

    /**
     * Address and position info
     *
     * @var \Com\Geoconcept\Toursolver\Model\GeocodeInfos
     */
    private $geocode;

    /**
     * Signature svg
     *
     * @var string
     */
    private $signatureSvg;

    /**
     * Signature, as a picture relative URL (a flavor of the reference
     * &#39;signatureSvg&#39;)
     * 
     * &lt;p&gt;
     * Is bound and synced from the &#39;signaturesSvg&#39; field. Is a relative URL, as
     * also done for the &#39;pictures&#39; field (see its documentation for details).
     *
     * @var string
     */
    private $signaturePicture;

    /**
     * fulfillment form data
     *
     * @var array
     */
    private $data;

    /**
     * List of picture relative urls. Url root for pictures is
     * https://api.geoconcept.com/ToursolverCloud/api/rest/otmobile/pictures/
     *
     * @var string[]
     */
    private $pictures;

    /**
     * identifier of the simulation used to fill the fulfillment planning
     *
     * @var string
     */
    private $simulationId;

    /**
     * day containing this order in the simulation used to fill the fulfillment
     * planning
     *
     * @var string
     */
    private $simulationDayId;

    /**
     * End of time window communicated to customer
     *
     * @var integer
     */
    private $timeWindowEnd;

    /**
     * Start of time window communicated to customer
     *
     * @var integer
     */
    private $timeWindowStart;

    /**
     * Start of time window requested by customer after slot notification or visit canceling
     *
     * @var integer
     */
    private $wishedStart;

    /**
     * End of time window requested by customer after slot notification or visit canceling
     *
     * @var integer
     */
    private $wishedEnd;

    /**
     * (no documentation provided)
     *
     * @var boolean
     */
    private $appointmentChanged;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $timeZone;

    /**
     * True if invoice has been sent
     *
     * @var boolean
     */
    private $invoiceSent;

    /**
     * Customer id (if using customer tab in UI)
     *
     * @var string
     */
    private $customerId;

    /**
     * (no documentation provided)
     *
     * @var boolean
     */
    private $appointmentFixed;

    /**
     * List of documents urls
     *
     * @var string[]
     */
    private $documentUrls;

    /**
     * Organization id
     *
     * @var string
     */
    private $organization;

    /**
     * True if order has been canceled or refused by user through the mobile app
     *
     * @var boolean
     */
    private $canceledByUser;

    /**
     * True if order has been canceled by customer (requesting a new time slot)
     *
     * @var boolean
     */
    private $canceledByCustomer;

    /**
     * True if order has been rescheduled and shared
     *
     * @var boolean
     */
    private $rescheduled;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $rescheduleCount;

    /**
     * For canceled orders : id of the simulation if it have been re-integrated
     *
     * @var string
     */
    private $rescheduledInSimulation;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $fuelType;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $vehicleType;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $averageFuelConsumption;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $workerSignatureSvg;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $workerSignaturePicture;

    /**
     * Constructs a OperationalOrderAchievement from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * Mobile resource identifier (mobile app login)
     *
     * @return string
     */
    public function getOperationalResourceId()
    {
        return $this->operationalResourceId;
    }

    /**
     * Mobile resource identifier (mobile app login)
     *
     * @param string $operationalResourceId
     */
    public function setOperationalResourceId($operationalResourceId)
    {
        $this->operationalResourceId = $operationalResourceId;
    }
    /**
     * Planned order
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSPlanned
     */
    public function getPlannedOrder()
    {
        return $this->plannedOrder;
    }

    /**
     * Planned order
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSPlanned $plannedOrder
     */
    public function setPlannedOrder($plannedOrder)
    {
        $this->plannedOrder = $plannedOrder;
    }
    /**
     * Original order
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSOrder
     */
    public function getOrder()
    {
        return $this->order;
    }

    /**
     * Original order
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSOrder $order
     */
    public function setOrder($order)
    {
        $this->order = $order;
    }
    /**
     * Planning day
     *
     * @return integer
     */
    public function getDate()
    {
        return $this->date;
    }

    /**
     * Planning day
     *
     * @param integer $date
     */
    public function setDate($date)
    {
        $this->date = $date;
    }
    /**
     * Planned start date and time
     *
     * @return integer
     */
    public function getStart()
    {
        return $this->start;
    }

    /**
     * Planned start date and time
     *
     * @param integer $start
     */
    public function setStart($start)
    {
        $this->start = $start;
    }
    /**
     * Planned end date and time
     *
     * @return integer
     */
    public function getEnd()
    {
        return $this->end;
    }

    /**
     * Planned end date and time
     *
     * @param integer $end
     */
    public function setEnd($end)
    {
        $this->end = $end;
    }
    /**
     * fulfillment status
     *
     * @return string
     */
    public function getStatus()
    {
        return $this->status;
    }

    /**
     * fulfillment status
     *
     * @param string $status
     */
    public function setStatus($status)
    {
        $this->status = $status;
    }
    /**
     * Event type
     *
     * @return string
     */
    public function getType()
    {
        return $this->type;
    }

    /**
     * Event type
     *
     * @param string $type
     */
    public function setType($type)
    {
        $this->type = $type;
    }
    /**
     * Longitude
     *
     * @return double
     */
    public function getLon()
    {
        return $this->lon;
    }

    /**
     * Longitude
     *
     * @param double $lon
     */
    public function setLon($lon)
    {
        $this->lon = $lon;
    }
    /**
     * Latitude
     *
     * @return double
     */
    public function getLat()
    {
        return $this->lat;
    }

    /**
     * Latitude
     *
     * @param double $lat
     */
    public function setLat($lat)
    {
        $this->lat = $lat;
    }
    /**
     * Last change from mobile app
     *
     * @return integer
     */
    public function getLastSynchroStatusChange()
    {
        return $this->lastSynchroStatusChange;
    }

    /**
     * Last change from mobile app
     *
     * @param integer $lastSynchroStatusChange
     */
    public function setLastSynchroStatusChange($lastSynchroStatusChange)
    {
        $this->lastSynchroStatusChange = $lastSynchroStatusChange;
    }
    /**
     * Sync status
     *
     * @return string
     */
    public function getSynchroStatus()
    {
        return $this->synchroStatus;
    }

    /**
     * Sync status
     *
     * @param string $synchroStatus
     */
    public function setSynchroStatus($synchroStatus)
    {
        $this->synchroStatus = $synchroStatus;
    }
    /**
     * Achievement start date and time
     *
     * @return integer
     */
    public function getAchievementStart()
    {
        return $this->achievementStart;
    }

    /**
     * Achievement start date and time
     *
     * @param integer $achievementStart
     */
    public function setAchievementStart($achievementStart)
    {
        $this->achievementStart = $achievementStart;
    }
    /**
     * Achievement end date and time
     *
     * @return integer
     */
    public function getAchievementEnd()
    {
        return $this->achievementEnd;
    }

    /**
     * Achievement end date and time
     *
     * @param integer $achievementEnd
     */
    public function setAchievementEnd($achievementEnd)
    {
        $this->achievementEnd = $achievementEnd;
    }
    /**
     * Achievement comment
     *
     * @return string
     */
    public function getAchievementComment()
    {
        return $this->achievementComment;
    }

    /**
     * Achievement comment
     *
     * @param string $achievementComment
     */
    public function setAchievementComment($achievementComment)
    {
        $this->achievementComment = $achievementComment;
    }
    /**
     * Achievement start latitude
     *
     * @return double
     */
    public function getAchievementStartLat()
    {
        return $this->achievementStartLat;
    }

    /**
     * Achievement start latitude
     *
     * @param double $achievementStartLat
     */
    public function setAchievementStartLat($achievementStartLat)
    {
        $this->achievementStartLat = $achievementStartLat;
    }
    /**
     * Achievement start longitude
     *
     * @return double
     */
    public function getAchievementStartLon()
    {
        return $this->achievementStartLon;
    }

    /**
     * Achievement start longitude
     *
     * @param double $achievementStartLon
     */
    public function setAchievementStartLon($achievementStartLon)
    {
        $this->achievementStartLon = $achievementStartLon;
    }
    /**
     * Achievement end latitude
     *
     * @return double
     */
    public function getAchievementEndLat()
    {
        return $this->achievementEndLat;
    }

    /**
     * Achievement end latitude
     *
     * @param double $achievementEndLat
     */
    public function setAchievementEndLat($achievementEndLat)
    {
        $this->achievementEndLat = $achievementEndLat;
    }
    /**
     * Achievement end longitude
     *
     * @return double
     */
    public function getAchievementEndLon()
    {
        return $this->achievementEndLon;
    }

    /**
     * Achievement end longitude
     *
     * @param double $achievementEndLon
     */
    public function setAchievementEndLon($achievementEndLon)
    {
        $this->achievementEndLon = $achievementEndLon;
    }
    /**
     * Address and position info
     *
     * @return \Com\Geoconcept\Toursolver\Model\GeocodeInfos
     */
    public function getGeocode()
    {
        return $this->geocode;
    }

    /**
     * Address and position info
     *
     * @param \Com\Geoconcept\Toursolver\Model\GeocodeInfos $geocode
     */
    public function setGeocode($geocode)
    {
        $this->geocode = $geocode;
    }
    /**
     * Signature svg
     *
     * @return string
     */
    public function getSignatureSvg()
    {
        return $this->signatureSvg;
    }

    /**
     * Signature svg
     *
     * @param string $signatureSvg
     */
    public function setSignatureSvg($signatureSvg)
    {
        $this->signatureSvg = $signatureSvg;
    }
    /**
     * Signature, as a picture relative URL (a flavor of the reference
       * &#39;signatureSvg&#39;)
       * 
       * &lt;p&gt;
       * Is bound and synced from the &#39;signaturesSvg&#39; field. Is a relative URL, as
       * also done for the &#39;pictures&#39; field (see its documentation for details).
     *
     * @return string
     */
    public function getSignaturePicture()
    {
        return $this->signaturePicture;
    }

    /**
     * Signature, as a picture relative URL (a flavor of the reference
       * &#39;signatureSvg&#39;)
       * 
       * &lt;p&gt;
       * Is bound and synced from the &#39;signaturesSvg&#39; field. Is a relative URL, as
       * also done for the &#39;pictures&#39; field (see its documentation for details).
     *
     * @param string $signaturePicture
     */
    public function setSignaturePicture($signaturePicture)
    {
        $this->signaturePicture = $signaturePicture;
    }
    /**
     * fulfillment form data
     *
     * @return array
     */
    public function getData()
    {
        return $this->data;
    }

    /**
     * fulfillment form data
     *
     * @param array $data
     */
    public function setData($data)
    {
        $this->data = $data;
    }
    /**
     * List of picture relative urls. Url root for pictures is
       * https://api.geoconcept.com/ToursolverCloud/api/rest/otmobile/pictures/
     *
     * @return string[]
     */
    public function getPictures()
    {
        return $this->pictures;
    }

    /**
     * List of picture relative urls. Url root for pictures is
       * https://api.geoconcept.com/ToursolverCloud/api/rest/otmobile/pictures/
     *
     * @param string[] $pictures
     */
    public function setPictures($pictures)
    {
        $this->pictures = $pictures;
    }
    /**
     * identifier of the simulation used to fill the fulfillment planning
     *
     * @return string
     */
    public function getSimulationId()
    {
        return $this->simulationId;
    }

    /**
     * identifier of the simulation used to fill the fulfillment planning
     *
     * @param string $simulationId
     */
    public function setSimulationId($simulationId)
    {
        $this->simulationId = $simulationId;
    }
    /**
     * day containing this order in the simulation used to fill the fulfillment
       * planning
     *
     * @return string
     */
    public function getSimulationDayId()
    {
        return $this->simulationDayId;
    }

    /**
     * day containing this order in the simulation used to fill the fulfillment
       * planning
     *
     * @param string $simulationDayId
     */
    public function setSimulationDayId($simulationDayId)
    {
        $this->simulationDayId = $simulationDayId;
    }
    /**
     * End of time window communicated to customer
     *
     * @return integer
     */
    public function getTimeWindowEnd()
    {
        return $this->timeWindowEnd;
    }

    /**
     * End of time window communicated to customer
     *
     * @param integer $timeWindowEnd
     */
    public function setTimeWindowEnd($timeWindowEnd)
    {
        $this->timeWindowEnd = $timeWindowEnd;
    }
    /**
     * Start of time window communicated to customer
     *
     * @return integer
     */
    public function getTimeWindowStart()
    {
        return $this->timeWindowStart;
    }

    /**
     * Start of time window communicated to customer
     *
     * @param integer $timeWindowStart
     */
    public function setTimeWindowStart($timeWindowStart)
    {
        $this->timeWindowStart = $timeWindowStart;
    }
    /**
     * Start of time window requested by customer after slot notification or visit canceling
     *
     * @return integer
     */
    public function getWishedStart()
    {
        return $this->wishedStart;
    }

    /**
     * Start of time window requested by customer after slot notification or visit canceling
     *
     * @param integer $wishedStart
     */
    public function setWishedStart($wishedStart)
    {
        $this->wishedStart = $wishedStart;
    }
    /**
     * End of time window requested by customer after slot notification or visit canceling
     *
     * @return integer
     */
    public function getWishedEnd()
    {
        return $this->wishedEnd;
    }

    /**
     * End of time window requested by customer after slot notification or visit canceling
     *
     * @param integer $wishedEnd
     */
    public function setWishedEnd($wishedEnd)
    {
        $this->wishedEnd = $wishedEnd;
    }
    /**
     * (no documentation provided)
     *
     * @return boolean
     */
    public function getAppointmentChanged()
    {
        return $this->appointmentChanged;
    }

    /**
     * (no documentation provided)
     *
     * @param boolean $appointmentChanged
     */
    public function setAppointmentChanged($appointmentChanged)
    {
        $this->appointmentChanged = $appointmentChanged;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getTimeZone()
    {
        return $this->timeZone;
    }

    /**
     * (no documentation provided)
     *
     * @param string $timeZone
     */
    public function setTimeZone($timeZone)
    {
        $this->timeZone = $timeZone;
    }
    /**
     * True if invoice has been sent
     *
     * @return boolean
     */
    public function getInvoiceSent()
    {
        return $this->invoiceSent;
    }

    /**
     * True if invoice has been sent
     *
     * @param boolean $invoiceSent
     */
    public function setInvoiceSent($invoiceSent)
    {
        $this->invoiceSent = $invoiceSent;
    }
    /**
     * Customer id (if using customer tab in UI)
     *
     * @return string
     */
    public function getCustomerId()
    {
        return $this->customerId;
    }

    /**
     * Customer id (if using customer tab in UI)
     *
     * @param string $customerId
     */
    public function setCustomerId($customerId)
    {
        $this->customerId = $customerId;
    }
    /**
     * (no documentation provided)
     *
     * @return boolean
     */
    public function getAppointmentFixed()
    {
        return $this->appointmentFixed;
    }

    /**
     * (no documentation provided)
     *
     * @param boolean $appointmentFixed
     */
    public function setAppointmentFixed($appointmentFixed)
    {
        $this->appointmentFixed = $appointmentFixed;
    }
    /**
     * List of documents urls
     *
     * @return string[]
     */
    public function getDocumentUrls()
    {
        return $this->documentUrls;
    }

    /**
     * List of documents urls
     *
     * @param string[] $documentUrls
     */
    public function setDocumentUrls($documentUrls)
    {
        $this->documentUrls = $documentUrls;
    }
    /**
     * Organization id
     *
     * @return string
     */
    public function getOrganization()
    {
        return $this->organization;
    }

    /**
     * Organization id
     *
     * @param string $organization
     */
    public function setOrganization($organization)
    {
        $this->organization = $organization;
    }
    /**
     * True if order has been canceled or refused by user through the mobile app
     *
     * @return boolean
     */
    public function getCanceledByUser()
    {
        return $this->canceledByUser;
    }

    /**
     * True if order has been canceled or refused by user through the mobile app
     *
     * @param boolean $canceledByUser
     */
    public function setCanceledByUser($canceledByUser)
    {
        $this->canceledByUser = $canceledByUser;
    }
    /**
     * True if order has been canceled by customer (requesting a new time slot)
     *
     * @return boolean
     */
    public function getCanceledByCustomer()
    {
        return $this->canceledByCustomer;
    }

    /**
     * True if order has been canceled by customer (requesting a new time slot)
     *
     * @param boolean $canceledByCustomer
     */
    public function setCanceledByCustomer($canceledByCustomer)
    {
        $this->canceledByCustomer = $canceledByCustomer;
    }
    /**
     * True if order has been rescheduled and shared
     *
     * @return boolean
     */
    public function getRescheduled()
    {
        return $this->rescheduled;
    }

    /**
     * True if order has been rescheduled and shared
     *
     * @param boolean $rescheduled
     */
    public function setRescheduled($rescheduled)
    {
        $this->rescheduled = $rescheduled;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getRescheduleCount()
    {
        return $this->rescheduleCount;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $rescheduleCount
     */
    public function setRescheduleCount($rescheduleCount)
    {
        $this->rescheduleCount = $rescheduleCount;
    }
    /**
     * For canceled orders : id of the simulation if it have been re-integrated
     *
     * @return string
     */
    public function getRescheduledInSimulation()
    {
        return $this->rescheduledInSimulation;
    }

    /**
     * For canceled orders : id of the simulation if it have been re-integrated
     *
     * @param string $rescheduledInSimulation
     */
    public function setRescheduledInSimulation($rescheduledInSimulation)
    {
        $this->rescheduledInSimulation = $rescheduledInSimulation;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getFuelType()
    {
        return $this->fuelType;
    }

    /**
     * (no documentation provided)
     *
     * @param string $fuelType
     */
    public function setFuelType($fuelType)
    {
        $this->fuelType = $fuelType;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getVehicleType()
    {
        return $this->vehicleType;
    }

    /**
     * (no documentation provided)
     *
     * @param string $vehicleType
     */
    public function setVehicleType($vehicleType)
    {
        $this->vehicleType = $vehicleType;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getAverageFuelConsumption()
    {
        return $this->averageFuelConsumption;
    }

    /**
     * (no documentation provided)
     *
     * @param double $averageFuelConsumption
     */
    public function setAverageFuelConsumption($averageFuelConsumption)
    {
        $this->averageFuelConsumption = $averageFuelConsumption;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getWorkerSignatureSvg()
    {
        return $this->workerSignatureSvg;
    }

    /**
     * (no documentation provided)
     *
     * @param string $workerSignatureSvg
     */
    public function setWorkerSignatureSvg($workerSignatureSvg)
    {
        $this->workerSignatureSvg = $workerSignatureSvg;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getWorkerSignaturePicture()
    {
        return $this->workerSignaturePicture;
    }

    /**
     * (no documentation provided)
     *
     * @param string $workerSignaturePicture
     */
    public function setWorkerSignaturePicture($workerSignaturePicture)
    {
        $this->workerSignaturePicture = $workerSignaturePicture;
    }

    /**
     * Sets a known child element of OperationalOrderAchievement from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'operationalResourceId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->operationalResourceId = $child;
            $happened = true;
        }
        else if (($xml->localName == 'plannedOrder') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSPlanned($xml);
            $this->plannedOrder = $child;
            $happened = true;
        }
        else if (($xml->localName == 'order') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSOrder($xml);
            $this->order = $child;
            $happened = true;
        }
        else if (($xml->localName == 'date') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->date = $child;
            $happened = true;
        }
        else if (($xml->localName == 'start') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->start = $child;
            $happened = true;
        }
        else if (($xml->localName == 'end') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->end = $child;
            $happened = true;
        }
        else if (($xml->localName == 'status') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->status = $child;
            $happened = true;
        }
        else if (($xml->localName == 'type') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->type = $child;
            $happened = true;
        }
        else if (($xml->localName == 'lon') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->lon = $child;
            $happened = true;
        }
        else if (($xml->localName == 'lat') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->lat = $child;
            $happened = true;
        }
        else if (($xml->localName == 'lastSynchroStatusChange') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->lastSynchroStatusChange = $child;
            $happened = true;
        }
        else if (($xml->localName == 'synchroStatus') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->synchroStatus = $child;
            $happened = true;
        }
        else if (($xml->localName == 'achievementStart') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->achievementStart = $child;
            $happened = true;
        }
        else if (($xml->localName == 'achievementEnd') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->achievementEnd = $child;
            $happened = true;
        }
        else if (($xml->localName == 'achievementComment') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->achievementComment = $child;
            $happened = true;
        }
        else if (($xml->localName == 'achievementStartLat') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->achievementStartLat = $child;
            $happened = true;
        }
        else if (($xml->localName == 'achievementStartLon') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->achievementStartLon = $child;
            $happened = true;
        }
        else if (($xml->localName == 'achievementEndLat') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->achievementEndLat = $child;
            $happened = true;
        }
        else if (($xml->localName == 'achievementEndLon') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->achievementEndLon = $child;
            $happened = true;
        }
        else if (($xml->localName == 'geocode') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\GeocodeInfos($xml);
            $this->geocode = $child;
            $happened = true;
        }
        else if (($xml->localName == 'signatureSvg') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->signatureSvg = $child;
            $happened = true;
        }
        else if (($xml->localName == 'signaturePicture') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->signaturePicture = $child;
            $happened = true;
        }
        else if (($xml->localName == 'data') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->data = $child;
            $happened = true;
        }
        else if (($xml->localName == 'pictures') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->pictures)) {
                $this->pictures = array();
            }
            array_push($this->pictures, $child);
            $happened = true;
        }
        else if (($xml->localName == 'simulationId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->simulationId = $child;
            $happened = true;
        }
        else if (($xml->localName == 'simulationDayId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->simulationDayId = $child;
            $happened = true;
        }
        else if (($xml->localName == 'timeWindowEnd') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->timeWindowEnd = $child;
            $happened = true;
        }
        else if (($xml->localName == 'timeWindowStart') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->timeWindowStart = $child;
            $happened = true;
        }
        else if (($xml->localName == 'wishedStart') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->wishedStart = $child;
            $happened = true;
        }
        else if (($xml->localName == 'wishedEnd') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->wishedEnd = $child;
            $happened = true;
        }
        else if (($xml->localName == 'appointmentChanged') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->appointmentChanged = $child;
            $happened = true;
        }
        else if (($xml->localName == 'timeZone') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->timeZone = $child;
            $happened = true;
        }
        else if (($xml->localName == 'invoiceSent') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->invoiceSent = $child;
            $happened = true;
        }
        else if (($xml->localName == 'customerId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->customerId = $child;
            $happened = true;
        }
        else if (($xml->localName == 'appointmentFixed') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->appointmentFixed = $child;
            $happened = true;
        }
        else if (($xml->localName == 'documentUrls') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->documentUrls)) {
                $this->documentUrls = array();
            }
            array_push($this->documentUrls, $child);
            $happened = true;
        }
        else if (($xml->localName == 'organization') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->organization = $child;
            $happened = true;
        }
        else if (($xml->localName == 'canceledByUser') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->canceledByUser = $child;
            $happened = true;
        }
        else if (($xml->localName == 'canceledByCustomer') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->canceledByCustomer = $child;
            $happened = true;
        }
        else if (($xml->localName == 'rescheduled') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->rescheduled = $child;
            $happened = true;
        }
        else if (($xml->localName == 'rescheduleCount') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->rescheduleCount = $child;
            $happened = true;
        }
        else if (($xml->localName == 'rescheduledInSimulation') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->rescheduledInSimulation = $child;
            $happened = true;
        }
        else if (($xml->localName == 'fuelType') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->fuelType = $child;
            $happened = true;
        }
        else if (($xml->localName == 'vehicleType') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->vehicleType = $child;
            $happened = true;
        }
        else if (($xml->localName == 'averageFuelConsumption') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->averageFuelConsumption = $child;
            $happened = true;
        }
        else if (($xml->localName == 'workerSignatureSvg') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->workerSignatureSvg = $child;
            $happened = true;
        }
        else if (($xml->localName == 'workerSignaturePicture') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->workerSignaturePicture = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of OperationalOrderAchievement from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes the contents of this OperationalOrderAchievement to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->operationalResourceId) {
            $writer->startElementNs(null, 'operationalResourceId', null);
            $writer->text($this->operationalResourceId);
            $writer->endElement();
        }
        if ($this->plannedOrder) {
            $writer->startElementNs(null, 'plannedOrder', null);
            $this->plannedOrder->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->order) {
            $writer->startElementNs(null, 'order', null);
            $this->order->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->date) {
            $writer->startElementNs(null, 'date', null);
            $writer->text($this->date);
            $writer->endElement();
        }
        if ($this->start) {
            $writer->startElementNs(null, 'start', null);
            $writer->text($this->start);
            $writer->endElement();
        }
        if ($this->end) {
            $writer->startElementNs(null, 'end', null);
            $writer->text($this->end);
            $writer->endElement();
        }
        if ($this->status) {
            $writer->startElementNs(null, 'status', null);
            $writer->text($this->status);
            $writer->endElement();
        }
        if ($this->type) {
            $writer->startElementNs(null, 'type', null);
            $writer->text($this->type);
            $writer->endElement();
        }
        if ($this->lon) {
            $writer->startElementNs(null, 'lon', null);
            $writer->text($this->lon);
            $writer->endElement();
        }
        if ($this->lat) {
            $writer->startElementNs(null, 'lat', null);
            $writer->text($this->lat);
            $writer->endElement();
        }
        if ($this->lastSynchroStatusChange) {
            $writer->startElementNs(null, 'lastSynchroStatusChange', null);
            $writer->text($this->lastSynchroStatusChange);
            $writer->endElement();
        }
        if ($this->synchroStatus) {
            $writer->startElementNs(null, 'synchroStatus', null);
            $writer->text($this->synchroStatus);
            $writer->endElement();
        }
        if ($this->achievementStart) {
            $writer->startElementNs(null, 'achievementStart', null);
            $writer->text($this->achievementStart);
            $writer->endElement();
        }
        if ($this->achievementEnd) {
            $writer->startElementNs(null, 'achievementEnd', null);
            $writer->text($this->achievementEnd);
            $writer->endElement();
        }
        if ($this->achievementComment) {
            $writer->startElementNs(null, 'achievementComment', null);
            $writer->text($this->achievementComment);
            $writer->endElement();
        }
        if ($this->achievementStartLat) {
            $writer->startElementNs(null, 'achievementStartLat', null);
            $writer->text($this->achievementStartLat);
            $writer->endElement();
        }
        if ($this->achievementStartLon) {
            $writer->startElementNs(null, 'achievementStartLon', null);
            $writer->text($this->achievementStartLon);
            $writer->endElement();
        }
        if ($this->achievementEndLat) {
            $writer->startElementNs(null, 'achievementEndLat', null);
            $writer->text($this->achievementEndLat);
            $writer->endElement();
        }
        if ($this->achievementEndLon) {
            $writer->startElementNs(null, 'achievementEndLon', null);
            $writer->text($this->achievementEndLon);
            $writer->endElement();
        }
        if ($this->geocode) {
            $writer->startElementNs(null, 'geocode', null);
            $this->geocode->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->signatureSvg) {
            $writer->startElementNs(null, 'signatureSvg', null);
            $writer->text($this->signatureSvg);
            $writer->endElement();
        }
        if ($this->signaturePicture) {
            $writer->startElementNs(null, 'signaturePicture', null);
            $writer->text($this->signaturePicture);
            $writer->endElement();
        }
        if ($this->data) {
            $writer->startElementNs(null, 'data', null);
            $writer->text($this->data);
            $writer->endElement();
        }
        if ($this->pictures) {
            foreach ($this->pictures as $i => $x) {
                $writer->startElementNs(null, 'pictures', null);
                $writer->text($x);
                $writer->endElement();
            }
        }
        if ($this->simulationId) {
            $writer->startElementNs(null, 'simulationId', null);
            $writer->text($this->simulationId);
            $writer->endElement();
        }
        if ($this->simulationDayId) {
            $writer->startElementNs(null, 'simulationDayId', null);
            $writer->text($this->simulationDayId);
            $writer->endElement();
        }
        if ($this->timeWindowEnd) {
            $writer->startElementNs(null, 'timeWindowEnd', null);
            $writer->text($this->timeWindowEnd);
            $writer->endElement();
        }
        if ($this->timeWindowStart) {
            $writer->startElementNs(null, 'timeWindowStart', null);
            $writer->text($this->timeWindowStart);
            $writer->endElement();
        }
        if ($this->wishedStart) {
            $writer->startElementNs(null, 'wishedStart', null);
            $writer->text($this->wishedStart);
            $writer->endElement();
        }
        if ($this->wishedEnd) {
            $writer->startElementNs(null, 'wishedEnd', null);
            $writer->text($this->wishedEnd);
            $writer->endElement();
        }
        if ($this->appointmentChanged) {
            $writer->startElementNs(null, 'appointmentChanged', null);
            $writer->text($this->appointmentChanged);
            $writer->endElement();
        }
        if ($this->timeZone) {
            $writer->startElementNs(null, 'timeZone', null);
            $writer->text($this->timeZone);
            $writer->endElement();
        }
        if ($this->invoiceSent) {
            $writer->startElementNs(null, 'invoiceSent', null);
            $writer->text($this->invoiceSent);
            $writer->endElement();
        }
        if ($this->customerId) {
            $writer->startElementNs(null, 'customerId', null);
            $writer->text($this->customerId);
            $writer->endElement();
        }
        if ($this->appointmentFixed) {
            $writer->startElementNs(null, 'appointmentFixed', null);
            $writer->text($this->appointmentFixed);
            $writer->endElement();
        }
        if ($this->documentUrls) {
            foreach ($this->documentUrls as $i => $x) {
                $writer->startElementNs(null, 'documentUrls', null);
                $writer->text($x);
                $writer->endElement();
            }
        }
        if ($this->organization) {
            $writer->startElementNs(null, 'organization', null);
            $writer->text($this->organization);
            $writer->endElement();
        }
        if ($this->canceledByUser) {
            $writer->startElementNs(null, 'canceledByUser', null);
            $writer->text($this->canceledByUser);
            $writer->endElement();
        }
        if ($this->canceledByCustomer) {
            $writer->startElementNs(null, 'canceledByCustomer', null);
            $writer->text($this->canceledByCustomer);
            $writer->endElement();
        }
        if ($this->rescheduled) {
            $writer->startElementNs(null, 'rescheduled', null);
            $writer->text($this->rescheduled);
            $writer->endElement();
        }
        if ($this->rescheduleCount) {
            $writer->startElementNs(null, 'rescheduleCount', null);
            $writer->text($this->rescheduleCount);
            $writer->endElement();
        }
        if ($this->rescheduledInSimulation) {
            $writer->startElementNs(null, 'rescheduledInSimulation', null);
            $writer->text($this->rescheduledInSimulation);
            $writer->endElement();
        }
        if ($this->fuelType) {
            $writer->startElementNs(null, 'fuelType', null);
            $writer->text($this->fuelType);
            $writer->endElement();
        }
        if ($this->vehicleType) {
            $writer->startElementNs(null, 'vehicleType', null);
            $writer->text($this->vehicleType);
            $writer->endElement();
        }
        if ($this->averageFuelConsumption) {
            $writer->startElementNs(null, 'averageFuelConsumption', null);
            $writer->text($this->averageFuelConsumption);
            $writer->endElement();
        }
        if ($this->workerSignatureSvg) {
            $writer->startElementNs(null, 'workerSignatureSvg', null);
            $writer->text($this->workerSignatureSvg);
            $writer->endElement();
        }
        if ($this->workerSignaturePicture) {
            $writer->startElementNs(null, 'workerSignaturePicture', null);
            $writer->text($this->workerSignaturePicture);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Export;

/**
 * (no documentation provided)
 */
class OperationalOrderStatus
{

    /**
     * 
     */
    const CANDIDATE = "CANDIDATE";

    /**
     * 
     */
    const FIXED = "FIXED";

    /**
     * 
     */
    const ACCEPTED = "ACCEPTED";

    /**
     * 
     */
    const REFUSED = "REFUSED";

    /**
     * 
     */
    const REFUSED_BY_CUSTOMER = "REFUSED_BY_CUSTOMER";

    /**
     * 
     */
    const STARTED = "STARTED";

    /**
     * 
     */
    const FINISHED = "FINISHED";

    /**
     * 
     */
    const CANCELLED = "CANCELLED";

    /**
     * 
     */
    const PAUSED = "PAUSED";

    /**
     * 
     */
    const RESUMED = "RESUMED";

    /**
     * 
     */
    const UNKNOWN = "UNKNOWN";

    /**
     * 
     */
    const TO_BE_PLANNED = "TO_BE_PLANNED";
}

namespace Com\Geoconcept\Toursolver\Model;

/**
 * (no documentation provided)
 */
class ScanItemAchievement extends \Com\Geoconcept\Toursolver\Model\ScanItem
{

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $comment;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $status;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $datetimePickupFromDepot;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $longitudePickupFromDepot;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $latitudePickupFromDepot;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $datetimeDeliveryToCustomer;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $longitudeDeliveryToCustomer;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $latitudeDeliveryToCustomer;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $datetimePickupFromCustomer;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $longitudePickupFromCustomer;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $latitudePickupFromCustomer;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $datetimeDeliveryToDepot;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $longitudeDeliveryToDepot;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $latitudeDeliveryToDepot;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $datetimeDeliveryToColleague;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $longitudeDeliveryToColleague;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $latitudeDeliveryToColleague;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $datetimePickupFromColleague;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $longitudePickupFromColleague;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $latitudePickupFromColleague;

    /**
     * (no documentation provided)
     *
     * @var string[]
     */
    private $pictures;

    /**
     * Constructs a ScanItemAchievement from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getComment()
    {
        return $this->comment;
    }

    /**
     * (no documentation provided)
     *
     * @param string $comment
     */
    public function setComment($comment)
    {
        $this->comment = $comment;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getStatus()
    {
        return $this->status;
    }

    /**
     * (no documentation provided)
     *
     * @param string $status
     */
    public function setStatus($status)
    {
        $this->status = $status;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getDatetimePickupFromDepot()
    {
        return $this->datetimePickupFromDepot;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $datetimePickupFromDepot
     */
    public function setDatetimePickupFromDepot($datetimePickupFromDepot)
    {
        $this->datetimePickupFromDepot = $datetimePickupFromDepot;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getLongitudePickupFromDepot()
    {
        return $this->longitudePickupFromDepot;
    }

    /**
     * (no documentation provided)
     *
     * @param double $longitudePickupFromDepot
     */
    public function setLongitudePickupFromDepot($longitudePickupFromDepot)
    {
        $this->longitudePickupFromDepot = $longitudePickupFromDepot;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getLatitudePickupFromDepot()
    {
        return $this->latitudePickupFromDepot;
    }

    /**
     * (no documentation provided)
     *
     * @param double $latitudePickupFromDepot
     */
    public function setLatitudePickupFromDepot($latitudePickupFromDepot)
    {
        $this->latitudePickupFromDepot = $latitudePickupFromDepot;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getDatetimeDeliveryToCustomer()
    {
        return $this->datetimeDeliveryToCustomer;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $datetimeDeliveryToCustomer
     */
    public function setDatetimeDeliveryToCustomer($datetimeDeliveryToCustomer)
    {
        $this->datetimeDeliveryToCustomer = $datetimeDeliveryToCustomer;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getLongitudeDeliveryToCustomer()
    {
        return $this->longitudeDeliveryToCustomer;
    }

    /**
     * (no documentation provided)
     *
     * @param double $longitudeDeliveryToCustomer
     */
    public function setLongitudeDeliveryToCustomer($longitudeDeliveryToCustomer)
    {
        $this->longitudeDeliveryToCustomer = $longitudeDeliveryToCustomer;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getLatitudeDeliveryToCustomer()
    {
        return $this->latitudeDeliveryToCustomer;
    }

    /**
     * (no documentation provided)
     *
     * @param double $latitudeDeliveryToCustomer
     */
    public function setLatitudeDeliveryToCustomer($latitudeDeliveryToCustomer)
    {
        $this->latitudeDeliveryToCustomer = $latitudeDeliveryToCustomer;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getDatetimePickupFromCustomer()
    {
        return $this->datetimePickupFromCustomer;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $datetimePickupFromCustomer
     */
    public function setDatetimePickupFromCustomer($datetimePickupFromCustomer)
    {
        $this->datetimePickupFromCustomer = $datetimePickupFromCustomer;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getLongitudePickupFromCustomer()
    {
        return $this->longitudePickupFromCustomer;
    }

    /**
     * (no documentation provided)
     *
     * @param double $longitudePickupFromCustomer
     */
    public function setLongitudePickupFromCustomer($longitudePickupFromCustomer)
    {
        $this->longitudePickupFromCustomer = $longitudePickupFromCustomer;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getLatitudePickupFromCustomer()
    {
        return $this->latitudePickupFromCustomer;
    }

    /**
     * (no documentation provided)
     *
     * @param double $latitudePickupFromCustomer
     */
    public function setLatitudePickupFromCustomer($latitudePickupFromCustomer)
    {
        $this->latitudePickupFromCustomer = $latitudePickupFromCustomer;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getDatetimeDeliveryToDepot()
    {
        return $this->datetimeDeliveryToDepot;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $datetimeDeliveryToDepot
     */
    public function setDatetimeDeliveryToDepot($datetimeDeliveryToDepot)
    {
        $this->datetimeDeliveryToDepot = $datetimeDeliveryToDepot;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getLongitudeDeliveryToDepot()
    {
        return $this->longitudeDeliveryToDepot;
    }

    /**
     * (no documentation provided)
     *
     * @param double $longitudeDeliveryToDepot
     */
    public function setLongitudeDeliveryToDepot($longitudeDeliveryToDepot)
    {
        $this->longitudeDeliveryToDepot = $longitudeDeliveryToDepot;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getLatitudeDeliveryToDepot()
    {
        return $this->latitudeDeliveryToDepot;
    }

    /**
     * (no documentation provided)
     *
     * @param double $latitudeDeliveryToDepot
     */
    public function setLatitudeDeliveryToDepot($latitudeDeliveryToDepot)
    {
        $this->latitudeDeliveryToDepot = $latitudeDeliveryToDepot;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getDatetimeDeliveryToColleague()
    {
        return $this->datetimeDeliveryToColleague;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $datetimeDeliveryToColleague
     */
    public function setDatetimeDeliveryToColleague($datetimeDeliveryToColleague)
    {
        $this->datetimeDeliveryToColleague = $datetimeDeliveryToColleague;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getLongitudeDeliveryToColleague()
    {
        return $this->longitudeDeliveryToColleague;
    }

    /**
     * (no documentation provided)
     *
     * @param double $longitudeDeliveryToColleague
     */
    public function setLongitudeDeliveryToColleague($longitudeDeliveryToColleague)
    {
        $this->longitudeDeliveryToColleague = $longitudeDeliveryToColleague;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getLatitudeDeliveryToColleague()
    {
        return $this->latitudeDeliveryToColleague;
    }

    /**
     * (no documentation provided)
     *
     * @param double $latitudeDeliveryToColleague
     */
    public function setLatitudeDeliveryToColleague($latitudeDeliveryToColleague)
    {
        $this->latitudeDeliveryToColleague = $latitudeDeliveryToColleague;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getDatetimePickupFromColleague()
    {
        return $this->datetimePickupFromColleague;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $datetimePickupFromColleague
     */
    public function setDatetimePickupFromColleague($datetimePickupFromColleague)
    {
        $this->datetimePickupFromColleague = $datetimePickupFromColleague;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getLongitudePickupFromColleague()
    {
        return $this->longitudePickupFromColleague;
    }

    /**
     * (no documentation provided)
     *
     * @param double $longitudePickupFromColleague
     */
    public function setLongitudePickupFromColleague($longitudePickupFromColleague)
    {
        $this->longitudePickupFromColleague = $longitudePickupFromColleague;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getLatitudePickupFromColleague()
    {
        return $this->latitudePickupFromColleague;
    }

    /**
     * (no documentation provided)
     *
     * @param double $latitudePickupFromColleague
     */
    public function setLatitudePickupFromColleague($latitudePickupFromColleague)
    {
        $this->latitudePickupFromColleague = $latitudePickupFromColleague;
    }
    /**
     * (no documentation provided)
     *
     * @return string[]
     */
    public function getPictures()
    {
        return $this->pictures;
    }

    /**
     * (no documentation provided)
     *
     * @param string[] $pictures
     */
    public function setPictures($pictures)
    {
        $this->pictures = $pictures;
    }

    /**
     * Sets a known child element of ScanItemAchievement from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'comment') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->comment = $child;
            $happened = true;
        }
        else if (($xml->localName == 'status') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->status = $child;
            $happened = true;
        }
        else if (($xml->localName == 'datetimePickupFromDepot') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->datetimePickupFromDepot = $child;
            $happened = true;
        }
        else if (($xml->localName == 'longitudePickupFromDepot') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->longitudePickupFromDepot = $child;
            $happened = true;
        }
        else if (($xml->localName == 'latitudePickupFromDepot') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->latitudePickupFromDepot = $child;
            $happened = true;
        }
        else if (($xml->localName == 'datetimeDeliveryToCustomer') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->datetimeDeliveryToCustomer = $child;
            $happened = true;
        }
        else if (($xml->localName == 'longitudeDeliveryToCustomer') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->longitudeDeliveryToCustomer = $child;
            $happened = true;
        }
        else if (($xml->localName == 'latitudeDeliveryToCustomer') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->latitudeDeliveryToCustomer = $child;
            $happened = true;
        }
        else if (($xml->localName == 'datetimePickupFromCustomer') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->datetimePickupFromCustomer = $child;
            $happened = true;
        }
        else if (($xml->localName == 'longitudePickupFromCustomer') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->longitudePickupFromCustomer = $child;
            $happened = true;
        }
        else if (($xml->localName == 'latitudePickupFromCustomer') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->latitudePickupFromCustomer = $child;
            $happened = true;
        }
        else if (($xml->localName == 'datetimeDeliveryToDepot') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->datetimeDeliveryToDepot = $child;
            $happened = true;
        }
        else if (($xml->localName == 'longitudeDeliveryToDepot') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->longitudeDeliveryToDepot = $child;
            $happened = true;
        }
        else if (($xml->localName == 'latitudeDeliveryToDepot') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->latitudeDeliveryToDepot = $child;
            $happened = true;
        }
        else if (($xml->localName == 'datetimeDeliveryToColleague') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->datetimeDeliveryToColleague = $child;
            $happened = true;
        }
        else if (($xml->localName == 'longitudeDeliveryToColleague') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->longitudeDeliveryToColleague = $child;
            $happened = true;
        }
        else if (($xml->localName == 'latitudeDeliveryToColleague') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->latitudeDeliveryToColleague = $child;
            $happened = true;
        }
        else if (($xml->localName == 'datetimePickupFromColleague') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->datetimePickupFromColleague = $child;
            $happened = true;
        }
        else if (($xml->localName == 'longitudePickupFromColleague') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->longitudePickupFromColleague = $child;
            $happened = true;
        }
        else if (($xml->localName == 'latitudePickupFromColleague') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->latitudePickupFromColleague = $child;
            $happened = true;
        }
        else if (($xml->localName == 'pictures') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->pictures)) {
                $this->pictures = array();
            }
            array_push($this->pictures, $child);
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of ScanItemAchievement from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes the contents of this ScanItemAchievement to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->comment) {
            $writer->startElementNs(null, 'comment', null);
            $writer->text($this->comment);
            $writer->endElement();
        }
        if ($this->status) {
            $writer->startElementNs(null, 'status', null);
            $writer->text($this->status);
            $writer->endElement();
        }
        if ($this->datetimePickupFromDepot) {
            $writer->startElementNs(null, 'datetimePickupFromDepot', null);
            $writer->text($this->datetimePickupFromDepot);
            $writer->endElement();
        }
        if ($this->longitudePickupFromDepot) {
            $writer->startElementNs(null, 'longitudePickupFromDepot', null);
            $writer->text($this->longitudePickupFromDepot);
            $writer->endElement();
        }
        if ($this->latitudePickupFromDepot) {
            $writer->startElementNs(null, 'latitudePickupFromDepot', null);
            $writer->text($this->latitudePickupFromDepot);
            $writer->endElement();
        }
        if ($this->datetimeDeliveryToCustomer) {
            $writer->startElementNs(null, 'datetimeDeliveryToCustomer', null);
            $writer->text($this->datetimeDeliveryToCustomer);
            $writer->endElement();
        }
        if ($this->longitudeDeliveryToCustomer) {
            $writer->startElementNs(null, 'longitudeDeliveryToCustomer', null);
            $writer->text($this->longitudeDeliveryToCustomer);
            $writer->endElement();
        }
        if ($this->latitudeDeliveryToCustomer) {
            $writer->startElementNs(null, 'latitudeDeliveryToCustomer', null);
            $writer->text($this->latitudeDeliveryToCustomer);
            $writer->endElement();
        }
        if ($this->datetimePickupFromCustomer) {
            $writer->startElementNs(null, 'datetimePickupFromCustomer', null);
            $writer->text($this->datetimePickupFromCustomer);
            $writer->endElement();
        }
        if ($this->longitudePickupFromCustomer) {
            $writer->startElementNs(null, 'longitudePickupFromCustomer', null);
            $writer->text($this->longitudePickupFromCustomer);
            $writer->endElement();
        }
        if ($this->latitudePickupFromCustomer) {
            $writer->startElementNs(null, 'latitudePickupFromCustomer', null);
            $writer->text($this->latitudePickupFromCustomer);
            $writer->endElement();
        }
        if ($this->datetimeDeliveryToDepot) {
            $writer->startElementNs(null, 'datetimeDeliveryToDepot', null);
            $writer->text($this->datetimeDeliveryToDepot);
            $writer->endElement();
        }
        if ($this->longitudeDeliveryToDepot) {
            $writer->startElementNs(null, 'longitudeDeliveryToDepot', null);
            $writer->text($this->longitudeDeliveryToDepot);
            $writer->endElement();
        }
        if ($this->latitudeDeliveryToDepot) {
            $writer->startElementNs(null, 'latitudeDeliveryToDepot', null);
            $writer->text($this->latitudeDeliveryToDepot);
            $writer->endElement();
        }
        if ($this->datetimeDeliveryToColleague) {
            $writer->startElementNs(null, 'datetimeDeliveryToColleague', null);
            $writer->text($this->datetimeDeliveryToColleague);
            $writer->endElement();
        }
        if ($this->longitudeDeliveryToColleague) {
            $writer->startElementNs(null, 'longitudeDeliveryToColleague', null);
            $writer->text($this->longitudeDeliveryToColleague);
            $writer->endElement();
        }
        if ($this->latitudeDeliveryToColleague) {
            $writer->startElementNs(null, 'latitudeDeliveryToColleague', null);
            $writer->text($this->latitudeDeliveryToColleague);
            $writer->endElement();
        }
        if ($this->datetimePickupFromColleague) {
            $writer->startElementNs(null, 'datetimePickupFromColleague', null);
            $writer->text($this->datetimePickupFromColleague);
            $writer->endElement();
        }
        if ($this->longitudePickupFromColleague) {
            $writer->startElementNs(null, 'longitudePickupFromColleague', null);
            $writer->text($this->longitudePickupFromColleague);
            $writer->endElement();
        }
        if ($this->latitudePickupFromColleague) {
            $writer->startElementNs(null, 'latitudePickupFromColleague', null);
            $writer->text($this->latitudePickupFromColleague);
            $writer->endElement();
        }
        if ($this->pictures) {
            foreach ($this->pictures as $i => $x) {
                $writer->startElementNs(null, 'pictures', null);
                $writer->text($x);
                $writer->endElement();
            }
        }
    }
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Optim;

/**
 * (no documentation provided)
 */
class PhoneNumberType
{

    /**
     * 
     */
    const MOBILE = "MOBILE";

    /**
     * 
     */
    const OFFICE = "OFFICE";

    /**
     * 
     */
    const HOME = "HOME";

    /**
     * 
     */
    const OFFICE_FAX = "OFFICE_FAX";

    /**
     * 
     */
    const HOME_FAX = "HOME_FAX";
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Optim;

/**
 * (no documentation provided)
 */
class DepotCostMode
{

    /**
     * 
     */
    const NONE = "NONE";

    /**
     * 
     */
    const ALL = "ALL";

    /**
     * 
     */
    const FIRST = "FIRST";

    /**
     * 
     */
    const ALLBUTFIRST = "ALLBUTFIRST";
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Optim;

/**
 * (no documentation provided)
 */
class DistanceType
{

    /**
     * 
     */
    const KILOMETERS = "KILOMETERS";

    /**
     * 
     */
    const MILES = "MILES";

    /**
     * 
     */
    const METERS = "METERS";

    /**
     * 
     */
    const FEET = "FEET";
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Optim;

/**
 * (no documentation provided)
 */
class RoutingMethod
{

    /**
     * 
     */
    const TIME = "TIME";

    /**
     * 
     */
    const DISTANCE = "DISTANCE";
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class CheckScheduleSlotsResult extends \Com\Geoconcept\Toursolver\Webservices\ToursolverServiceResult
{

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Export\ScheduleSlot[]
     */
    private $slots;

    /**
     * Constructs a CheckScheduleSlotsResult from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Export\ScheduleSlot[]
     */
    public function getSlots()
    {
        return $this->slots;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Export\ScheduleSlot[] $slots
     */
    public function setSlots($slots)
    {
        $this->slots = $slots;
    }

    /**
     * Sets a known child element of CheckScheduleSlotsResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'slots') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Export\ScheduleSlot($xml);
            if (!isset($this->slots)) {
                $this->slots = array();
            }
            array_push($this->slots, $child);
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of CheckScheduleSlotsResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes this CheckScheduleSlotsResult to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'checkScheduleSlotsResult', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this CheckScheduleSlotsResult to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->slots) {
            foreach ($this->slots as $i => $x) {
                $writer->startElementNs(null, 'slots', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class DepotsResult extends \Com\Geoconcept\Toursolver\Webservices\ToursolverServiceResult
{

    /**
     * List of depots
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSDepot[]
     */
    private $depots;

    /**
     * Constructs a DepotsResult from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * List of depots
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSDepot[]
     */
    public function getDepots()
    {
        return $this->depots;
    }

    /**
     * List of depots
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSDepot[] $depots
     */
    public function setDepots($depots)
    {
        $this->depots = $depots;
    }

    /**
     * Sets a known child element of DepotsResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'depots') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSDepot($xml);
            if (!isset($this->depots)) {
                $this->depots = array();
            }
            array_push($this->depots, $child);
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of DepotsResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes this DepotsResult to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'depotsResult', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this DepotsResult to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->depots) {
            foreach ($this->depots as $i => $x) {
                $writer->startElementNs(null, 'depots', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class FindClientsResult extends \Com\Geoconcept\Toursolver\Webservices\ToursolverServiceResult
{

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Mycustomers\Api\Model\ClientEntity[]
     */
    private $clients;

    /**
     * Constructs a FindClientsResult from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Mycustomers\Api\Model\ClientEntity[]
     */
    public function getClients()
    {
        return $this->clients;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Mycustomers\Api\Model\ClientEntity[] $clients
     */
    public function setClients($clients)
    {
        $this->clients = $clients;
    }

    /**
     * Sets a known child element of FindClientsResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'clients') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Mycustomers\Api\Model\ClientEntity($xml);
            if (!isset($this->clients)) {
                $this->clients = array();
            }
            array_push($this->clients, $child);
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of FindClientsResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes this FindClientsResult to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'findClientsResult', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this FindClientsResult to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->clients) {
            foreach ($this->clients as $i => $x) {
                $writer->startElementNs(null, 'clients', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class HealthResult extends \Com\Geoconcept\Toursolver\Webservices\ToursolverServiceResult
{

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $threadCount;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $totalMemory;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $freeMemory;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $jobsCompleted;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $jobsInqueue;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $jobsProcessing;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $jobsError;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $jobsTotal;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $processCpuLoad;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $systemCpuLoad;

    /**
     * Constructs a HealthResult from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getThreadCount()
    {
        return $this->threadCount;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $threadCount
     */
    public function setThreadCount($threadCount)
    {
        $this->threadCount = $threadCount;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getTotalMemory()
    {
        return $this->totalMemory;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $totalMemory
     */
    public function setTotalMemory($totalMemory)
    {
        $this->totalMemory = $totalMemory;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getFreeMemory()
    {
        return $this->freeMemory;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $freeMemory
     */
    public function setFreeMemory($freeMemory)
    {
        $this->freeMemory = $freeMemory;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getJobsCompleted()
    {
        return $this->jobsCompleted;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $jobsCompleted
     */
    public function setJobsCompleted($jobsCompleted)
    {
        $this->jobsCompleted = $jobsCompleted;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getJobsInqueue()
    {
        return $this->jobsInqueue;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $jobsInqueue
     */
    public function setJobsInqueue($jobsInqueue)
    {
        $this->jobsInqueue = $jobsInqueue;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getJobsProcessing()
    {
        return $this->jobsProcessing;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $jobsProcessing
     */
    public function setJobsProcessing($jobsProcessing)
    {
        $this->jobsProcessing = $jobsProcessing;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getJobsError()
    {
        return $this->jobsError;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $jobsError
     */
    public function setJobsError($jobsError)
    {
        $this->jobsError = $jobsError;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getJobsTotal()
    {
        return $this->jobsTotal;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $jobsTotal
     */
    public function setJobsTotal($jobsTotal)
    {
        $this->jobsTotal = $jobsTotal;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getProcessCpuLoad()
    {
        return $this->processCpuLoad;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $processCpuLoad
     */
    public function setProcessCpuLoad($processCpuLoad)
    {
        $this->processCpuLoad = $processCpuLoad;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getSystemCpuLoad()
    {
        return $this->systemCpuLoad;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $systemCpuLoad
     */
    public function setSystemCpuLoad($systemCpuLoad)
    {
        $this->systemCpuLoad = $systemCpuLoad;
    }

    /**
     * Sets a known child element of HealthResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'threadCount') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->threadCount = $child;
            $happened = true;
        }
        else if (($xml->localName == 'totalMemory') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->totalMemory = $child;
            $happened = true;
        }
        else if (($xml->localName == 'freeMemory') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->freeMemory = $child;
            $happened = true;
        }
        else if (($xml->localName == 'jobsCompleted') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->jobsCompleted = $child;
            $happened = true;
        }
        else if (($xml->localName == 'jobsInqueue') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->jobsInqueue = $child;
            $happened = true;
        }
        else if (($xml->localName == 'jobsProcessing') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->jobsProcessing = $child;
            $happened = true;
        }
        else if (($xml->localName == 'jobsError') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->jobsError = $child;
            $happened = true;
        }
        else if (($xml->localName == 'jobsTotal') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->jobsTotal = $child;
            $happened = true;
        }
        else if (($xml->localName == 'processCpuLoad') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->processCpuLoad = $child;
            $happened = true;
        }
        else if (($xml->localName == 'systemCpuLoad') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->systemCpuLoad = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of HealthResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes this HealthResult to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'healthResult', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this HealthResult to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->threadCount) {
            $writer->startElementNs(null, 'threadCount', null);
            $writer->text($this->threadCount);
            $writer->endElement();
        }
        if ($this->totalMemory) {
            $writer->startElementNs(null, 'totalMemory', null);
            $writer->text($this->totalMemory);
            $writer->endElement();
        }
        if ($this->freeMemory) {
            $writer->startElementNs(null, 'freeMemory', null);
            $writer->text($this->freeMemory);
            $writer->endElement();
        }
        if ($this->jobsCompleted) {
            $writer->startElementNs(null, 'jobsCompleted', null);
            $writer->text($this->jobsCompleted);
            $writer->endElement();
        }
        if ($this->jobsInqueue) {
            $writer->startElementNs(null, 'jobsInqueue', null);
            $writer->text($this->jobsInqueue);
            $writer->endElement();
        }
        if ($this->jobsProcessing) {
            $writer->startElementNs(null, 'jobsProcessing', null);
            $writer->text($this->jobsProcessing);
            $writer->endElement();
        }
        if ($this->jobsError) {
            $writer->startElementNs(null, 'jobsError', null);
            $writer->text($this->jobsError);
            $writer->endElement();
        }
        if ($this->jobsTotal) {
            $writer->startElementNs(null, 'jobsTotal', null);
            $writer->text($this->jobsTotal);
            $writer->endElement();
        }
        if ($this->processCpuLoad) {
            $writer->startElementNs(null, 'processCpuLoad', null);
            $writer->text($this->processCpuLoad);
            $writer->endElement();
        }
        if ($this->systemCpuLoad) {
            $writer->startElementNs(null, 'systemCpuLoad', null);
            $writer->text($this->systemCpuLoad);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class LoginTokenResult extends \Com\Geoconcept\Toursolver\Webservices\ToursolverServiceResult
{

    /**
     * the token string
     *
     * @var string
     */
    private $token;

    /**
     * The token validity end date
     *
     * @var integer
     */
    private $validUntil;

    /**
     * Constructs a LoginTokenResult from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * the token string
     *
     * @return string
     */
    public function getToken()
    {
        return $this->token;
    }

    /**
     * the token string
     *
     * @param string $token
     */
    public function setToken($token)
    {
        $this->token = $token;
    }
    /**
     * The token validity end date
     *
     * @return integer
     */
    public function getValidUntil()
    {
        return $this->validUntil;
    }

    /**
     * The token validity end date
     *
     * @param integer $validUntil
     */
    public function setValidUntil($validUntil)
    {
        $this->validUntil = $validUntil;
    }

    /**
     * Sets a known child element of LoginTokenResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'token') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->token = $child;
            $happened = true;
        }
        else if (($xml->localName == 'validUntil') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->validUntil = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of LoginTokenResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes this LoginTokenResult to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'loginTokenResult', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this LoginTokenResult to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->token) {
            $writer->startElementNs(null, 'token', null);
            $writer->text($this->token);
            $writer->endElement();
        }
        if ($this->validUntil) {
            $writer->startElementNs(null, 'validUntil', null);
            $writer->text($this->validUntil);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class OptimStatusResult extends \Com\Geoconcept\Toursolver\Webservices\ToursolverServiceResult
{

    /**
     * Current status of the optimization process
     *
     * @var string
     */
    private $optimizeStatus;

    /**
     * Start time of the optimization
     *
     * @var integer
     */
    private $startTime;

    /**
     * Remaining Kg CO2 of the current solution
     *
     * @var double
     */
    private $currentCo2;

    /**
     * Cost of the current solution
     *
     * @var integer
     */
    private $currentCost;

    /**
     * Courier cost of the current solution
     *
     * @var integer
     */
    private $currentCourierCost;

    /**
     * Total quantity delivered of the current solution
     *
     * @var double
     */
    private $currentDeliveredQuantity;

    /**
     * Delivery cost of the current solution
     *
     * @var integer
     */
    private $currentDeliveryCost;

    /**
     * Drive cost of the current solution
     *
     * @var integer
     */
    private $currentDriveCost;

    /**
     * Drive distance of the current solution
     *
     * @var integer
     */
    private $currentDriveDistance;

    /**
     * Drive time in seconds of the current solution
     *
     * @var integer
     */
    private $currentDriveTime;

    /**
     * Fixed cost of the current solution
     *
     * @var integer
     */
    private $currentFixedCost;

    /**
     * Late time in seconds of the current solution
     *
     * @var integer
     */
    private $currentLateTime;

    /**
     * Nights cost of the current solution
     *
     * @var integer
     */
    private $currentNightsCost;

    /**
     * Overwork cost of the current solution
     *
     * @var integer
     */
    private $currentOverWorkCost;

    /**
     * Over work time in seconds of the current solution
     *
     * @var integer
     */
    private $currentOverWorkTime;

    /**
     * Total quantity picked-up of the current solution
     *
     * @var double
     */
    private $currentPickUpQuantity;

    /**
     * Rest time in seconds of the current solution
     *
     * @var integer
     */
    private $currentRestTime;

    /**
     * Number of visits unplanned or delivered by a courier of the current
     * solution
     *
     * @var integer
     */
    private $currentUnplannedVisits;

    /**
     * Wait time in seconds of the current solution
     *
     * @var integer
     */
    private $currentWaitTime;

    /**
     * Work cost of the current solution
     *
     * @var integer
     */
    private $currentWorkCost;

    /**
     * Work time in seconds of the current solution
     *
     * @var integer
     */
    private $currentWorkTime;

    /**
     * Remaining Kg CO2 of the initial solution
     *
     * @var double
     */
    private $initialCo2;

    /**
     * Cost of the initial solution
     *
     * @var integer
     */
    private $initialCost;

    /**
     * Courier cost of the initial solution
     *
     * @var integer
     */
    private $initialCourierCost;

    /**
     * Total quantity delivered of the initial solution
     *
     * @var double
     */
    private $initialDeliveredQuantity;

    /**
     * Delivery cost of the initial solution
     *
     * @var integer
     */
    private $initialDeliveryCost;

    /**
     * Drive cost of the initial solution
     *
     * @var integer
     */
    private $initialDriveCost;

    /**
     * Drive distance of the initial solution
     *
     * @var integer
     */
    private $initialDriveDistance;

    /**
     * Drive time in seconds of the initial solution
     *
     * @var integer
     */
    private $initialDriveTime;

    /**
     * Fixed cost of the initial solution
     *
     * @var integer
     */
    private $initialFixedCost;

    /**
     * Late time in seconds of the initial solution
     *
     * @var integer
     */
    private $initialLateTime;

    /**
     * Nights cost of the initial solution
     *
     * @var integer
     */
    private $initialNightsCost;

    /**
     * Overwork cost of the initial solution
     *
     * @var integer
     */
    private $initialOverWorkCost;

    /**
     * Over work time in seconds of the initial solution
     *
     * @var integer
     */
    private $initialOverWorkTime;

    /**
     * Total quantity picked-up of the initial solution
     *
     * @var double
     */
    private $initialPickUpQuantity;

    /**
     * Rest time in seconds of the initial solution
     *
     * @var integer
     */
    private $initialRestTime;

    /**
     * Number of visits unplanned or delivered by a courier of the initial
     * solution
     *
     * @var integer
     */
    private $initialUnplannedVisits;

    /**
     * Wait time in seconds of the initial solution
     *
     * @var integer
     */
    private $initialWaitTime;

    /**
     * Work cost of the initial solution
     *
     * @var integer
     */
    private $initialWorkCost;

    /**
     * Work time in seconds of the current solution
     *
     * @var integer
     */
    private $initialWorkTime;

    /**
     * Mileage and travel time matrix computing remaining time. This information
     * may not be available depending on the geographical area.
     *
     * @var integer
     */
    private $mileageChartRemainingTime;

    /**
     * initial number of open tours (tours with at least one visit)
     *
     * @var integer
     */
    private $initialOpenTourNumber;

    /**
     * initial number of open tours (tours with at least one visit)
     *
     * @var integer
     */
    private $currentOpenTourNumber;

    /**
     * Number of sub-optimizations created (after pre-sectorization)
     *
     * @var integer
     */
    private $subOptimNb;

    /**
     * Number of sub-optimizations in waiting state
     *
     * @var integer
     */
    private $subOptimWaitingNb;

    /**
     * Number of sub-optimizations in running state
     *
     * @var integer
     */
    private $subOptimRunningNb;

    /**
     * Number of sub-optimizations in finished state
     *
     * @var integer
     */
    private $subOptimFinishedNb;

    /**
     * Number of sub-optimizations in error state
     *
     * @var integer
     */
    private $subOptimErrorNb;

    /**
     * Number of sub-optimizations in aborted state
     *
     * @var integer
     */
    private $subOptimAbortedNb;

    /**
     * Id of the simulation associated to this task
     *
     * @var string
     */
    private $simulationId;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $currentVisitsNb;

    /**
     * Number of planned visits of the initial solution
     * (new engine only)
     *
     * @var integer
     */
    private $initialPlannedVisits;

    /**
     * Number of planned visits of the current solution
     * (new engine only)
     *
     * @var integer
     */
    private $currentPlannedVisits;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $positionInQueue;

    /**
     * Constructs a OptimStatusResult from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * Current status of the optimization process
     *
     * @return string
     */
    public function getOptimizeStatus()
    {
        return $this->optimizeStatus;
    }

    /**
     * Current status of the optimization process
     *
     * @param string $optimizeStatus
     */
    public function setOptimizeStatus($optimizeStatus)
    {
        $this->optimizeStatus = $optimizeStatus;
    }
    /**
     * Start time of the optimization
     *
     * @return integer
     */
    public function getStartTime()
    {
        return $this->startTime;
    }

    /**
     * Start time of the optimization
     *
     * @param integer $startTime
     */
    public function setStartTime($startTime)
    {
        $this->startTime = $startTime;
    }
    /**
     * Remaining Kg CO2 of the current solution
     *
     * @return double
     */
    public function getCurrentCo2()
    {
        return $this->currentCo2;
    }

    /**
     * Remaining Kg CO2 of the current solution
     *
     * @param double $currentCo2
     */
    public function setCurrentCo2($currentCo2)
    {
        $this->currentCo2 = $currentCo2;
    }
    /**
     * Cost of the current solution
     *
     * @return integer
     */
    public function getCurrentCost()
    {
        return $this->currentCost;
    }

    /**
     * Cost of the current solution
     *
     * @param integer $currentCost
     */
    public function setCurrentCost($currentCost)
    {
        $this->currentCost = $currentCost;
    }
    /**
     * Courier cost of the current solution
     *
     * @return integer
     */
    public function getCurrentCourierCost()
    {
        return $this->currentCourierCost;
    }

    /**
     * Courier cost of the current solution
     *
     * @param integer $currentCourierCost
     */
    public function setCurrentCourierCost($currentCourierCost)
    {
        $this->currentCourierCost = $currentCourierCost;
    }
    /**
     * Total quantity delivered of the current solution
     *
     * @return double
     */
    public function getCurrentDeliveredQuantity()
    {
        return $this->currentDeliveredQuantity;
    }

    /**
     * Total quantity delivered of the current solution
     *
     * @param double $currentDeliveredQuantity
     */
    public function setCurrentDeliveredQuantity($currentDeliveredQuantity)
    {
        $this->currentDeliveredQuantity = $currentDeliveredQuantity;
    }
    /**
     * Delivery cost of the current solution
     *
     * @return integer
     */
    public function getCurrentDeliveryCost()
    {
        return $this->currentDeliveryCost;
    }

    /**
     * Delivery cost of the current solution
     *
     * @param integer $currentDeliveryCost
     */
    public function setCurrentDeliveryCost($currentDeliveryCost)
    {
        $this->currentDeliveryCost = $currentDeliveryCost;
    }
    /**
     * Drive cost of the current solution
     *
     * @return integer
     */
    public function getCurrentDriveCost()
    {
        return $this->currentDriveCost;
    }

    /**
     * Drive cost of the current solution
     *
     * @param integer $currentDriveCost
     */
    public function setCurrentDriveCost($currentDriveCost)
    {
        $this->currentDriveCost = $currentDriveCost;
    }
    /**
     * Drive distance of the current solution
     *
     * @return integer
     */
    public function getCurrentDriveDistance()
    {
        return $this->currentDriveDistance;
    }

    /**
     * Drive distance of the current solution
     *
     * @param integer $currentDriveDistance
     */
    public function setCurrentDriveDistance($currentDriveDistance)
    {
        $this->currentDriveDistance = $currentDriveDistance;
    }
    /**
     * Drive time in seconds of the current solution
     *
     * @return integer
     */
    public function getCurrentDriveTime()
    {
        return $this->currentDriveTime;
    }

    /**
     * Drive time in seconds of the current solution
     *
     * @param integer $currentDriveTime
     */
    public function setCurrentDriveTime($currentDriveTime)
    {
        $this->currentDriveTime = $currentDriveTime;
    }
    /**
     * Fixed cost of the current solution
     *
     * @return integer
     */
    public function getCurrentFixedCost()
    {
        return $this->currentFixedCost;
    }

    /**
     * Fixed cost of the current solution
     *
     * @param integer $currentFixedCost
     */
    public function setCurrentFixedCost($currentFixedCost)
    {
        $this->currentFixedCost = $currentFixedCost;
    }
    /**
     * Late time in seconds of the current solution
     *
     * @return integer
     */
    public function getCurrentLateTime()
    {
        return $this->currentLateTime;
    }

    /**
     * Late time in seconds of the current solution
     *
     * @param integer $currentLateTime
     */
    public function setCurrentLateTime($currentLateTime)
    {
        $this->currentLateTime = $currentLateTime;
    }
    /**
     * Nights cost of the current solution
     *
     * @return integer
     */
    public function getCurrentNightsCost()
    {
        return $this->currentNightsCost;
    }

    /**
     * Nights cost of the current solution
     *
     * @param integer $currentNightsCost
     */
    public function setCurrentNightsCost($currentNightsCost)
    {
        $this->currentNightsCost = $currentNightsCost;
    }
    /**
     * Overwork cost of the current solution
     *
     * @return integer
     */
    public function getCurrentOverWorkCost()
    {
        return $this->currentOverWorkCost;
    }

    /**
     * Overwork cost of the current solution
     *
     * @param integer $currentOverWorkCost
     */
    public function setCurrentOverWorkCost($currentOverWorkCost)
    {
        $this->currentOverWorkCost = $currentOverWorkCost;
    }
    /**
     * Over work time in seconds of the current solution
     *
     * @return integer
     */
    public function getCurrentOverWorkTime()
    {
        return $this->currentOverWorkTime;
    }

    /**
     * Over work time in seconds of the current solution
     *
     * @param integer $currentOverWorkTime
     */
    public function setCurrentOverWorkTime($currentOverWorkTime)
    {
        $this->currentOverWorkTime = $currentOverWorkTime;
    }
    /**
     * Total quantity picked-up of the current solution
     *
     * @return double
     */
    public function getCurrentPickUpQuantity()
    {
        return $this->currentPickUpQuantity;
    }

    /**
     * Total quantity picked-up of the current solution
     *
     * @param double $currentPickUpQuantity
     */
    public function setCurrentPickUpQuantity($currentPickUpQuantity)
    {
        $this->currentPickUpQuantity = $currentPickUpQuantity;
    }
    /**
     * Rest time in seconds of the current solution
     *
     * @return integer
     */
    public function getCurrentRestTime()
    {
        return $this->currentRestTime;
    }

    /**
     * Rest time in seconds of the current solution
     *
     * @param integer $currentRestTime
     */
    public function setCurrentRestTime($currentRestTime)
    {
        $this->currentRestTime = $currentRestTime;
    }
    /**
     * Number of visits unplanned or delivered by a courier of the current
       * solution
     *
     * @return integer
     */
    public function getCurrentUnplannedVisits()
    {
        return $this->currentUnplannedVisits;
    }

    /**
     * Number of visits unplanned or delivered by a courier of the current
       * solution
     *
     * @param integer $currentUnplannedVisits
     */
    public function setCurrentUnplannedVisits($currentUnplannedVisits)
    {
        $this->currentUnplannedVisits = $currentUnplannedVisits;
    }
    /**
     * Wait time in seconds of the current solution
     *
     * @return integer
     */
    public function getCurrentWaitTime()
    {
        return $this->currentWaitTime;
    }

    /**
     * Wait time in seconds of the current solution
     *
     * @param integer $currentWaitTime
     */
    public function setCurrentWaitTime($currentWaitTime)
    {
        $this->currentWaitTime = $currentWaitTime;
    }
    /**
     * Work cost of the current solution
     *
     * @return integer
     */
    public function getCurrentWorkCost()
    {
        return $this->currentWorkCost;
    }

    /**
     * Work cost of the current solution
     *
     * @param integer $currentWorkCost
     */
    public function setCurrentWorkCost($currentWorkCost)
    {
        $this->currentWorkCost = $currentWorkCost;
    }
    /**
     * Work time in seconds of the current solution
     *
     * @return integer
     */
    public function getCurrentWorkTime()
    {
        return $this->currentWorkTime;
    }

    /**
     * Work time in seconds of the current solution
     *
     * @param integer $currentWorkTime
     */
    public function setCurrentWorkTime($currentWorkTime)
    {
        $this->currentWorkTime = $currentWorkTime;
    }
    /**
     * Remaining Kg CO2 of the initial solution
     *
     * @return double
     */
    public function getInitialCo2()
    {
        return $this->initialCo2;
    }

    /**
     * Remaining Kg CO2 of the initial solution
     *
     * @param double $initialCo2
     */
    public function setInitialCo2($initialCo2)
    {
        $this->initialCo2 = $initialCo2;
    }
    /**
     * Cost of the initial solution
     *
     * @return integer
     */
    public function getInitialCost()
    {
        return $this->initialCost;
    }

    /**
     * Cost of the initial solution
     *
     * @param integer $initialCost
     */
    public function setInitialCost($initialCost)
    {
        $this->initialCost = $initialCost;
    }
    /**
     * Courier cost of the initial solution
     *
     * @return integer
     */
    public function getInitialCourierCost()
    {
        return $this->initialCourierCost;
    }

    /**
     * Courier cost of the initial solution
     *
     * @param integer $initialCourierCost
     */
    public function setInitialCourierCost($initialCourierCost)
    {
        $this->initialCourierCost = $initialCourierCost;
    }
    /**
     * Total quantity delivered of the initial solution
     *
     * @return double
     */
    public function getInitialDeliveredQuantity()
    {
        return $this->initialDeliveredQuantity;
    }

    /**
     * Total quantity delivered of the initial solution
     *
     * @param double $initialDeliveredQuantity
     */
    public function setInitialDeliveredQuantity($initialDeliveredQuantity)
    {
        $this->initialDeliveredQuantity = $initialDeliveredQuantity;
    }
    /**
     * Delivery cost of the initial solution
     *
     * @return integer
     */
    public function getInitialDeliveryCost()
    {
        return $this->initialDeliveryCost;
    }

    /**
     * Delivery cost of the initial solution
     *
     * @param integer $initialDeliveryCost
     */
    public function setInitialDeliveryCost($initialDeliveryCost)
    {
        $this->initialDeliveryCost = $initialDeliveryCost;
    }
    /**
     * Drive cost of the initial solution
     *
     * @return integer
     */
    public function getInitialDriveCost()
    {
        return $this->initialDriveCost;
    }

    /**
     * Drive cost of the initial solution
     *
     * @param integer $initialDriveCost
     */
    public function setInitialDriveCost($initialDriveCost)
    {
        $this->initialDriveCost = $initialDriveCost;
    }
    /**
     * Drive distance of the initial solution
     *
     * @return integer
     */
    public function getInitialDriveDistance()
    {
        return $this->initialDriveDistance;
    }

    /**
     * Drive distance of the initial solution
     *
     * @param integer $initialDriveDistance
     */
    public function setInitialDriveDistance($initialDriveDistance)
    {
        $this->initialDriveDistance = $initialDriveDistance;
    }
    /**
     * Drive time in seconds of the initial solution
     *
     * @return integer
     */
    public function getInitialDriveTime()
    {
        return $this->initialDriveTime;
    }

    /**
     * Drive time in seconds of the initial solution
     *
     * @param integer $initialDriveTime
     */
    public function setInitialDriveTime($initialDriveTime)
    {
        $this->initialDriveTime = $initialDriveTime;
    }
    /**
     * Fixed cost of the initial solution
     *
     * @return integer
     */
    public function getInitialFixedCost()
    {
        return $this->initialFixedCost;
    }

    /**
     * Fixed cost of the initial solution
     *
     * @param integer $initialFixedCost
     */
    public function setInitialFixedCost($initialFixedCost)
    {
        $this->initialFixedCost = $initialFixedCost;
    }
    /**
     * Late time in seconds of the initial solution
     *
     * @return integer
     */
    public function getInitialLateTime()
    {
        return $this->initialLateTime;
    }

    /**
     * Late time in seconds of the initial solution
     *
     * @param integer $initialLateTime
     */
    public function setInitialLateTime($initialLateTime)
    {
        $this->initialLateTime = $initialLateTime;
    }
    /**
     * Nights cost of the initial solution
     *
     * @return integer
     */
    public function getInitialNightsCost()
    {
        return $this->initialNightsCost;
    }

    /**
     * Nights cost of the initial solution
     *
     * @param integer $initialNightsCost
     */
    public function setInitialNightsCost($initialNightsCost)
    {
        $this->initialNightsCost = $initialNightsCost;
    }
    /**
     * Overwork cost of the initial solution
     *
     * @return integer
     */
    public function getInitialOverWorkCost()
    {
        return $this->initialOverWorkCost;
    }

    /**
     * Overwork cost of the initial solution
     *
     * @param integer $initialOverWorkCost
     */
    public function setInitialOverWorkCost($initialOverWorkCost)
    {
        $this->initialOverWorkCost = $initialOverWorkCost;
    }
    /**
     * Over work time in seconds of the initial solution
     *
     * @return integer
     */
    public function getInitialOverWorkTime()
    {
        return $this->initialOverWorkTime;
    }

    /**
     * Over work time in seconds of the initial solution
     *
     * @param integer $initialOverWorkTime
     */
    public function setInitialOverWorkTime($initialOverWorkTime)
    {
        $this->initialOverWorkTime = $initialOverWorkTime;
    }
    /**
     * Total quantity picked-up of the initial solution
     *
     * @return double
     */
    public function getInitialPickUpQuantity()
    {
        return $this->initialPickUpQuantity;
    }

    /**
     * Total quantity picked-up of the initial solution
     *
     * @param double $initialPickUpQuantity
     */
    public function setInitialPickUpQuantity($initialPickUpQuantity)
    {
        $this->initialPickUpQuantity = $initialPickUpQuantity;
    }
    /**
     * Rest time in seconds of the initial solution
     *
     * @return integer
     */
    public function getInitialRestTime()
    {
        return $this->initialRestTime;
    }

    /**
     * Rest time in seconds of the initial solution
     *
     * @param integer $initialRestTime
     */
    public function setInitialRestTime($initialRestTime)
    {
        $this->initialRestTime = $initialRestTime;
    }
    /**
     * Number of visits unplanned or delivered by a courier of the initial
       * solution
     *
     * @return integer
     */
    public function getInitialUnplannedVisits()
    {
        return $this->initialUnplannedVisits;
    }

    /**
     * Number of visits unplanned or delivered by a courier of the initial
       * solution
     *
     * @param integer $initialUnplannedVisits
     */
    public function setInitialUnplannedVisits($initialUnplannedVisits)
    {
        $this->initialUnplannedVisits = $initialUnplannedVisits;
    }
    /**
     * Wait time in seconds of the initial solution
     *
     * @return integer
     */
    public function getInitialWaitTime()
    {
        return $this->initialWaitTime;
    }

    /**
     * Wait time in seconds of the initial solution
     *
     * @param integer $initialWaitTime
     */
    public function setInitialWaitTime($initialWaitTime)
    {
        $this->initialWaitTime = $initialWaitTime;
    }
    /**
     * Work cost of the initial solution
     *
     * @return integer
     */
    public function getInitialWorkCost()
    {
        return $this->initialWorkCost;
    }

    /**
     * Work cost of the initial solution
     *
     * @param integer $initialWorkCost
     */
    public function setInitialWorkCost($initialWorkCost)
    {
        $this->initialWorkCost = $initialWorkCost;
    }
    /**
     * Work time in seconds of the current solution
     *
     * @return integer
     */
    public function getInitialWorkTime()
    {
        return $this->initialWorkTime;
    }

    /**
     * Work time in seconds of the current solution
     *
     * @param integer $initialWorkTime
     */
    public function setInitialWorkTime($initialWorkTime)
    {
        $this->initialWorkTime = $initialWorkTime;
    }
    /**
     * Mileage and travel time matrix computing remaining time. This information
       * may not be available depending on the geographical area.
     *
     * @return integer
     */
    public function getMileageChartRemainingTime()
    {
        return $this->mileageChartRemainingTime;
    }

    /**
     * Mileage and travel time matrix computing remaining time. This information
       * may not be available depending on the geographical area.
     *
     * @param integer $mileageChartRemainingTime
     */
    public function setMileageChartRemainingTime($mileageChartRemainingTime)
    {
        $this->mileageChartRemainingTime = $mileageChartRemainingTime;
    }
    /**
     * initial number of open tours (tours with at least one visit)
     *
     * @return integer
     */
    public function getInitialOpenTourNumber()
    {
        return $this->initialOpenTourNumber;
    }

    /**
     * initial number of open tours (tours with at least one visit)
     *
     * @param integer $initialOpenTourNumber
     */
    public function setInitialOpenTourNumber($initialOpenTourNumber)
    {
        $this->initialOpenTourNumber = $initialOpenTourNumber;
    }
    /**
     * initial number of open tours (tours with at least one visit)
     *
     * @return integer
     */
    public function getCurrentOpenTourNumber()
    {
        return $this->currentOpenTourNumber;
    }

    /**
     * initial number of open tours (tours with at least one visit)
     *
     * @param integer $currentOpenTourNumber
     */
    public function setCurrentOpenTourNumber($currentOpenTourNumber)
    {
        $this->currentOpenTourNumber = $currentOpenTourNumber;
    }
    /**
     * Number of sub-optimizations created (after pre-sectorization)
     *
     * @return integer
     */
    public function getSubOptimNb()
    {
        return $this->subOptimNb;
    }

    /**
     * Number of sub-optimizations created (after pre-sectorization)
     *
     * @param integer $subOptimNb
     */
    public function setSubOptimNb($subOptimNb)
    {
        $this->subOptimNb = $subOptimNb;
    }
    /**
     * Number of sub-optimizations in waiting state
     *
     * @return integer
     */
    public function getSubOptimWaitingNb()
    {
        return $this->subOptimWaitingNb;
    }

    /**
     * Number of sub-optimizations in waiting state
     *
     * @param integer $subOptimWaitingNb
     */
    public function setSubOptimWaitingNb($subOptimWaitingNb)
    {
        $this->subOptimWaitingNb = $subOptimWaitingNb;
    }
    /**
     * Number of sub-optimizations in running state
     *
     * @return integer
     */
    public function getSubOptimRunningNb()
    {
        return $this->subOptimRunningNb;
    }

    /**
     * Number of sub-optimizations in running state
     *
     * @param integer $subOptimRunningNb
     */
    public function setSubOptimRunningNb($subOptimRunningNb)
    {
        $this->subOptimRunningNb = $subOptimRunningNb;
    }
    /**
     * Number of sub-optimizations in finished state
     *
     * @return integer
     */
    public function getSubOptimFinishedNb()
    {
        return $this->subOptimFinishedNb;
    }

    /**
     * Number of sub-optimizations in finished state
     *
     * @param integer $subOptimFinishedNb
     */
    public function setSubOptimFinishedNb($subOptimFinishedNb)
    {
        $this->subOptimFinishedNb = $subOptimFinishedNb;
    }
    /**
     * Number of sub-optimizations in error state
     *
     * @return integer
     */
    public function getSubOptimErrorNb()
    {
        return $this->subOptimErrorNb;
    }

    /**
     * Number of sub-optimizations in error state
     *
     * @param integer $subOptimErrorNb
     */
    public function setSubOptimErrorNb($subOptimErrorNb)
    {
        $this->subOptimErrorNb = $subOptimErrorNb;
    }
    /**
     * Number of sub-optimizations in aborted state
     *
     * @return integer
     */
    public function getSubOptimAbortedNb()
    {
        return $this->subOptimAbortedNb;
    }

    /**
     * Number of sub-optimizations in aborted state
     *
     * @param integer $subOptimAbortedNb
     */
    public function setSubOptimAbortedNb($subOptimAbortedNb)
    {
        $this->subOptimAbortedNb = $subOptimAbortedNb;
    }
    /**
     * Id of the simulation associated to this task
     *
     * @return string
     */
    public function getSimulationId()
    {
        return $this->simulationId;
    }

    /**
     * Id of the simulation associated to this task
     *
     * @param string $simulationId
     */
    public function setSimulationId($simulationId)
    {
        $this->simulationId = $simulationId;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getCurrentVisitsNb()
    {
        return $this->currentVisitsNb;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $currentVisitsNb
     */
    public function setCurrentVisitsNb($currentVisitsNb)
    {
        $this->currentVisitsNb = $currentVisitsNb;
    }
    /**
     * Number of planned visits of the initial solution
       * (new engine only)
     *
     * @return integer
     */
    public function getInitialPlannedVisits()
    {
        return $this->initialPlannedVisits;
    }

    /**
     * Number of planned visits of the initial solution
       * (new engine only)
     *
     * @param integer $initialPlannedVisits
     */
    public function setInitialPlannedVisits($initialPlannedVisits)
    {
        $this->initialPlannedVisits = $initialPlannedVisits;
    }
    /**
     * Number of planned visits of the current solution
       * (new engine only)
     *
     * @return integer
     */
    public function getCurrentPlannedVisits()
    {
        return $this->currentPlannedVisits;
    }

    /**
     * Number of planned visits of the current solution
       * (new engine only)
     *
     * @param integer $currentPlannedVisits
     */
    public function setCurrentPlannedVisits($currentPlannedVisits)
    {
        $this->currentPlannedVisits = $currentPlannedVisits;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getPositionInQueue()
    {
        return $this->positionInQueue;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $positionInQueue
     */
    public function setPositionInQueue($positionInQueue)
    {
        $this->positionInQueue = $positionInQueue;
    }

    /**
     * Sets a known child element of OptimStatusResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'optimizeStatus') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->optimizeStatus = $child;
            $happened = true;
        }
        else if (($xml->localName == 'startTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->startTime = $child;
            $happened = true;
        }
        else if (($xml->localName == 'currentCo2') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->currentCo2 = $child;
            $happened = true;
        }
        else if (($xml->localName == 'currentCost') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->currentCost = $child;
            $happened = true;
        }
        else if (($xml->localName == 'currentCourierCost') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->currentCourierCost = $child;
            $happened = true;
        }
        else if (($xml->localName == 'currentDeliveredQuantity') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->currentDeliveredQuantity = $child;
            $happened = true;
        }
        else if (($xml->localName == 'currentDeliveryCost') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->currentDeliveryCost = $child;
            $happened = true;
        }
        else if (($xml->localName == 'currentDriveCost') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->currentDriveCost = $child;
            $happened = true;
        }
        else if (($xml->localName == 'currentDriveDistance') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->currentDriveDistance = $child;
            $happened = true;
        }
        else if (($xml->localName == 'currentDriveTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->currentDriveTime = $child;
            $happened = true;
        }
        else if (($xml->localName == 'currentFixedCost') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->currentFixedCost = $child;
            $happened = true;
        }
        else if (($xml->localName == 'currentLateTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->currentLateTime = $child;
            $happened = true;
        }
        else if (($xml->localName == 'currentNightsCost') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->currentNightsCost = $child;
            $happened = true;
        }
        else if (($xml->localName == 'currentOverWorkCost') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->currentOverWorkCost = $child;
            $happened = true;
        }
        else if (($xml->localName == 'currentOverWorkTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->currentOverWorkTime = $child;
            $happened = true;
        }
        else if (($xml->localName == 'currentPickUpQuantity') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->currentPickUpQuantity = $child;
            $happened = true;
        }
        else if (($xml->localName == 'currentRestTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->currentRestTime = $child;
            $happened = true;
        }
        else if (($xml->localName == 'currentUnplannedVisits') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->currentUnplannedVisits = $child;
            $happened = true;
        }
        else if (($xml->localName == 'currentWaitTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->currentWaitTime = $child;
            $happened = true;
        }
        else if (($xml->localName == 'currentWorkCost') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->currentWorkCost = $child;
            $happened = true;
        }
        else if (($xml->localName == 'currentWorkTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->currentWorkTime = $child;
            $happened = true;
        }
        else if (($xml->localName == 'initialCo2') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->initialCo2 = $child;
            $happened = true;
        }
        else if (($xml->localName == 'initialCost') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->initialCost = $child;
            $happened = true;
        }
        else if (($xml->localName == 'initialCourierCost') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->initialCourierCost = $child;
            $happened = true;
        }
        else if (($xml->localName == 'initialDeliveredQuantity') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->initialDeliveredQuantity = $child;
            $happened = true;
        }
        else if (($xml->localName == 'initialDeliveryCost') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->initialDeliveryCost = $child;
            $happened = true;
        }
        else if (($xml->localName == 'initialDriveCost') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->initialDriveCost = $child;
            $happened = true;
        }
        else if (($xml->localName == 'initialDriveDistance') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->initialDriveDistance = $child;
            $happened = true;
        }
        else if (($xml->localName == 'initialDriveTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->initialDriveTime = $child;
            $happened = true;
        }
        else if (($xml->localName == 'initialFixedCost') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->initialFixedCost = $child;
            $happened = true;
        }
        else if (($xml->localName == 'initialLateTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->initialLateTime = $child;
            $happened = true;
        }
        else if (($xml->localName == 'initialNightsCost') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->initialNightsCost = $child;
            $happened = true;
        }
        else if (($xml->localName == 'initialOverWorkCost') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->initialOverWorkCost = $child;
            $happened = true;
        }
        else if (($xml->localName == 'initialOverWorkTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->initialOverWorkTime = $child;
            $happened = true;
        }
        else if (($xml->localName == 'initialPickUpQuantity') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->initialPickUpQuantity = $child;
            $happened = true;
        }
        else if (($xml->localName == 'initialRestTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->initialRestTime = $child;
            $happened = true;
        }
        else if (($xml->localName == 'initialUnplannedVisits') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->initialUnplannedVisits = $child;
            $happened = true;
        }
        else if (($xml->localName == 'initialWaitTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->initialWaitTime = $child;
            $happened = true;
        }
        else if (($xml->localName == 'initialWorkCost') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->initialWorkCost = $child;
            $happened = true;
        }
        else if (($xml->localName == 'initialWorkTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->initialWorkTime = $child;
            $happened = true;
        }
        else if (($xml->localName == 'mileageChartRemainingTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->mileageChartRemainingTime = $child;
            $happened = true;
        }
        else if (($xml->localName == 'initialOpenTourNumber') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->initialOpenTourNumber = $child;
            $happened = true;
        }
        else if (($xml->localName == 'currentOpenTourNumber') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->currentOpenTourNumber = $child;
            $happened = true;
        }
        else if (($xml->localName == 'subOptimNb') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->subOptimNb = $child;
            $happened = true;
        }
        else if (($xml->localName == 'subOptimWaitingNb') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->subOptimWaitingNb = $child;
            $happened = true;
        }
        else if (($xml->localName == 'subOptimRunningNb') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->subOptimRunningNb = $child;
            $happened = true;
        }
        else if (($xml->localName == 'subOptimFinishedNb') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->subOptimFinishedNb = $child;
            $happened = true;
        }
        else if (($xml->localName == 'subOptimErrorNb') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->subOptimErrorNb = $child;
            $happened = true;
        }
        else if (($xml->localName == 'subOptimAbortedNb') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->subOptimAbortedNb = $child;
            $happened = true;
        }
        else if (($xml->localName == 'simulationId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->simulationId = $child;
            $happened = true;
        }
        else if (($xml->localName == 'currentVisitsNb') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->currentVisitsNb = $child;
            $happened = true;
        }
        else if (($xml->localName == 'initialPlannedVisits') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->initialPlannedVisits = $child;
            $happened = true;
        }
        else if (($xml->localName == 'currentPlannedVisits') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->currentPlannedVisits = $child;
            $happened = true;
        }
        else if (($xml->localName == 'positionInQueue') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->positionInQueue = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of OptimStatusResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes this OptimStatusResult to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'optimStatusResult', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this OptimStatusResult to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->optimizeStatus) {
            $writer->startElementNs(null, 'optimizeStatus', null);
            $writer->text($this->optimizeStatus);
            $writer->endElement();
        }
        if ($this->startTime) {
            $writer->startElementNs(null, 'startTime', null);
            $writer->text($this->startTime);
            $writer->endElement();
        }
        if ($this->currentCo2) {
            $writer->startElementNs(null, 'currentCo2', null);
            $writer->text($this->currentCo2);
            $writer->endElement();
        }
        if ($this->currentCost) {
            $writer->startElementNs(null, 'currentCost', null);
            $writer->text($this->currentCost);
            $writer->endElement();
        }
        if ($this->currentCourierCost) {
            $writer->startElementNs(null, 'currentCourierCost', null);
            $writer->text($this->currentCourierCost);
            $writer->endElement();
        }
        if ($this->currentDeliveredQuantity) {
            $writer->startElementNs(null, 'currentDeliveredQuantity', null);
            $writer->text($this->currentDeliveredQuantity);
            $writer->endElement();
        }
        if ($this->currentDeliveryCost) {
            $writer->startElementNs(null, 'currentDeliveryCost', null);
            $writer->text($this->currentDeliveryCost);
            $writer->endElement();
        }
        if ($this->currentDriveCost) {
            $writer->startElementNs(null, 'currentDriveCost', null);
            $writer->text($this->currentDriveCost);
            $writer->endElement();
        }
        if ($this->currentDriveDistance) {
            $writer->startElementNs(null, 'currentDriveDistance', null);
            $writer->text($this->currentDriveDistance);
            $writer->endElement();
        }
        if ($this->currentDriveTime) {
            $writer->startElementNs(null, 'currentDriveTime', null);
            $writer->text($this->currentDriveTime);
            $writer->endElement();
        }
        if ($this->currentFixedCost) {
            $writer->startElementNs(null, 'currentFixedCost', null);
            $writer->text($this->currentFixedCost);
            $writer->endElement();
        }
        if ($this->currentLateTime) {
            $writer->startElementNs(null, 'currentLateTime', null);
            $writer->text($this->currentLateTime);
            $writer->endElement();
        }
        if ($this->currentNightsCost) {
            $writer->startElementNs(null, 'currentNightsCost', null);
            $writer->text($this->currentNightsCost);
            $writer->endElement();
        }
        if ($this->currentOverWorkCost) {
            $writer->startElementNs(null, 'currentOverWorkCost', null);
            $writer->text($this->currentOverWorkCost);
            $writer->endElement();
        }
        if ($this->currentOverWorkTime) {
            $writer->startElementNs(null, 'currentOverWorkTime', null);
            $writer->text($this->currentOverWorkTime);
            $writer->endElement();
        }
        if ($this->currentPickUpQuantity) {
            $writer->startElementNs(null, 'currentPickUpQuantity', null);
            $writer->text($this->currentPickUpQuantity);
            $writer->endElement();
        }
        if ($this->currentRestTime) {
            $writer->startElementNs(null, 'currentRestTime', null);
            $writer->text($this->currentRestTime);
            $writer->endElement();
        }
        if ($this->currentUnplannedVisits) {
            $writer->startElementNs(null, 'currentUnplannedVisits', null);
            $writer->text($this->currentUnplannedVisits);
            $writer->endElement();
        }
        if ($this->currentWaitTime) {
            $writer->startElementNs(null, 'currentWaitTime', null);
            $writer->text($this->currentWaitTime);
            $writer->endElement();
        }
        if ($this->currentWorkCost) {
            $writer->startElementNs(null, 'currentWorkCost', null);
            $writer->text($this->currentWorkCost);
            $writer->endElement();
        }
        if ($this->currentWorkTime) {
            $writer->startElementNs(null, 'currentWorkTime', null);
            $writer->text($this->currentWorkTime);
            $writer->endElement();
        }
        if ($this->initialCo2) {
            $writer->startElementNs(null, 'initialCo2', null);
            $writer->text($this->initialCo2);
            $writer->endElement();
        }
        if ($this->initialCost) {
            $writer->startElementNs(null, 'initialCost', null);
            $writer->text($this->initialCost);
            $writer->endElement();
        }
        if ($this->initialCourierCost) {
            $writer->startElementNs(null, 'initialCourierCost', null);
            $writer->text($this->initialCourierCost);
            $writer->endElement();
        }
        if ($this->initialDeliveredQuantity) {
            $writer->startElementNs(null, 'initialDeliveredQuantity', null);
            $writer->text($this->initialDeliveredQuantity);
            $writer->endElement();
        }
        if ($this->initialDeliveryCost) {
            $writer->startElementNs(null, 'initialDeliveryCost', null);
            $writer->text($this->initialDeliveryCost);
            $writer->endElement();
        }
        if ($this->initialDriveCost) {
            $writer->startElementNs(null, 'initialDriveCost', null);
            $writer->text($this->initialDriveCost);
            $writer->endElement();
        }
        if ($this->initialDriveDistance) {
            $writer->startElementNs(null, 'initialDriveDistance', null);
            $writer->text($this->initialDriveDistance);
            $writer->endElement();
        }
        if ($this->initialDriveTime) {
            $writer->startElementNs(null, 'initialDriveTime', null);
            $writer->text($this->initialDriveTime);
            $writer->endElement();
        }
        if ($this->initialFixedCost) {
            $writer->startElementNs(null, 'initialFixedCost', null);
            $writer->text($this->initialFixedCost);
            $writer->endElement();
        }
        if ($this->initialLateTime) {
            $writer->startElementNs(null, 'initialLateTime', null);
            $writer->text($this->initialLateTime);
            $writer->endElement();
        }
        if ($this->initialNightsCost) {
            $writer->startElementNs(null, 'initialNightsCost', null);
            $writer->text($this->initialNightsCost);
            $writer->endElement();
        }
        if ($this->initialOverWorkCost) {
            $writer->startElementNs(null, 'initialOverWorkCost', null);
            $writer->text($this->initialOverWorkCost);
            $writer->endElement();
        }
        if ($this->initialOverWorkTime) {
            $writer->startElementNs(null, 'initialOverWorkTime', null);
            $writer->text($this->initialOverWorkTime);
            $writer->endElement();
        }
        if ($this->initialPickUpQuantity) {
            $writer->startElementNs(null, 'initialPickUpQuantity', null);
            $writer->text($this->initialPickUpQuantity);
            $writer->endElement();
        }
        if ($this->initialRestTime) {
            $writer->startElementNs(null, 'initialRestTime', null);
            $writer->text($this->initialRestTime);
            $writer->endElement();
        }
        if ($this->initialUnplannedVisits) {
            $writer->startElementNs(null, 'initialUnplannedVisits', null);
            $writer->text($this->initialUnplannedVisits);
            $writer->endElement();
        }
        if ($this->initialWaitTime) {
            $writer->startElementNs(null, 'initialWaitTime', null);
            $writer->text($this->initialWaitTime);
            $writer->endElement();
        }
        if ($this->initialWorkCost) {
            $writer->startElementNs(null, 'initialWorkCost', null);
            $writer->text($this->initialWorkCost);
            $writer->endElement();
        }
        if ($this->initialWorkTime) {
            $writer->startElementNs(null, 'initialWorkTime', null);
            $writer->text($this->initialWorkTime);
            $writer->endElement();
        }
        if ($this->mileageChartRemainingTime) {
            $writer->startElementNs(null, 'mileageChartRemainingTime', null);
            $writer->text($this->mileageChartRemainingTime);
            $writer->endElement();
        }
        if ($this->initialOpenTourNumber) {
            $writer->startElementNs(null, 'initialOpenTourNumber', null);
            $writer->text($this->initialOpenTourNumber);
            $writer->endElement();
        }
        if ($this->currentOpenTourNumber) {
            $writer->startElementNs(null, 'currentOpenTourNumber', null);
            $writer->text($this->currentOpenTourNumber);
            $writer->endElement();
        }
        if ($this->subOptimNb) {
            $writer->startElementNs(null, 'subOptimNb', null);
            $writer->text($this->subOptimNb);
            $writer->endElement();
        }
        if ($this->subOptimWaitingNb) {
            $writer->startElementNs(null, 'subOptimWaitingNb', null);
            $writer->text($this->subOptimWaitingNb);
            $writer->endElement();
        }
        if ($this->subOptimRunningNb) {
            $writer->startElementNs(null, 'subOptimRunningNb', null);
            $writer->text($this->subOptimRunningNb);
            $writer->endElement();
        }
        if ($this->subOptimFinishedNb) {
            $writer->startElementNs(null, 'subOptimFinishedNb', null);
            $writer->text($this->subOptimFinishedNb);
            $writer->endElement();
        }
        if ($this->subOptimErrorNb) {
            $writer->startElementNs(null, 'subOptimErrorNb', null);
            $writer->text($this->subOptimErrorNb);
            $writer->endElement();
        }
        if ($this->subOptimAbortedNb) {
            $writer->startElementNs(null, 'subOptimAbortedNb', null);
            $writer->text($this->subOptimAbortedNb);
            $writer->endElement();
        }
        if ($this->simulationId) {
            $writer->startElementNs(null, 'simulationId', null);
            $writer->text($this->simulationId);
            $writer->endElement();
        }
        if ($this->currentVisitsNb) {
            $writer->startElementNs(null, 'currentVisitsNb', null);
            $writer->text($this->currentVisitsNb);
            $writer->endElement();
        }
        if ($this->initialPlannedVisits) {
            $writer->startElementNs(null, 'initialPlannedVisits', null);
            $writer->text($this->initialPlannedVisits);
            $writer->endElement();
        }
        if ($this->currentPlannedVisits) {
            $writer->startElementNs(null, 'currentPlannedVisits', null);
            $writer->text($this->currentPlannedVisits);
            $writer->endElement();
        }
        if ($this->positionInQueue) {
            $writer->startElementNs(null, 'positionInQueue', null);
            $writer->text($this->positionInQueue);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class OptimStopResult extends \Com\Geoconcept\Toursolver\Webservices\ToursolverServiceResult
{

    /**
     * 
     *
     * @var integer
     */
    private $firstStopAsked;

    /**
     * Constructs a OptimStopResult from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * 
     *
     * @return integer
     */
    public function getFirstStopAsked()
    {
        return $this->firstStopAsked;
    }

    /**
     * 
     *
     * @param integer $firstStopAsked
     */
    public function setFirstStopAsked($firstStopAsked)
    {
        $this->firstStopAsked = $firstStopAsked;
    }

    /**
     * Sets a known child element of OptimStopResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'firstStopAsked') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->firstStopAsked = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of OptimStopResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes this OptimStopResult to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'optimStopResult', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this OptimStopResult to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->firstStopAsked) {
            $writer->startElementNs(null, 'firstStopAsked', null);
            $writer->text($this->firstStopAsked);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class OptimizeResult extends \Com\Geoconcept\Toursolver\Webservices\ToursolverServiceResult
{

    /**
     * the id of the optimization task that was launched
     *
     * @var string
     */
    private $taskId;

    /**
     * Constructs a OptimizeResult from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * the id of the optimization task that was launched
     *
     * @return string
     */
    public function getTaskId()
    {
        return $this->taskId;
    }

    /**
     * the id of the optimization task that was launched
     *
     * @param string $taskId
     */
    public function setTaskId($taskId)
    {
        $this->taskId = $taskId;
    }

    /**
     * Sets a known child element of OptimizeResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'taskId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->taskId = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of OptimizeResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes this OptimizeResult to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'optimizeResult', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this OptimizeResult to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->taskId) {
            $writer->startElementNs(null, 'taskId', null);
            $writer->text($this->taskId);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class ReadClientResult extends \Com\Geoconcept\Toursolver\Webservices\ToursolverServiceResult
{

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Mycustomers\Api\Model\ClientEntity
     */
    private $client;

    /**
     * Constructs a ReadClientResult from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Mycustomers\Api\Model\ClientEntity
     */
    public function getClient()
    {
        return $this->client;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Mycustomers\Api\Model\ClientEntity $client
     */
    public function setClient($client)
    {
        $this->client = $client;
    }

    /**
     * Sets a known child element of ReadClientResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'client') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Mycustomers\Api\Model\ClientEntity($xml);
            $this->client = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of ReadClientResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes this ReadClientResult to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'readClientResult', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this ReadClientResult to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->client) {
            $writer->startElementNs(null, 'client', null);
            $this->client->writeXmlContents($writer);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class ResourcesResult extends \Com\Geoconcept\Toursolver\Webservices\ToursolverServiceResult
{

    /**
     * List of resources
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSResource[]
     */
    private $resources;

    /**
     * Constructs a ResourcesResult from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * List of resources
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSResource[]
     */
    public function getResources()
    {
        return $this->resources;
    }

    /**
     * List of resources
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSResource[] $resources
     */
    public function setResources($resources)
    {
        $this->resources = $resources;
    }

    /**
     * Sets a known child element of ResourcesResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'resources') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSResource($xml);
            if (!isset($this->resources)) {
                $this->resources = array();
            }
            array_push($this->resources, $child);
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of ResourcesResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes this ResourcesResult to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'resourcesResult', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this ResourcesResult to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->resources) {
            foreach ($this->resources as $i => $x) {
                $writer->startElementNs(null, 'resources', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
    }
}

namespace Com\Geoconcept\Toursolver\Mobile;

/**
 * (no documentation provided)
 */
class DataItemHandling
{

    /**
     * 
     */
    const WRITABLE = "writable";

    /**
     * 
     */
    const READONLY = "readonly";

    /**
     * 
     */
    const MANDATORY = "mandatory";

    /**
     * 
     */
    const UNVISIBLE = "unvisible";
}

namespace Com\Geoconcept\Toursolver\Mobile;

/**
 * (no documentation provided)
 */
class DetailSetType
{

    /**
     * 
     */
    const FILLER = "filler";

    /**
     * 
     */
    const QUANTITY = "quantity";

    /**
     * 
     */
    const DATE = "date";

    /**
     * 
     */
    const LOGICAL = "logical";

    /**
     * 
     */
    const URL = "url";
}

namespace Com\Geoconcept\Toursolver\Mobile;

/**
 * (no documentation provided)
 */
class DisplayMode
{

    /**
     * 
     */
    const NONE = "none";

    /**
     * 
     */
    const TABLE = "table";

    /**
     * 
     */
    const FORM = "form";

    /**
     * 
     */
    const ALL = "all";

    /**
     * 
     */
    const APPLICATION = "application";
}

namespace Com\Geoconcept\Toursolver\Mobile;

/**
 * (no documentation provided)
 */
class TaskTypeDataItem extends \Com\Geoconcept\Toursolver\Mobile\TaskType
{

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Mobile\DataItem[]
     */
    private $dataItems;

    /**
     * Constructs a TaskTypeDataItem from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Mobile\DataItem[]
     */
    public function getDataItems()
    {
        return $this->dataItems;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Mobile\DataItem[] $dataItems
     */
    public function setDataItems($dataItems)
    {
        $this->dataItems = $dataItems;
    }

    /**
     * Sets a known child element of TaskTypeDataItem from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'DataItems') && ($xml->namespaceURI == 'http://geoconcept.com/gc/schemas/otmobile')) {
            $child = new \Com\Geoconcept\Toursolver\Mobile\DataItem($xml);
            if (!isset($this->dataItems)) {
                $this->dataItems = array();
            }
            array_push($this->dataItems, $child);
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of TaskTypeDataItem from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes the contents of this TaskTypeDataItem to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->dataItems) {
            foreach ($this->dataItems as $i => $x) {
                $writer->startElementNs('ns1', 'DataItems', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
    }
}

namespace Com\Geoconcept\Toursolver\Mobile;

/**
 * (no documentation provided)
 */
class GPSStatus
{

    /**
     * 
     */
    const NO_SIGNAL = "0";

    /**
     * 
     */
    const ONLINE = "1";

    /**
     * 
     */
    const OFFLINE = "2";
}

namespace Com\Geoconcept\Toursolver\Mobile;

/**
 * (no documentation provided)
 */
class DataItemType
{

    /**
     * 
     */
    const STRING = "string";

    /**
     * 
     */
    const MULTILINE = "multiLine";

    /**
     * 
     */
    const NUMBER = "number";

    /**
     * 
     */
    const DATE = "date";

    /**
     * 
     */
    const CHECKBOX = "checkBox";

    /**
     * 
     */
    const URL = "url";
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class Status
{

    /**
     * result is ok
     */
    const OK = "OK";

    /**
     * there was an error
     */
    const ERROR = "ERROR";
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class UpdateClientsResult extends \Com\Geoconcept\Toursolver\Webservices\ToursolverServiceResult
{

    /**
     * Constructs a UpdateClientsResult from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }


    /**
     * Sets a known child element of UpdateClientsResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        return false;
    }

    /**
     * Sets a known attribute of UpdateClientsResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes this UpdateClientsResult to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'updateClientsResult', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this UpdateClientsResult to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class SimulationResult extends \Com\Geoconcept\Toursolver\Webservices\ToursolverServiceResult
{

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSSimulation
     */
    private $simulation;

    /**
     * Constructs a SimulationResult from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSSimulation
     */
    public function getSimulation()
    {
        return $this->simulation;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSSimulation $simulation
     */
    public function setSimulation($simulation)
    {
        $this->simulation = $simulation;
    }

    /**
     * Sets a known child element of SimulationResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'simulation') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSSimulation($xml);
            $this->simulation = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of SimulationResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes this SimulationResult to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'simulationResult', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this SimulationResult to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->simulation) {
            $writer->startElementNs(null, 'simulation', null);
            $this->simulation->writeXmlContents($writer);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class OptimToursResult extends \Com\Geoconcept\Toursolver\Webservices\ToursolverServiceResult
{

    /**
     * the id of the optimization task (usefull if result is automatically sent through a webhook).
     *
     * @var string
     */
    private $taskId;

    /**
     * List of tours (one tour per resource per day)
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTour[]
     */
    private $tours;

    /**
     * the list of warning messages (and associated error codes) about possible
     * Orders and Resources elements constraints misconfiguration.
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSWarning[]
     */
    private $warnings;

    /**
     * the orders which has not been planned because: &lt;li&gt;it was sent by an
     * other mail service &lt;li&gt;it was not scheduled by any resource.
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSUnplanned[]
     */
    private $unplannedOrders;

    /**
     * Constructs a OptimToursResult from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * the id of the optimization task (usefull if result is automatically sent through a webhook).
     *
     * @return string
     */
    public function getTaskId()
    {
        return $this->taskId;
    }

    /**
     * the id of the optimization task (usefull if result is automatically sent through a webhook).
     *
     * @param string $taskId
     */
    public function setTaskId($taskId)
    {
        $this->taskId = $taskId;
    }
    /**
     * List of tours (one tour per resource per day)
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTour[]
     */
    public function getTours()
    {
        return $this->tours;
    }

    /**
     * List of tours (one tour per resource per day)
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTour[] $tours
     */
    public function setTours($tours)
    {
        $this->tours = $tours;
    }
    /**
     * the list of warning messages (and associated error codes) about possible
       * Orders and Resources elements constraints misconfiguration.
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSWarning[]
     */
    public function getWarnings()
    {
        return $this->warnings;
    }

    /**
     * the list of warning messages (and associated error codes) about possible
       * Orders and Resources elements constraints misconfiguration.
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSWarning[] $warnings
     */
    public function setWarnings($warnings)
    {
        $this->warnings = $warnings;
    }
    /**
     * the orders which has not been planned because: &lt;li&gt;it was sent by an
       * other mail service &lt;li&gt;it was not scheduled by any resource.
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSUnplanned[]
     */
    public function getUnplannedOrders()
    {
        return $this->unplannedOrders;
    }

    /**
     * the orders which has not been planned because: &lt;li&gt;it was sent by an
       * other mail service &lt;li&gt;it was not scheduled by any resource.
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSUnplanned[] $unplannedOrders
     */
    public function setUnplannedOrders($unplannedOrders)
    {
        $this->unplannedOrders = $unplannedOrders;
    }

    /**
     * Sets a known child element of OptimToursResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'taskId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->taskId = $child;
            $happened = true;
        }
        else if (($xml->localName == 'tours') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTour($xml);
            if (!isset($this->tours)) {
                $this->tours = array();
            }
            array_push($this->tours, $child);
            $happened = true;
        }
        else if (($xml->localName == 'warnings') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSWarning($xml);
            if (!isset($this->warnings)) {
                $this->warnings = array();
            }
            array_push($this->warnings, $child);
            $happened = true;
        }
        else if (($xml->localName == 'unplannedOrders') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSUnplanned($xml);
            if (!isset($this->unplannedOrders)) {
                $this->unplannedOrders = array();
            }
            array_push($this->unplannedOrders, $child);
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of OptimToursResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes this OptimToursResult to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'optimToursResult', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this OptimToursResult to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->taskId) {
            $writer->startElementNs(null, 'taskId', null);
            $writer->text($this->taskId);
            $writer->endElement();
        }
        if ($this->tours) {
            foreach ($this->tours as $i => $x) {
                $writer->startElementNs(null, 'tours', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->warnings) {
            foreach ($this->warnings as $i => $x) {
                $writer->startElementNs(null, 'warnings', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->unplannedOrders) {
            foreach ($this->unplannedOrders as $i => $x) {
                $writer->startElementNs(null, 'unplannedOrders', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class OptimResultResult extends \Com\Geoconcept\Toursolver\Webservices\ToursolverServiceResult
{

    /**
     * the id of the optimization task (usefull if result is automatically sent through a webhook).
     *
     * @var string
     */
    private $taskId;

    /**
     * the planned stops
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSPlanned[]
     */
    private $plannedOrders;

    /**
     * the orders which has not been planned because: &lt;li&gt;it was sent by an
     * other mail service &lt;li&gt;it was not scheduled by any resource.
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSUnplanned[]
     */
    private $unplannedOrders;

    /**
     * the list of warning messages (and associated error codes) about possible
     * Orders and Resources elements constraints misconfiguration.
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSWarning[]
     */
    private $warnings;

    /**
     * Id of the simulation associated to this task
     *
     * @var string
     */
    private $simulationId;

    /**
     * Constructs a OptimResultResult from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * the id of the optimization task (usefull if result is automatically sent through a webhook).
     *
     * @return string
     */
    public function getTaskId()
    {
        return $this->taskId;
    }

    /**
     * the id of the optimization task (usefull if result is automatically sent through a webhook).
     *
     * @param string $taskId
     */
    public function setTaskId($taskId)
    {
        $this->taskId = $taskId;
    }
    /**
     * the planned stops
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSPlanned[]
     */
    public function getPlannedOrders()
    {
        return $this->plannedOrders;
    }

    /**
     * the planned stops
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSPlanned[] $plannedOrders
     */
    public function setPlannedOrders($plannedOrders)
    {
        $this->plannedOrders = $plannedOrders;
    }
    /**
     * the orders which has not been planned because: &lt;li&gt;it was sent by an
       * other mail service &lt;li&gt;it was not scheduled by any resource.
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSUnplanned[]
     */
    public function getUnplannedOrders()
    {
        return $this->unplannedOrders;
    }

    /**
     * the orders which has not been planned because: &lt;li&gt;it was sent by an
       * other mail service &lt;li&gt;it was not scheduled by any resource.
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSUnplanned[] $unplannedOrders
     */
    public function setUnplannedOrders($unplannedOrders)
    {
        $this->unplannedOrders = $unplannedOrders;
    }
    /**
     * the list of warning messages (and associated error codes) about possible
       * Orders and Resources elements constraints misconfiguration.
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSWarning[]
     */
    public function getWarnings()
    {
        return $this->warnings;
    }

    /**
     * the list of warning messages (and associated error codes) about possible
       * Orders and Resources elements constraints misconfiguration.
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSWarning[] $warnings
     */
    public function setWarnings($warnings)
    {
        $this->warnings = $warnings;
    }
    /**
     * Id of the simulation associated to this task
     *
     * @return string
     */
    public function getSimulationId()
    {
        return $this->simulationId;
    }

    /**
     * Id of the simulation associated to this task
     *
     * @param string $simulationId
     */
    public function setSimulationId($simulationId)
    {
        $this->simulationId = $simulationId;
    }

    /**
     * Sets a known child element of OptimResultResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'taskId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->taskId = $child;
            $happened = true;
        }
        else if (($xml->localName == 'plannedOrders') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSPlanned($xml);
            if (!isset($this->plannedOrders)) {
                $this->plannedOrders = array();
            }
            array_push($this->plannedOrders, $child);
            $happened = true;
        }
        else if (($xml->localName == 'unplannedOrders') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSUnplanned($xml);
            if (!isset($this->unplannedOrders)) {
                $this->unplannedOrders = array();
            }
            array_push($this->unplannedOrders, $child);
            $happened = true;
        }
        else if (($xml->localName == 'warnings') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSWarning($xml);
            if (!isset($this->warnings)) {
                $this->warnings = array();
            }
            array_push($this->warnings, $child);
            $happened = true;
        }
        else if (($xml->localName == 'simulationId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->simulationId = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of OptimResultResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes this OptimResultResult to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'optimResultResult', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this OptimResultResult to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->taskId) {
            $writer->startElementNs(null, 'taskId', null);
            $writer->text($this->taskId);
            $writer->endElement();
        }
        if ($this->plannedOrders) {
            foreach ($this->plannedOrders as $i => $x) {
                $writer->startElementNs(null, 'plannedOrders', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->unplannedOrders) {
            foreach ($this->unplannedOrders as $i => $x) {
                $writer->startElementNs(null, 'unplannedOrders', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->warnings) {
            foreach ($this->warnings as $i => $x) {
                $writer->startElementNs(null, 'warnings', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->simulationId) {
            $writer->startElementNs(null, 'simulationId', null);
            $writer->text($this->simulationId);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class FulfillmentResult extends \Com\Geoconcept\Toursolver\Webservices\ToursolverServiceResult
{

    /**
     * List of orders
     *
     * @var \Com\Geoconcept\Toursolver\Export\OperationalOrder[]
     */
    private $operationalOrderAchievements;

    /**
     * List of positions
     *
     * @var \Com\Geoconcept\Toursolver\Export\OperationalLastKnownPosition[]
     */
    private $lastKnownPosition;

    /**
     * Constructs a FulfillmentResult from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * List of orders
     *
     * @return \Com\Geoconcept\Toursolver\Export\OperationalOrder[]
     */
    public function getOperationalOrderAchievements()
    {
        return $this->operationalOrderAchievements;
    }

    /**
     * List of orders
     *
     * @param \Com\Geoconcept\Toursolver\Export\OperationalOrder[] $operationalOrderAchievements
     */
    public function setOperationalOrderAchievements($operationalOrderAchievements)
    {
        $this->operationalOrderAchievements = $operationalOrderAchievements;
    }
    /**
     * List of positions
     *
     * @return \Com\Geoconcept\Toursolver\Export\OperationalLastKnownPosition[]
     */
    public function getLastKnownPosition()
    {
        return $this->lastKnownPosition;
    }

    /**
     * List of positions
     *
     * @param \Com\Geoconcept\Toursolver\Export\OperationalLastKnownPosition[] $lastKnownPosition
     */
    public function setLastKnownPosition($lastKnownPosition)
    {
        $this->lastKnownPosition = $lastKnownPosition;
    }

    /**
     * Sets a known child element of FulfillmentResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'operationalOrderAchievements') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Export\OperationalOrder($xml);
            if (!isset($this->operationalOrderAchievements)) {
                $this->operationalOrderAchievements = array();
            }
            array_push($this->operationalOrderAchievements, $child);
            $happened = true;
        }
        else if (($xml->localName == 'lastKnownPosition') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Export\OperationalLastKnownPosition($xml);
            if (!isset($this->lastKnownPosition)) {
                $this->lastKnownPosition = array();
            }
            array_push($this->lastKnownPosition, $child);
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of FulfillmentResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes this FulfillmentResult to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'fulfillmentResult', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this FulfillmentResult to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->operationalOrderAchievements) {
            foreach ($this->operationalOrderAchievements as $i => $x) {
                $writer->startElementNs(null, 'operationalOrderAchievements', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->lastKnownPosition) {
            foreach ($this->lastKnownPosition as $i => $x) {
                $writer->startElementNs(null, 'lastKnownPosition', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class DeleteClientsResult extends \Com\Geoconcept\Toursolver\Webservices\ToursolverServiceResult
{

    /**
     * Constructs a DeleteClientsResult from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }


    /**
     * Sets a known child element of DeleteClientsResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        return false;
    }

    /**
     * Sets a known attribute of DeleteClientsResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes this DeleteClientsResult to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'deleteClientsResult', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this DeleteClientsResult to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class AddClientsResult extends \Com\Geoconcept\Toursolver\Webservices\ToursolverServiceResult
{

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Mycustomers\Api\Model\ClientEntity[]
     */
    private $clients;

    /**
     * Constructs a AddClientsResult from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Mycustomers\Api\Model\ClientEntity[]
     */
    public function getClients()
    {
        return $this->clients;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Mycustomers\Api\Model\ClientEntity[] $clients
     */
    public function setClients($clients)
    {
        $this->clients = $clients;
    }

    /**
     * Sets a known child element of AddClientsResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'clients') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Mycustomers\Api\Model\ClientEntity($xml);
            if (!isset($this->clients)) {
                $this->clients = array();
            }
            array_push($this->clients, $child);
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of AddClientsResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes this AddClientsResult to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'addClientsResult', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this AddClientsResult to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->clients) {
            foreach ($this->clients as $i => $x) {
                $writer->startElementNs(null, 'clients', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
    }
}

namespace Com\Geoconcept\Toursolver\Webservices;

/**
 * (no documentation provided)
 */
class AddOperationalOrdersResult extends \Com\Geoconcept\Toursolver\Webservices\ToursolverServiceResult
{

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Export\OperationalOrder[]
     */
    private $orders;

    /**
     * Constructs a AddOperationalOrdersResult from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Export\OperationalOrder[]
     */
    public function getOrders()
    {
        return $this->orders;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Export\OperationalOrder[] $orders
     */
    public function setOrders($orders)
    {
        $this->orders = $orders;
    }

    /**
     * Sets a known child element of AddOperationalOrdersResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'orders') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Export\OperationalOrder($xml);
            if (!isset($this->orders)) {
                $this->orders = array();
            }
            array_push($this->orders, $child);
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of AddOperationalOrdersResult from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes this AddOperationalOrdersResult to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'addOperationalOrdersResult', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this AddOperationalOrdersResult to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->orders) {
            foreach ($this->orders as $i => $x) {
                $writer->startElementNs(null, 'orders', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
    }
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Optim;

/**
 * (no documentation provided)
 */
class WebhookExportMode
{

    /**
     * 
     */
    const NONE = "NONE";

    /**
     * 
     */
    const ORDERS = "ORDERS";

    /**
     * 
     */
    const TOURS = "TOURS";
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Optim;

/**
 * (no documentation provided)
 */
class TSResource extends \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSObject
{

    /**
     * Indicates whether a resource is included in the planning process or not.
     * 
     * This constraint enables you to easily modify your optimization problem
     * configuration without having to add nor delete original data.
     * 
     * * Set it to True to include a resource element in the planning process.
     * 
     * * Set it to False to ignore it: it will not be used in the planning.
     * 
     * **Type : ** Boolean. **Default : ** not used.
     *
     * @var boolean
     */
    private $available;

    /**
     * Average consumption of the resource. Use this constraint to specify the
     * average consumption of the resource. This consumption must be defined in
     * liters per 100 distance unit (km or miles)
     * 
     * **Default : ** The consumption indicated in the
     * VehicleProfile.Consumption property.
     *
     * @var double
     */
    private $avgConsumption;

    /**
     * An additional duration applied before the tour starts. Use this
     * constraint to specify an additional duration before the resource begins
     * the tour. For instance, to brief drivers before they leave or to simulate
     * an initial vehicle loading time (no depot).
     * 
     * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** &quot;00:00:00&quot;.
     *
     * @var string
     */
    private $briefingDuration;

    /**
     * The total product capacity a resource can carry. Use this constraint to
     * specify the amount of product a resource can deliver or pick-up. It must
     * be linked with the customers related quantity constraint. 23 more
     * dimensions can be used in order to specify various products. They must be
     * linked with the customers related dimensions.
     * 
     * **Type : ** float (maximum of 3 significant digits after decimal
     * separator). **Default: ** None. **Max : ** 2,147,483.
     * 
     * **Example :**
     * 
     * * Use it to store the total number of packages a resource can deliver
     * before reloading, when working with packages.
     * 
     * * Use it to store the total number of litres a resource can deliver
     * before reloading, when working with liquids.
     * 
     * * Use multiple capacity dimensions when working with multiple products:
     * when delivering fuels, you will use as many capacities as types of fuels.
     *
     * @var double[]
     */
    private $capacities;

    /**
     * The list of characteristics provided by a resource.
     * 
     * This constraint is linked with the same order constraint: a customer with
     * a required skill can only be delivered by a resource providing it.
     * 
     * Caution : use only alphanumeric characters (and _) in your characteristics values, otherwise the skill will be ignored.
     * 
     * **Type : ** string as a list of characteristics separated with commas.
     * **Default: : ** not used.
     * 
     * **Example : **
     * 
     * * Specify &quot;Maintenance&quot; in the provided skills of a resource designed to
     * perform maintenance visits type.
     * 
     * * Specify &quot;Small vehicle&quot; to the provided skills of a resource able to
     * perform downtown visits.
     *
     * @var string
     */
    private $providedSkills;

    /**
     * Private custom data.
     * 
     * Use this feature when you need to keep attributes values of your own into
     * the optimization context. For instance if you need the address of an
     * element, store it there.
     *
     * @var array
     */
    private $customDataMap;

    /**
     * The maximum resource work duration over a day. Use this constraint to
     * specify the maximum daily work duration (unless overtime periods have
     * been defined). If the dailyWorkTime constraint is not set to a value,
     * default daily work time is computed from resource time window and lunch
     * duration (workStartTime, workEndTime and lunchDuration).
     * 
     * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** not used.
     *
     * @var string
     */
    private $dailyWorkTime;

    /**
     * An additional duration applied at the end of the tour. Use this
     * constraint to specify an additional duration after the resources stops at
     * the end location. For instance, to debrief drivers after their tour or to
     * account an ultimate vehicle unloading time, or a parking time.
     * 
     * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** &quot;00:00:00&quot;.
     *
     * @var string
     */
    private $debriefingDuration;

    /**
     * Indicates whether or not time spent at customer during deliveries can be
     * considered as rest break.
     * 
     * * Set it to True if a visit can be considered as a rest break, as soon as
     * its duration is equal or higher than the legalMinRestDuration constraint.
     * 
     * * Set it to False if not.
     * 
     * **Type : ** Boolean. **Default : ** False.
     *
     * @var boolean
     */
    private $driveRestAtCustomer;

    /**
     * Indicates whether time spent at depot during a reload break can be
     * considered as drive break or not.
     * 
     * Use this constraint to take into account drive time legislation in your
     * planning results.
     * 
     * * Set it to True if load breaks can be considered as drive breaks, as
     * soon as their duration is equal or higher than the legalMinRestDuration
     * constraint.
     * 
     * * Set it to False if not.
     * 
     * **Type : ** Boolean. **Default : ** False.
     *
     * @var boolean
     */
    private $driveRestAtDepot;

    /**
     * The fixed duration of the resource load break. Use this constraint to
     * specify how long takes a resource reload at depot. You can specify an
     * additional duration according to the quantity to reload, using
     * loadingDurationPerUnit.
     * 
     * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** &quot;00:00:00&quot;.
     * 
     * **Example : **
     * 
     * * fixedVisitDuration = &quot;00:30:00&quot; indicates that 30 minutes are needed to
     * load the resource.
     * 
     * * loadingDurationPerUnit = 120 indicates that 120 sec are needed to load
     * one unit. If the quantity to reload is 8, for instance, the variable part
     * is 120*8. 16 minutes are required to load the resource.
     * 
     * * Total load time = 30 minutes + 16 minutes = 46 minutes accounted for
     * this reload break.
     *
     * @var string
     */
    private $fixedLoadingDuration;

    /**
     * The fuel type of the resource.
     * 
     * Use this constraint to specify the fuel type of the resource. Available
     * fuel types are :
     * 
     * * 0: Unknown fuel type
     * 
     * * 1: No fuel type (pedestrian)
     * 
     * * 2: Diesel
     * 
     * * 3: Unleaded fuel
     * 
     * * 4: LPG
     * 
     * **Type : ** Integer. **Default :** The fuel type indicated in the
     * VehicleProfile.FuelType property.
     *
     * @var integer
     */
    private $fuelType;

    /**
     * The unique identifier of the resource.
     * 
     * This id can not contain special characters like &#39;=&#39; or &#39;:&#39;
     *
     * @var string
     */
    private $id;

    /**
     * The legal daily duration a resource can drive before having a rest break.
     * 
     * Use this constraint to take into account drive time legislation in your
     * planning results. Specify the rest duration in the
     * legalDailyRestDuration: rest breaks occur as soon as the resource has
     * driven the legal daily driving duration or has completed its daily work
     * time.
     * 
     * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** not used.
     * 
     * **Example : ** legalDailyDriveDuration = &quot;09:00:00&quot;,
     * legalDailyRestDuration = &quot;11:00:00&quot;. The resource can cumulate a 9-hours
     * daily drive time before having to rest during 11 hours.
     *
     * @var string
     */
    private $legalDailyDriveDuration;

    /**
     * The legal rest duration a resource must have after the daily max drive
     * duration.
     * 
     * Use this constraint to take into account drive time legislation in your
     * planning results. Rest breaks occur as soon as the resource has driven
     * the legal max daily duration or has complete its daily work time. The use
     * of both legalDailyDriveDuration and legalDailyRestDuration implies that
     * the start and end time of tours are no longer defined by the
     * workStartTime and workEndTime constraints, but may vary as long as the
     * legalDailyRestDuration constraint is respected.
     * 
     * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** not used.
     *
     * @var string
     */
    private $legalDailyRestDuration;

    /**
     * The resource break duration after max drive duration. Use this constraint
     * to take into account drive time legislation in your planning results.
     * 
     * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** not used.
     *
     * @var string
     */
    private $legalDriveRestDuration;

    /**
     * The legal max duration a resource can drive without a break. Use this
     * constraint to take into account drive time legislation in your planning
     * results.
     * 
     * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default: : ** not used.
     * 
     * **Example : **
     * 
     * * legalMaxDriveDuration = &quot;04:30:00&quot;, legalDriveRestDuration =
     * &quot;00:45:00&quot;. The resource can drive for 4 hours and 30 minutes before
     * having a 45 minutes break. Then it can start driving again for 4 hours
     * and 30 minutes...etc.
     * 
     * * If added driveRestAtCustomer = True and legalMinRestDuration =
     * &quot;00:15:00&quot;, rest time is cumulated as soon as customer visit duration is
     * equal or higher than the specified min rest duration. If the 45 minutes
     * rest break has not occured when the resource has driven for 4 hours and
     * 30 minutes, it must stop to complete the break. Otherwise, it can drive
     * again for 4 hours and 30 minutes.
     *
     * @var string
     */
    private $legalMaxDriveDuration;

    /**
     * The minimum duration a resource breaks for it to be considered as a drive
     * break. Use this constraint to take into account drive time legislation in
     * your planning results. When breaks occur at customer or at depot, they
     * are considered as drive breaks if their duration is equal or higher than
     * the specified min rest duration.
     * 
     * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default: : ** not used.
     *
     * @var string
     */
    private $legalMinRestDuration;

    /**
     * Indicates whether a resource must load before starting a tour or not.
     * 
     * * Set this constraint to True to insert a load break at depot before the
     * tour starts.
     * 
     * * Set it to False to consider the vehicle loaded.
     * 
     * **Type : ** Boolean. **Default: : ** False.
     *
     * @var boolean
     */
    private $loadBeforeDeparture;

    /**
     * The time needed to load a unit of product. This constraint is added to
     * the fixed part of the loading duration: it depends on the total quantity
     * to load.
     * 
     * **Type : ** &quot;hh:mm:ss&quot;, DateTime, Integer (number of seconds). **Default:
     * : ** 0.
     *
     * @var string
     */
    private $loadingDurationPerUnit;

    /**
     * Indicates whether a resource must reload after a tour or not.
     * 
     * * Set this constraint to True to insert a load break at depot after the
     * tour ends.
     * 
     * * Set it to False to not reload the vehicle.
     * 
     * **Type : ** Boolean. **Default: : ** False.
     *
     * @var boolean
     */
    private $loadOnReturn;

    /**
     * The lunch break
     * 
     * **Default: : ** no lunch break
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSPause
     */
    private $lunch;

    /**
     * The number of nights a resource can spend out to perform deliveries
     * before coming back to base.
     * 
     * Use this constraint to enable night breaks trip: it will store how many
     * days a resource can drive away from depot. Unless the vehicle needs to
     * reload, it will not come back before.
     * 
     * **Type : ** integer. **Default: : ** not used.
     * 
     * Example: maxNightsOutPerJourney = 4, workDays = 1=&gt;5. The resource can
     * perform deliveries during 5 days (and 4 nights) without coming back to
     * depot. Starting on day 1, it must come back to depot on day 5.
     *
     * @var integer
     */
    private $maxNightsOutPerJourney;

    /**
     * The number of nights a resource can spend out to perform deliveries
     * before coming back to base in a week.
     * 
     * **Type : ** integer. **Default: : ** not used.
     *
     * @var integer
     */
    private $maxNightsOutPerWeek;

    /**
     * The minimum laps of time between 2 consecutive visits.
     * 
     * Use this constraint to specify a minimum drive time accounted when
     * consecutive visits are very close, in order to compute a realistic
     * timing.
     * 
     * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default: : ** not used.
     *
     * @var string
     */
    private $minDriveDuration;

    /**
     * The night cost of a resource when planning night breaks.
     * 
     * Use this constrainte to specify how much a night out costs (lunch, bed,
     * breakfeast...) for a resource when night breaks are allowed.
     * 
     * **Type : ** float. **Default: : ** 0
     *
     * @var double
     */
    private $nightPenalty;

    /**
     * A cost paid for NOT using a resource in the computed planning.
     * 
     * Use this constraint to penalize the fact that an available resource is
     * not used in the planning. It proves usefull when you must use all the
     * resources in the Resources collection: you will prevent the solver from
     * optimizing the number of resources, as using them would be too expensive
     * a solution.
     * 
     * **Type : ** float. **Default: : ** not used.
     * 
     * **Example : ** Use it to specify parking taxes when a vehicle performs no
     * tour.
     *
     * @var double
     */
    private $nonUsePenalty;

    /**
     * Indicates whether or not a tour evaluation starts from the resource start
     * location or from the first customer&#39;s place.
     * 
     * * Set it to True to begin the tour at the first customer (no cost will be
     * computed between the resource start location and the first customer).
     * 
     * * Set it to False to begin the tour at the resource start location.
     * 
     * **Type : ** Boolean. **Default: : ** False.
     *
     * @var boolean
     */
    private $openStart;

    /**
     * Indicates whether or not a tour evaluation ends at the last customer&#39;s
     * place or at the resource end location.
     * 
     * * Set it to True to finish the tour at the last customer location (no
     * cost will be computed between the last customer and the resource end
     * location).
     * 
     * * Set it to False to finish the tour at the resource end location.
     * 
     * **Type : ** Boolean. **Default: : ** False.
     *
     * @var boolean
     */
    private $openStop;

    /**
     * Adapts the resource start time to the best solution.
     * 
     * * Set this constraint to False to start the tour at the time indicated by
     * the workStartTime constraint.
     * 
     * * Set this constraint to True to optimize the resource start time and
     * enable the use of the dailyWorkTime constraint.
     * 
     * Notice that, in both cases, the tour will not start before the time
     * stored in the workStartTime constraint and that the use of the
     * weeklyWorkTime constraint is enabled.
     * 
     * **Type : ** Boolean. **Default: : ** False.
     *
     * @var boolean
     */
    private $optimumStartTime;

    /**
     * The max duration a resource can drive to go back to base at the end of a
     * tour when working with night breaks.
     * 
     * Use this constraint when a resource can end a tour at base instead of
     * having a night break on the road.
     * 
     * **Type : ** &quot;hh:mm:ss&quot;. **Default: : ** not used.
     *
     * @var string
     */
    private $overnightMinDriving;

    /**
     * The duration of the resource overwork periods. (max 2 periods)
     * 
     * Use this constraint when you need to define 2 different overwork periods
     * with regard to daily work time and their related surcharge. No overwork
     * period can be defined with regard to weekly work time.
     * 
     * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default: : ** not used (no second
     * overtime period).
     * 
     * **Example : **
     * 
     * workPenalty = 10, first overtime duration = &quot;02:00:00&quot;, first overtime
     * penalty = 5,second overtime duration = &quot;01:00:00&quot;, second overtime
     * penalty = 10.
     * 
     * The cost of the resource during the daily working time is 10 euros per
     * hour. The resource can work during 3 more hours and each overworked hour
     * will cost 10 + 5 euros for 2 hours and 10 + 10 euros for the last hour.
     *
     * @var string[]
     */
    private $overtimeDurations;

    /**
     * A surcharge for a resource&#39;s overwork period (max 2 periods).
     * 
     * Use this constraint to specify additional cost to workPenalty as overwork
     * time. You can define up to 2 overwork periods with regard to daily work
     * time and their related surcharge. No overwork period can be defined with
     * regard to weekly work time.
     * 
     * **Type : ** float. **Default: : ** not used.
     * 
     * **Example : **
     * 
     * workPenalty = 10, first overtime duration = &quot;02:00:00&quot;, first overtime
     * penalty = 5.
     * 
     * The cost of the resource during the daily working time is 10 euros per
     * hour. The resource can work during 2 hours after the daily working time
     * and each overworked hour will cost 15 (10 + 5) euros.
     *
     * @var double[]
     */
    private $overtimePenalties;

    /**
     * Indicates whether or not a whole work day cost is computed as soon as a
     * resource works even a few hours.
     * 
     * * Set this constraint to True to account a whole day cost.
     * 
     * * Set it to False to account only effective worked hours.
     * 
     * **Type : ** Boolean. **Default: : ** False.
     *
     * @var boolean
     */
    private $payWholeDay;

    /**
     * An additional fixed cost applied each time the resource performs a visit.
     * 
     * Use this constraint when the cost of a resource may vary according to the
     * number of visits it performs.
     * 
     * **Type : ** float. **Default: : ** 0.
     *
     * @var double
     */
    private $penaltyPerVisit;

    /**
     * A factor to increase or decrease the vehicle speed.
     * 
     * Whenever users observe a significant gap between estimated speeds and the
     * real ones, they can adjust them by using this factor. It is expressed as
     * a percentage of the used speed.
     * 
     * **Type : ** float. **Default: : ** not used.
     * 
     * **Example : **
     * 
     * * speedAdjustment = 110: resource speeds will be 10% higher than the used
     * speeds.
     * 
     * * speedAdjustment = 80: resource speeds will be 20% lower than the used
     * speeds.
     *
     * @var integer
     */
    private $speedAdjustment;

    /**
     * travel time modifier associated with the start location of the resource
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTravelTimeModifier
     */
    private $startTravelTimeModifier;

    /**
     * travel time modifier associated with the stop location of the resource
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTravelTimeModifier
     */
    private $stopTravelTimeModifier;

    /**
     * The costs for a resource of driving for one distance unit.
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTravelPenalty[]
     */
    private $extraTravelPenalties;

    /**
     * travel time modifiers
     * 
     * When reaching a location situated in a large city, one may want to take
     * into account driving difficulties, such as narrow streets and congestion.
     * The travel time modifier enables to increase the travel times around a
     * location. It is describes by three values. The value by which multiply
     * the travel times around the location travelTimeModifierValue), the
     * portion of the travel time on which the modifier applies
     * (travelTimeModifierLength) an offset to add to any travel duration
     * leaving or reaching the location (travelTimeModifierOffSet).
     * 
     * **Example : **
     * 
     * * Set travelTimeModifierValue to 1.5, travelTimeModifierLength to 300 and
     * travelTimeModifierOffSet to 60 for Resource 1
     * 
     * * Set travelTimeModifierValue to 2, travelTimeModifierLength to 420 and
     * travelTimeModifierOffSet to 0 for Order 1 If the initial travel duration
     * between Resource 1 and Order 1 was 1000, one obtains a travel time 360 *
     * 1.5 + 60 + 280 + 420 * 2 + 0 = 1660
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTravelTimeModifier
     */
    private $travelTimeModifier;

    /**
     * A cost paid for using the resource in the computed planning. Use this
     * constraint to ponderate the cost of using a resource element of the
     * Resources collection, when working with rented vehicle for instance. You
     * can use it as well to reduce the number of resources used to perform the
     * deliveries.
     * 
     * **Type : ** float. **Default: : ** not used.
     * 
     * **Example : **
     * 
     * Add the cost of use to the distance and hourly costs when working with a
     * service provider. The solver, aiming at cost reduction, will try to
     * eliminate this resource first, as it is the most expensive.
     *
     * @var double
     */
    private $usePenalty;

    /**
     * The maximum resource work duration over a week.
     * 
     * Use this constraint to specify the maximum weekly work duration. Weeks
     * are defined as follows:
     * 
     * * year&#39;s week, from monday to sunday, if a date has been specified in the
     * workDays constraint
     * 
     * * days 1 to 7 are the days of the first week and the second week start on
     * day 8 if no date has been specified in the workDays constraint. No over
     * work with regard to the weekly work duration is allowed.
     * 
     * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default: : ** &quot;168:00:00&quot;.
     *
     * @var string
     */
    private $weeklyWorkTime;

    /**
     * The end time of a resource work time window.
     * 
     * Use this constraint to specify the time at which the tour must be over or
     * the daily work duration.
     * 
     * * If the optimumStartTime parameter is set to True and the dailyWorkTime
     * or weeklyWorkTime constraint value is set by user, the tour cannot finish
     * later than the value of the workEndTime parameter, whatever overtime may
     * be allowed by the overtime1_Duration and overtime2_Duration constraints.
     * 
     * * If the optimumStartTime parameter is set to True and the dailyWorkTime
     * constraint value is not set, the end time of the tour can be adjusted to
     * match the begining of the work time window. In this case, this parameter
     * is used only to compute the resource daily work time and the tour can
     * finish at midnight.
     * 
     * * If the optimumStartTime parameter is set to False, then this parameter
     * is used to compute the resource daily work time and the tour can finish
     * no later than the specified end time plus the values of the first
     * overtime duration and the second overtime duration constraints. If the
     * daily work duration is specified by the workEndTime constraint&#39;s value,
     * then it is equal to workEndTime minus workStartTime and lunchDuration.
     * 
     * **Example : ** For a vehicle to work for 6 hours between 7PM and 7AM, set
     * 
     * * optimumStartTime=True
     * 
     * * dailyWorkTime=&quot;06:00:00&quot;
     * 
     * * workStartTime=&quot;07:00:00&quot;
     * 
     * * workEndTime=&quot;19:00:00&quot;
     * 
     * For a vehicle to work for 8 hour between 8PM and 5AM with a one-hour
     * break at 12:30, set
     * 
     * * workStartTime=&quot;08:00:00&quot;
     * 
     * * workEndTime=&quot;17:00:00&quot;
     * 
     * * lunchDuration=&quot;01:00:00&quot;
     * 
     * * lunchTime=&quot;12:30:00&quot;
     * 
     * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default: : ** &quot;24:00:00&quot;.
     *
     * @var string
     */
    private $workEndTime;

    /**
     * The resource&#39;s work days. Use this constraint to specify the days a
     * resource works in the planning period. This constraint is linked with the
     * orders possible visit days constraints of Orders object elements and with
     * the depot days of opening constraints of Depots object elements. Thus,
     * customers and resources must have matching days for deliveries to be
     * possible, and depots must be opened on resources working days to be used.
     * A maximum of 64 days can be defined as work days. Working days can be
     * written as integers (1,2...) or dates (14/05/2010, 15/05/2010, ...). If
     * you are using dates, the oldest date in the workDays constraint defines
     * day 1.
     * 
     * **Type : ** string values containing days separated with commas (like &quot;1,
     * 2, 5&quot; or &quot;14/05/2010, 15/05/2010, 18/05/2010&quot; to specify day 1, day 2 and
     * day 5) or intervals (like &quot;1-10&quot;, &quot;2=&gt;5&quot; or &quot;14/05/2010=&gt;24/05/2010&quot;)
     * where 1 (or 14/05/2010) is the first day of the planning period. For day
     * intervals, prefer the &quot;=&gt;&quot; separator. Be careful, if the separator of
     * date is - then &quot;1-5&quot; corresponds to May 1st of the current year. If you
     * mix integer and date formats, beware that day 1 will all the same be
     * defined by the oldest available date.
     * 
     * **Default: : ** &quot;1&quot;.
     * 
     * **Example : **
     * 
     * You can define a single working day: Specify &quot;1&quot;, &quot;3&quot; or &quot;10&quot; for the
     * resource to work on day 1, day 3 or day 10 of the planning period. You
     * can also define working periods. Specify &quot;1-5&quot; or &quot;1=&gt;5&quot; or
     * &quot;14/05/2010=&gt;18/05/2010&quot; for the resource to work on a 5-days period
     * (from day 1 to day 5 included).
     * 
     * You can also mix single day and periods. Specify &quot;1, 3=&gt;5&quot; for the
     * resource to work on day 1 and from day 3 to 5 of the planning period.
     *
     * @var string
     */
    private $workingDays;

    /**
     * The cost of a resource working for an hour.
     * 
     * Use this constraint to specify the resource wages when working for an
     * hour.
     * 
     * **Type : ** float. **Default: : ** 9.
     * 
     * **Example : **
     * 
     * If workPenalty = 10 (euros per hour) and daily work time is about 8
     * hours, the total daily work cost is 10 * 8 = 80 euros.
     *
     * @var double
     */
    private $workPenalty;

    /**
     * The start time of the resource work time window.
     * 
     * Use this constraint to specify the time at which the tour must start.
     * This time can be adjusted using the optimumStartTime parameter.
     * 
     * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default: : ** &quot;00:00:00&quot;.
     *
     * @var string
     */
    private $workStartTime;

    /**
     * longitude of resource start (and arrival if no endX provided)
     *
     * @var double
     */
    private $startX;

    /**
     * longitude of resource arrival
     * 
     * Specify it only if arrival and start are not the same.
     *
     * @var double
     */
    private $endX;

    /**
     * latitude of resource start (and arrival if no endY provided)
     *
     * @var double
     */
    private $startY;

    /**
     * latitude of resource arrival
     * 
     * Specify it only if arrival and start are not the same.
     *
     * @var double
     */
    private $endY;

    /**
     * The cost for a resource of driving for one distance unit.
     * 
     * Use this constraint to specify the average resource taxes (gazoline,
     * wear,...) when driving one distance unit.
     * 
     * **Type : ** float **Default : ** 1.5
     * 
     * **Example : ** if travelPenalty = 0.5 (euro per distance unit) and the
     * driven distance is about 100 unit (km or miles), the total distance cost
     * is 0,5 * 100 = 50 euros.
     *
     * @var double
     */
    private $travelPenalty;

    /**
     * Value for minimum quantity to deliver.
     * 
     * If the resource has a non null minimum quantity to deliver constraint
     * value, the resource can visit on order only if the quantity to be
     * picked-up or delivered at this order is higher than the constraint value.
     * 
     * *Example : *
     * 
     * * set order *quantity* to 3 and resource *minimumQuantity* to 2 :
     * resource might visit the order
     * 
     * * set order *quantity* to 3 and resource *minimumQuantity* to 5 :
     * resource can not visit the order
     * 
     * **Type : ** float
     *
     * @var double
     */
    private $minimumQuantity;

    /**
     * The fixed time needed for the resource to deliver/pick-up at the
     * customer&#39;s place.
     * 
     * This fixed resource&#39;s unloading duration is added to the resource&#39;s
     * unloading duration depending on the quantity to deliver/pick-up and to
     * the order&#39;s unloading duration depending on the quantity to
     * deliver/pick-up. See also tsResource unloadingDurationPerUnit and tsOrder
     * unloadingDurationPerUnit. **Example : **
     * 
     * * Set tsOrderQuantity to 3.
     * 
     * * Set tsOrder unloadingDurationPerUnit to 2 mn and tsResource
     * fixedUnloadingDuration and tsResource unloadingPerUnit to 0 or empty: the
     * variable part of the order is 6 mn
     * 
     * * Set tsOrder unloadingDurationPerUnit to 2 mn and tsResource
     * fixedUnloadingDuration to 10 mn and tsResource unloadingPerUnit to 0 or
     * empty: the variable part of the order is 10 mn
     * 
     * * Set tsOrder unloadingDurationPerUnit to 2 mn and tsResource
     * fixedUnloadingDuration empty and tsResource unloadingPerUnit to 1 mn: the
     * variable part of the order is 3 mn
     * 
     * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** &quot;&quot;
     * 
     * **Warning : ** the fixed/per unit unloading duration for resource is not
     * compatible with the orders constraints: partition and whole visit in time
     * window. Hence if one of the constraint at least tsResource
     * fixedUnloadingDuration and tsResource unloadingDurationPerUnit is non
     * null, partition and whole visit in time window are disabled.
     *
     * @var string
     */
    private $fixedUnloadingDuration;

    /**
     * the time needed to the resource to deliver/pick-up one unit of product at
     * the customer&#39;s place.
     * 
     * This resource&#39;s duration is added to the fixed resource&#39;s unloading
     * duration and to the order&#39;s unloading duration depending on quantity to
     * deliver/pick-up. See also tsResource fixedUnloadingDuration and tsOrder
     * unloadingDurationPerUnit.
     * 
     * **Example : **
     * 
     * * Set tsOrderQuantity to 3.
     * 
     * * Set tsOrder unloadingDurationPerUnit to 2 mn and tsResource
     * fixedUnloadingDuration and tsResource unloadingPerUnit to 0 or empty: the
     * variable part of the order is 6 mn
     * 
     * * Set tsOrder unloadingDurationPerUnit to 2 mn and tsResource
     * fixedUnloadingDuration to 10 mn and tsResource unloadingPerUnit to 0 or
     * empty: the variable part of the order is 10 mn
     * 
     * * Set tsOrder unloadingDurationPerUnit to 2 mn and tsResource
     * fixedUnloadingDuration empty and tsResource unloadingPerUnit to 1 mn: the
     * variable part of the order is 3 mn
     * 
     * **Type : ** &quot;hh:mm:ss&quot;, DateTime.
     *
     * @var string
     */
    private $unloadingDurationPerUnit;

    /**
     * Value for maximum number of reloads per day.
     *
     * @var integer
     */
    private $maximumReloads;

    /**
     * Value of the penalty if the resource exceeds the maximum number of
     * reloads per day.
     * 
     * If the resource exceeds the maximum number of reloads per day, it will be
     * penalized by the maximum reloads penalty multiplied by the number of
     * reloads&#39; overtaking. The default value is 1024 if the constraint
     * maximumReloads is set. See also maximumReloads.
     *
     * @var double
     */
    private $maximumReloadsPenalty;

    /**
     * Constraint providing resource to reload at depot during a tour.
     * 
     * If none of the constraints loadBeforeDeparture and loadOnReturn is
     * activated, the resource is never loading at depot. If one of these
     * constraint is activated the resource is loading once per tour, either at
     * the beginning of the tour or at the end of it. If both constraints are
     * activated then the resource is loading twice a tour, at the beginning and
     * at the end.
     * 
     * With standard solver only : solver always works with solution cost
     * comparison, so it may allow reloads even if you set noReload to true if
     * the solution cost is really lower. The only way to totally prevent
     * reloads is to set fixedLoadingDuration to a very long duration (20:00:00
     * for instance). The solver will warn you about this long duration but will
     * not add reloads to the tours. Caution : Don&#39;t do this if you are using
     * loadOnReturn or loadBeforeDeparture
     * 
     * **Default : ** False
     *
     * @var boolean
     */
    private $noReload;

    /**
     * The start time of the resource work time window for the &quot;other working
     * days&quot; (see otherWorkDaysList).
     * 
     * If you defined other working days, use this constraint to specify the
     * time at which the tour must start. These times can be adjusted using the
     * optimumStartTime parameter.
     * 
     * You can define up to 3 different start times here, corresponding to the
     * different &quot;other working days&quot; slots.
     * 
     * **Type : ** List of &quot;hh:mm:ss&quot;, DateTime. **Example : **
     * [&quot;08:00:00&quot;,&quot;09:00:00]
     *
     * @var string[]
     */
    private $otherWorkStartTimes;

    /**
     * The end time of the resource work time window for the &quot;other working
     * days&quot; (see otherWorkDaysList).
     * 
     * If you defined other working days, use this constraint to specify the
     * time at which the tour must end. These times can be adjusted using the
     * optimumStartTime parameter.
     * 
     * You can define up to 3 different end times here, corresponding to the
     * different &quot;other working days&quot; slots.
     * 
     * **Type : ** List of &quot;hh:mm:ss&quot;, DateTime. **Example : **
     * [&quot;18:00:00&quot;,&quot;19:00:00]
     *
     * @var string[]
     */
    private $otherWorkEndTimes;

    /**
     * Other working days (see workingDays)
     * 
     * You can define up to 3 different working days slots. If you do so, you
     * can then specify distinct work start and end times with
     * otherWorkStartTimes and otherWorkEndTimes.
     * 
     * **Type : ** List of string (see workingDays format) **Example : **
     * [&quot;2&quot;,&quot;3=&gt;5&quot;]
     *
     * @var string[]
     */
    private $otherWorkDaysList;

    /**
     * The list of products provided by a resource.
     * 
     * This constraint is linked with tsDepot requiredProducts constraint: a
     * depot with a required product can only be visited by a resource providing
     * it.
     * 
     * **Type : ** string as a list of products separated with commas. **Default
     * : ** not used.
     * 
     * ** Example : ** Specify &quot;Oxygen&quot; in the resource can provide oxygen.
     *
     * @var string
     */
    private $providedProducts;

    /**
     * Penalty value if the resource is used in the planning.
     * 
     * Use this constraint to specify the penalty if the resource is used at
     * least one day in the planning
     * 
     * **Type : ** float **Default : ** 0
     *
     * @var double
     */
    private $useInPlanningPenalty;

    /**
     * The maximum distance the resource should travel per day.
     * 
     * Use this constraint to specify the distance the resource should not
     * exceed in one day
     * 
     * **Type : ** integer **Default : ** -1 (no limit)
     *
     * @var integer
     */
    private $maximumDistance;

    /**
     * The maximum number of visits the resource can perform in one day.
     * 
     * 
     * **Type : ** integer **Default : ** -1 (no limit) **Max : ** 2,147,483.
     *
     * @var integer
     */
    private $maximumVisits;

    /**
     * Mobile login to be specified only if you need to be able to export the
     * optimization result to operation planning from TsCloud GUI. If you
     * trigger operational planning export from the API, you will still need to
     * specify the mapping between resource name and login.
     *
     * @var string
     */
    private $mobileLogin;

    /**
     * Determines if both global capacity and capacities per product should be
     * considered in the optimization or only global capacity.
     * 
     * **Type : ** Boolean **Default : ** False
     * 
     * ** Example : ** Set globalCapacity = 15 and useAllCapacities = False. The
     * global capacity only is considered: the vehicle can carry 15 quantities
     * of products, whatever product is to be carried.
     *
     * @var boolean
     */
    private $useAllCapacities;

    /**
     * Global capacity for a resource. This constraint unables to set a maximum
     * capacity on a resource, whatever product is carried. If both global
     * capacity and capacity per product are to be used, set True for the value
     * of *useAllCapacities*.
     * 
     * **Type : ** Float **Default : ** None **Max : ** 2,147,483.
     * 
     * ** Example : ** Set globalCapacity = 15 and useAllCapacities = False. The
     * global capacity only is considered: the vehicle can carry 15 quantities
     * of products, whatever product is to be carried.
     *
     * @var double
     */
    private $globalCapacity;

    /**
     * Name of TSOrder customData that will contain the TSOrder type used for
     * additional cost computation (see toursResult object)
     *
     * @var string
     */
    private $additionalCostOrderCustomDataName;

    /**
     * Operator used to compute additional cost (see toursResult object)
     * 
     * Possible values are :
     * 
     * * SUM : tour additional cost will be the sum of additional costs of
     * planned orders
     * 
     * * MAX : tour additional cost will be the maximum value of additional
     * costs of planned orders
     * 
     * * MIN : tour additional cost will be the minimum value of additional
     * costs of planned orders
     * 
     * * AVERAGE : tour additional cost will be the average of additional costs
     * of planned orders
     *
     * @var string
     */
    private $additionalCostOperator;

    /**
     * List of additional cost (cost per order type)
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSAdditionalCost[]
     */
    private $additionalCosts;

    /**
     * (no documentation provided)
     *
     * @var boolean
     */
    private $openTimeStart;

    /**
     * (no documentation provided)
     *
     * @var boolean
     */
    private $openDistanceStart;

    /**
     * (no documentation provided)
     *
     * @var boolean
     */
    private $openTimeStop;

    /**
     * (no documentation provided)
     *
     * @var boolean
     */
    private $openDistanceStop;

    /**
     * (no documentation provided)
     *
     * @var boolean
     */
    private $tomTomWebFleetEnabled;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $tomTomWebFleetIdentifier;

    /**
     * Vehicles regulations.
     * 
     * Possible values are :
     * 
     * * bicycle
     * 
     * * bus
     * 
     * * car
     * 
     * * deliveryIntermediateVehicle
     * 
     * * deliveryLightCommercialVehicle
     * 
     * * emergencyTruck
     * 
     * * emergencyVehicle
     * 
     * * intermediateVehicle
     * 
     * * lightCommercialVehicle
     * 
     * * pedestrian
     * 
     * * taxi
     * 
     * * truck
     * 
     * If not specified, vehicle type defined in UI will be used
     * 
     * Only new solver can handle optimization with several types of vehicle. If
     * you use standard solver, you should specify the vehicle code only in the
     * options object.
     *
     * @var string
     */
    private $vehicleCode;

    /**
     * Vehicles fuel type. Possible values are :
     * 
     * * diesel
     * 
     * * undefined
     * 
     * * unleaded
     *
     * @var string
     */
    private $fuelCode;

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Resource\DayOff[]
     */
    private $daysOff;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $allowedNights;

    /**
     * Parking time in seconds added to the travel time before each order (new engine only).
     * 
     * This parking time is applied only once for a group of aggregated orders.
     *
     * @var integer
     */
    private $parkingTime;

    /**
     * Constructs a TSResource from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * Indicates whether a resource is included in the planning process or not.
       * 
       * This constraint enables you to easily modify your optimization problem
       * configuration without having to add nor delete original data.
       * 
       * * Set it to True to include a resource element in the planning process.
       * 
       * * Set it to False to ignore it: it will not be used in the planning.
       * 
       * **Type : ** Boolean. **Default : ** not used.
     *
     * @return boolean
     */
    public function getAvailable()
    {
        return $this->available;
    }

    /**
     * Indicates whether a resource is included in the planning process or not.
       * 
       * This constraint enables you to easily modify your optimization problem
       * configuration without having to add nor delete original data.
       * 
       * * Set it to True to include a resource element in the planning process.
       * 
       * * Set it to False to ignore it: it will not be used in the planning.
       * 
       * **Type : ** Boolean. **Default : ** not used.
     *
     * @param boolean $available
     */
    public function setAvailable($available)
    {
        $this->available = $available;
    }
    /**
     * Average consumption of the resource. Use this constraint to specify the
       * average consumption of the resource. This consumption must be defined in
       * liters per 100 distance unit (km or miles)
       * 
       * **Default : ** The consumption indicated in the
       * VehicleProfile.Consumption property.
     *
     * @return double
     */
    public function getAvgConsumption()
    {
        return $this->avgConsumption;
    }

    /**
     * Average consumption of the resource. Use this constraint to specify the
       * average consumption of the resource. This consumption must be defined in
       * liters per 100 distance unit (km or miles)
       * 
       * **Default : ** The consumption indicated in the
       * VehicleProfile.Consumption property.
     *
     * @param double $avgConsumption
     */
    public function setAvgConsumption($avgConsumption)
    {
        $this->avgConsumption = $avgConsumption;
    }
    /**
     * An additional duration applied before the tour starts. Use this
       * constraint to specify an additional duration before the resource begins
       * the tour. For instance, to brief drivers before they leave or to simulate
       * an initial vehicle loading time (no depot).
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** &quot;00:00:00&quot;.
     *
     * @return string
     */
    public function getBriefingDuration()
    {
        return $this->briefingDuration;
    }

    /**
     * An additional duration applied before the tour starts. Use this
       * constraint to specify an additional duration before the resource begins
       * the tour. For instance, to brief drivers before they leave or to simulate
       * an initial vehicle loading time (no depot).
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** &quot;00:00:00&quot;.
     *
     * @param string $briefingDuration
     */
    public function setBriefingDuration($briefingDuration)
    {
        $this->briefingDuration = $briefingDuration;
    }
    /**
     * The total product capacity a resource can carry. Use this constraint to
       * specify the amount of product a resource can deliver or pick-up. It must
       * be linked with the customers related quantity constraint. 23 more
       * dimensions can be used in order to specify various products. They must be
       * linked with the customers related dimensions.
       * 
       * **Type : ** float (maximum of 3 significant digits after decimal
       * separator). **Default: ** None. **Max : ** 2,147,483.
       * 
       * **Example :**
       * 
       * * Use it to store the total number of packages a resource can deliver
       * before reloading, when working with packages.
       * 
       * * Use it to store the total number of litres a resource can deliver
       * before reloading, when working with liquids.
       * 
       * * Use multiple capacity dimensions when working with multiple products:
       * when delivering fuels, you will use as many capacities as types of fuels.
     *
     * @return double[]
     */
    public function getCapacities()
    {
        return $this->capacities;
    }

    /**
     * The total product capacity a resource can carry. Use this constraint to
       * specify the amount of product a resource can deliver or pick-up. It must
       * be linked with the customers related quantity constraint. 23 more
       * dimensions can be used in order to specify various products. They must be
       * linked with the customers related dimensions.
       * 
       * **Type : ** float (maximum of 3 significant digits after decimal
       * separator). **Default: ** None. **Max : ** 2,147,483.
       * 
       * **Example :**
       * 
       * * Use it to store the total number of packages a resource can deliver
       * before reloading, when working with packages.
       * 
       * * Use it to store the total number of litres a resource can deliver
       * before reloading, when working with liquids.
       * 
       * * Use multiple capacity dimensions when working with multiple products:
       * when delivering fuels, you will use as many capacities as types of fuels.
     *
     * @param double[] $capacities
     */
    public function setCapacities($capacities)
    {
        $this->capacities = $capacities;
    }
    /**
     * The list of characteristics provided by a resource.
       * 
       * This constraint is linked with the same order constraint: a customer with
       * a required skill can only be delivered by a resource providing it.
       * 
       * Caution : use only alphanumeric characters (and _) in your characteristics values, otherwise the skill will be ignored.
       * 
       * **Type : ** string as a list of characteristics separated with commas.
       * **Default: : ** not used.
       * 
       * **Example : **
       * 
       * * Specify &quot;Maintenance&quot; in the provided skills of a resource designed to
       * perform maintenance visits type.
       * 
       * * Specify &quot;Small vehicle&quot; to the provided skills of a resource able to
       * perform downtown visits.
     *
     * @return string
     */
    public function getProvidedSkills()
    {
        return $this->providedSkills;
    }

    /**
     * The list of characteristics provided by a resource.
       * 
       * This constraint is linked with the same order constraint: a customer with
       * a required skill can only be delivered by a resource providing it.
       * 
       * Caution : use only alphanumeric characters (and _) in your characteristics values, otherwise the skill will be ignored.
       * 
       * **Type : ** string as a list of characteristics separated with commas.
       * **Default: : ** not used.
       * 
       * **Example : **
       * 
       * * Specify &quot;Maintenance&quot; in the provided skills of a resource designed to
       * perform maintenance visits type.
       * 
       * * Specify &quot;Small vehicle&quot; to the provided skills of a resource able to
       * perform downtown visits.
     *
     * @param string $providedSkills
     */
    public function setProvidedSkills($providedSkills)
    {
        $this->providedSkills = $providedSkills;
    }
    /**
     * Private custom data.
       * 
       * Use this feature when you need to keep attributes values of your own into
       * the optimization context. For instance if you need the address of an
       * element, store it there.
     *
     * @return array
     */
    public function getCustomDataMap()
    {
        return $this->customDataMap;
    }

    /**
     * Private custom data.
       * 
       * Use this feature when you need to keep attributes values of your own into
       * the optimization context. For instance if you need the address of an
       * element, store it there.
     *
     * @param array $customDataMap
     */
    public function setCustomDataMap($customDataMap)
    {
        $this->customDataMap = $customDataMap;
    }
    /**
     * The maximum resource work duration over a day. Use this constraint to
       * specify the maximum daily work duration (unless overtime periods have
       * been defined). If the dailyWorkTime constraint is not set to a value,
       * default daily work time is computed from resource time window and lunch
       * duration (workStartTime, workEndTime and lunchDuration).
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** not used.
     *
     * @return string
     */
    public function getDailyWorkTime()
    {
        return $this->dailyWorkTime;
    }

    /**
     * The maximum resource work duration over a day. Use this constraint to
       * specify the maximum daily work duration (unless overtime periods have
       * been defined). If the dailyWorkTime constraint is not set to a value,
       * default daily work time is computed from resource time window and lunch
       * duration (workStartTime, workEndTime and lunchDuration).
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** not used.
     *
     * @param string $dailyWorkTime
     */
    public function setDailyWorkTime($dailyWorkTime)
    {
        $this->dailyWorkTime = $dailyWorkTime;
    }
    /**
     * An additional duration applied at the end of the tour. Use this
       * constraint to specify an additional duration after the resources stops at
       * the end location. For instance, to debrief drivers after their tour or to
       * account an ultimate vehicle unloading time, or a parking time.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** &quot;00:00:00&quot;.
     *
     * @return string
     */
    public function getDebriefingDuration()
    {
        return $this->debriefingDuration;
    }

    /**
     * An additional duration applied at the end of the tour. Use this
       * constraint to specify an additional duration after the resources stops at
       * the end location. For instance, to debrief drivers after their tour or to
       * account an ultimate vehicle unloading time, or a parking time.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** &quot;00:00:00&quot;.
     *
     * @param string $debriefingDuration
     */
    public function setDebriefingDuration($debriefingDuration)
    {
        $this->debriefingDuration = $debriefingDuration;
    }
    /**
     * Indicates whether or not time spent at customer during deliveries can be
       * considered as rest break.
       * 
       * * Set it to True if a visit can be considered as a rest break, as soon as
       * its duration is equal or higher than the legalMinRestDuration constraint.
       * 
       * * Set it to False if not.
       * 
       * **Type : ** Boolean. **Default : ** False.
     *
     * @return boolean
     */
    public function getDriveRestAtCustomer()
    {
        return $this->driveRestAtCustomer;
    }

    /**
     * Indicates whether or not time spent at customer during deliveries can be
       * considered as rest break.
       * 
       * * Set it to True if a visit can be considered as a rest break, as soon as
       * its duration is equal or higher than the legalMinRestDuration constraint.
       * 
       * * Set it to False if not.
       * 
       * **Type : ** Boolean. **Default : ** False.
     *
     * @param boolean $driveRestAtCustomer
     */
    public function setDriveRestAtCustomer($driveRestAtCustomer)
    {
        $this->driveRestAtCustomer = $driveRestAtCustomer;
    }
    /**
     * Indicates whether time spent at depot during a reload break can be
       * considered as drive break or not.
       * 
       * Use this constraint to take into account drive time legislation in your
       * planning results.
       * 
       * * Set it to True if load breaks can be considered as drive breaks, as
       * soon as their duration is equal or higher than the legalMinRestDuration
       * constraint.
       * 
       * * Set it to False if not.
       * 
       * **Type : ** Boolean. **Default : ** False.
     *
     * @return boolean
     */
    public function getDriveRestAtDepot()
    {
        return $this->driveRestAtDepot;
    }

    /**
     * Indicates whether time spent at depot during a reload break can be
       * considered as drive break or not.
       * 
       * Use this constraint to take into account drive time legislation in your
       * planning results.
       * 
       * * Set it to True if load breaks can be considered as drive breaks, as
       * soon as their duration is equal or higher than the legalMinRestDuration
       * constraint.
       * 
       * * Set it to False if not.
       * 
       * **Type : ** Boolean. **Default : ** False.
     *
     * @param boolean $driveRestAtDepot
     */
    public function setDriveRestAtDepot($driveRestAtDepot)
    {
        $this->driveRestAtDepot = $driveRestAtDepot;
    }
    /**
     * The fixed duration of the resource load break. Use this constraint to
       * specify how long takes a resource reload at depot. You can specify an
       * additional duration according to the quantity to reload, using
       * loadingDurationPerUnit.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** &quot;00:00:00&quot;.
       * 
       * **Example : **
       * 
       * * fixedVisitDuration = &quot;00:30:00&quot; indicates that 30 minutes are needed to
       * load the resource.
       * 
       * * loadingDurationPerUnit = 120 indicates that 120 sec are needed to load
       * one unit. If the quantity to reload is 8, for instance, the variable part
       * is 120*8. 16 minutes are required to load the resource.
       * 
       * * Total load time = 30 minutes + 16 minutes = 46 minutes accounted for
       * this reload break.
     *
     * @return string
     */
    public function getFixedLoadingDuration()
    {
        return $this->fixedLoadingDuration;
    }

    /**
     * The fixed duration of the resource load break. Use this constraint to
       * specify how long takes a resource reload at depot. You can specify an
       * additional duration according to the quantity to reload, using
       * loadingDurationPerUnit.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** &quot;00:00:00&quot;.
       * 
       * **Example : **
       * 
       * * fixedVisitDuration = &quot;00:30:00&quot; indicates that 30 minutes are needed to
       * load the resource.
       * 
       * * loadingDurationPerUnit = 120 indicates that 120 sec are needed to load
       * one unit. If the quantity to reload is 8, for instance, the variable part
       * is 120*8. 16 minutes are required to load the resource.
       * 
       * * Total load time = 30 minutes + 16 minutes = 46 minutes accounted for
       * this reload break.
     *
     * @param string $fixedLoadingDuration
     */
    public function setFixedLoadingDuration($fixedLoadingDuration)
    {
        $this->fixedLoadingDuration = $fixedLoadingDuration;
    }
    /**
     * The fuel type of the resource.
       * 
       * Use this constraint to specify the fuel type of the resource. Available
       * fuel types are :
       * 
       * * 0: Unknown fuel type
       * 
       * * 1: No fuel type (pedestrian)
       * 
       * * 2: Diesel
       * 
       * * 3: Unleaded fuel
       * 
       * * 4: LPG
       * 
       * **Type : ** Integer. **Default :** The fuel type indicated in the
       * VehicleProfile.FuelType property.
     *
     * @return integer
     */
    public function getFuelType()
    {
        return $this->fuelType;
    }

    /**
     * The fuel type of the resource.
       * 
       * Use this constraint to specify the fuel type of the resource. Available
       * fuel types are :
       * 
       * * 0: Unknown fuel type
       * 
       * * 1: No fuel type (pedestrian)
       * 
       * * 2: Diesel
       * 
       * * 3: Unleaded fuel
       * 
       * * 4: LPG
       * 
       * **Type : ** Integer. **Default :** The fuel type indicated in the
       * VehicleProfile.FuelType property.
     *
     * @param integer $fuelType
     */
    public function setFuelType($fuelType)
    {
        $this->fuelType = $fuelType;
    }
    /**
     * The unique identifier of the resource.
       * 
       * This id can not contain special characters like &#39;=&#39; or &#39;:&#39;
     *
     * @return string
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * The unique identifier of the resource.
       * 
       * This id can not contain special characters like &#39;=&#39; or &#39;:&#39;
     *
     * @param string $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }
    /**
     * The legal daily duration a resource can drive before having a rest break.
       * 
       * Use this constraint to take into account drive time legislation in your
       * planning results. Specify the rest duration in the
       * legalDailyRestDuration: rest breaks occur as soon as the resource has
       * driven the legal daily driving duration or has completed its daily work
       * time.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** not used.
       * 
       * **Example : ** legalDailyDriveDuration = &quot;09:00:00&quot;,
       * legalDailyRestDuration = &quot;11:00:00&quot;. The resource can cumulate a 9-hours
       * daily drive time before having to rest during 11 hours.
     *
     * @return string
     */
    public function getLegalDailyDriveDuration()
    {
        return $this->legalDailyDriveDuration;
    }

    /**
     * The legal daily duration a resource can drive before having a rest break.
       * 
       * Use this constraint to take into account drive time legislation in your
       * planning results. Specify the rest duration in the
       * legalDailyRestDuration: rest breaks occur as soon as the resource has
       * driven the legal daily driving duration or has completed its daily work
       * time.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** not used.
       * 
       * **Example : ** legalDailyDriveDuration = &quot;09:00:00&quot;,
       * legalDailyRestDuration = &quot;11:00:00&quot;. The resource can cumulate a 9-hours
       * daily drive time before having to rest during 11 hours.
     *
     * @param string $legalDailyDriveDuration
     */
    public function setLegalDailyDriveDuration($legalDailyDriveDuration)
    {
        $this->legalDailyDriveDuration = $legalDailyDriveDuration;
    }
    /**
     * The legal rest duration a resource must have after the daily max drive
       * duration.
       * 
       * Use this constraint to take into account drive time legislation in your
       * planning results. Rest breaks occur as soon as the resource has driven
       * the legal max daily duration or has complete its daily work time. The use
       * of both legalDailyDriveDuration and legalDailyRestDuration implies that
       * the start and end time of tours are no longer defined by the
       * workStartTime and workEndTime constraints, but may vary as long as the
       * legalDailyRestDuration constraint is respected.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** not used.
     *
     * @return string
     */
    public function getLegalDailyRestDuration()
    {
        return $this->legalDailyRestDuration;
    }

    /**
     * The legal rest duration a resource must have after the daily max drive
       * duration.
       * 
       * Use this constraint to take into account drive time legislation in your
       * planning results. Rest breaks occur as soon as the resource has driven
       * the legal max daily duration or has complete its daily work time. The use
       * of both legalDailyDriveDuration and legalDailyRestDuration implies that
       * the start and end time of tours are no longer defined by the
       * workStartTime and workEndTime constraints, but may vary as long as the
       * legalDailyRestDuration constraint is respected.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** not used.
     *
     * @param string $legalDailyRestDuration
     */
    public function setLegalDailyRestDuration($legalDailyRestDuration)
    {
        $this->legalDailyRestDuration = $legalDailyRestDuration;
    }
    /**
     * The resource break duration after max drive duration. Use this constraint
       * to take into account drive time legislation in your planning results.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** not used.
     *
     * @return string
     */
    public function getLegalDriveRestDuration()
    {
        return $this->legalDriveRestDuration;
    }

    /**
     * The resource break duration after max drive duration. Use this constraint
       * to take into account drive time legislation in your planning results.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** not used.
     *
     * @param string $legalDriveRestDuration
     */
    public function setLegalDriveRestDuration($legalDriveRestDuration)
    {
        $this->legalDriveRestDuration = $legalDriveRestDuration;
    }
    /**
     * The legal max duration a resource can drive without a break. Use this
       * constraint to take into account drive time legislation in your planning
       * results.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default: : ** not used.
       * 
       * **Example : **
       * 
       * * legalMaxDriveDuration = &quot;04:30:00&quot;, legalDriveRestDuration =
       * &quot;00:45:00&quot;. The resource can drive for 4 hours and 30 minutes before
       * having a 45 minutes break. Then it can start driving again for 4 hours
       * and 30 minutes...etc.
       * 
       * * If added driveRestAtCustomer = True and legalMinRestDuration =
       * &quot;00:15:00&quot;, rest time is cumulated as soon as customer visit duration is
       * equal or higher than the specified min rest duration. If the 45 minutes
       * rest break has not occured when the resource has driven for 4 hours and
       * 30 minutes, it must stop to complete the break. Otherwise, it can drive
       * again for 4 hours and 30 minutes.
     *
     * @return string
     */
    public function getLegalMaxDriveDuration()
    {
        return $this->legalMaxDriveDuration;
    }

    /**
     * The legal max duration a resource can drive without a break. Use this
       * constraint to take into account drive time legislation in your planning
       * results.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default: : ** not used.
       * 
       * **Example : **
       * 
       * * legalMaxDriveDuration = &quot;04:30:00&quot;, legalDriveRestDuration =
       * &quot;00:45:00&quot;. The resource can drive for 4 hours and 30 minutes before
       * having a 45 minutes break. Then it can start driving again for 4 hours
       * and 30 minutes...etc.
       * 
       * * If added driveRestAtCustomer = True and legalMinRestDuration =
       * &quot;00:15:00&quot;, rest time is cumulated as soon as customer visit duration is
       * equal or higher than the specified min rest duration. If the 45 minutes
       * rest break has not occured when the resource has driven for 4 hours and
       * 30 minutes, it must stop to complete the break. Otherwise, it can drive
       * again for 4 hours and 30 minutes.
     *
     * @param string $legalMaxDriveDuration
     */
    public function setLegalMaxDriveDuration($legalMaxDriveDuration)
    {
        $this->legalMaxDriveDuration = $legalMaxDriveDuration;
    }
    /**
     * The minimum duration a resource breaks for it to be considered as a drive
       * break. Use this constraint to take into account drive time legislation in
       * your planning results. When breaks occur at customer or at depot, they
       * are considered as drive breaks if their duration is equal or higher than
       * the specified min rest duration.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default: : ** not used.
     *
     * @return string
     */
    public function getLegalMinRestDuration()
    {
        return $this->legalMinRestDuration;
    }

    /**
     * The minimum duration a resource breaks for it to be considered as a drive
       * break. Use this constraint to take into account drive time legislation in
       * your planning results. When breaks occur at customer or at depot, they
       * are considered as drive breaks if their duration is equal or higher than
       * the specified min rest duration.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default: : ** not used.
     *
     * @param string $legalMinRestDuration
     */
    public function setLegalMinRestDuration($legalMinRestDuration)
    {
        $this->legalMinRestDuration = $legalMinRestDuration;
    }
    /**
     * Indicates whether a resource must load before starting a tour or not.
       * 
       * * Set this constraint to True to insert a load break at depot before the
       * tour starts.
       * 
       * * Set it to False to consider the vehicle loaded.
       * 
       * **Type : ** Boolean. **Default: : ** False.
     *
     * @return boolean
     */
    public function getLoadBeforeDeparture()
    {
        return $this->loadBeforeDeparture;
    }

    /**
     * Indicates whether a resource must load before starting a tour or not.
       * 
       * * Set this constraint to True to insert a load break at depot before the
       * tour starts.
       * 
       * * Set it to False to consider the vehicle loaded.
       * 
       * **Type : ** Boolean. **Default: : ** False.
     *
     * @param boolean $loadBeforeDeparture
     */
    public function setLoadBeforeDeparture($loadBeforeDeparture)
    {
        $this->loadBeforeDeparture = $loadBeforeDeparture;
    }
    /**
     * The time needed to load a unit of product. This constraint is added to
       * the fixed part of the loading duration: it depends on the total quantity
       * to load.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime, Integer (number of seconds). **Default:
       * : ** 0.
     *
     * @return string
     */
    public function getLoadingDurationPerUnit()
    {
        return $this->loadingDurationPerUnit;
    }

    /**
     * The time needed to load a unit of product. This constraint is added to
       * the fixed part of the loading duration: it depends on the total quantity
       * to load.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime, Integer (number of seconds). **Default:
       * : ** 0.
     *
     * @param string $loadingDurationPerUnit
     */
    public function setLoadingDurationPerUnit($loadingDurationPerUnit)
    {
        $this->loadingDurationPerUnit = $loadingDurationPerUnit;
    }
    /**
     * Indicates whether a resource must reload after a tour or not.
       * 
       * * Set this constraint to True to insert a load break at depot after the
       * tour ends.
       * 
       * * Set it to False to not reload the vehicle.
       * 
       * **Type : ** Boolean. **Default: : ** False.
     *
     * @return boolean
     */
    public function getLoadOnReturn()
    {
        return $this->loadOnReturn;
    }

    /**
     * Indicates whether a resource must reload after a tour or not.
       * 
       * * Set this constraint to True to insert a load break at depot after the
       * tour ends.
       * 
       * * Set it to False to not reload the vehicle.
       * 
       * **Type : ** Boolean. **Default: : ** False.
     *
     * @param boolean $loadOnReturn
     */
    public function setLoadOnReturn($loadOnReturn)
    {
        $this->loadOnReturn = $loadOnReturn;
    }
    /**
     * The lunch break
       * 
       * **Default: : ** no lunch break
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSPause
     */
    public function getLunch()
    {
        return $this->lunch;
    }

    /**
     * The lunch break
       * 
       * **Default: : ** no lunch break
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSPause $lunch
     */
    public function setLunch($lunch)
    {
        $this->lunch = $lunch;
    }
    /**
     * The number of nights a resource can spend out to perform deliveries
       * before coming back to base.
       * 
       * Use this constraint to enable night breaks trip: it will store how many
       * days a resource can drive away from depot. Unless the vehicle needs to
       * reload, it will not come back before.
       * 
       * **Type : ** integer. **Default: : ** not used.
       * 
       * Example: maxNightsOutPerJourney = 4, workDays = 1=&gt;5. The resource can
       * perform deliveries during 5 days (and 4 nights) without coming back to
       * depot. Starting on day 1, it must come back to depot on day 5.
     *
     * @return integer
     */
    public function getMaxNightsOutPerJourney()
    {
        return $this->maxNightsOutPerJourney;
    }

    /**
     * The number of nights a resource can spend out to perform deliveries
       * before coming back to base.
       * 
       * Use this constraint to enable night breaks trip: it will store how many
       * days a resource can drive away from depot. Unless the vehicle needs to
       * reload, it will not come back before.
       * 
       * **Type : ** integer. **Default: : ** not used.
       * 
       * Example: maxNightsOutPerJourney = 4, workDays = 1=&gt;5. The resource can
       * perform deliveries during 5 days (and 4 nights) without coming back to
       * depot. Starting on day 1, it must come back to depot on day 5.
     *
     * @param integer $maxNightsOutPerJourney
     */
    public function setMaxNightsOutPerJourney($maxNightsOutPerJourney)
    {
        $this->maxNightsOutPerJourney = $maxNightsOutPerJourney;
    }
    /**
     * The number of nights a resource can spend out to perform deliveries
       * before coming back to base in a week.
       * 
       * **Type : ** integer. **Default: : ** not used.
     *
     * @return integer
     */
    public function getMaxNightsOutPerWeek()
    {
        return $this->maxNightsOutPerWeek;
    }

    /**
     * The number of nights a resource can spend out to perform deliveries
       * before coming back to base in a week.
       * 
       * **Type : ** integer. **Default: : ** not used.
     *
     * @param integer $maxNightsOutPerWeek
     */
    public function setMaxNightsOutPerWeek($maxNightsOutPerWeek)
    {
        $this->maxNightsOutPerWeek = $maxNightsOutPerWeek;
    }
    /**
     * The minimum laps of time between 2 consecutive visits.
       * 
       * Use this constraint to specify a minimum drive time accounted when
       * consecutive visits are very close, in order to compute a realistic
       * timing.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default: : ** not used.
     *
     * @return string
     */
    public function getMinDriveDuration()
    {
        return $this->minDriveDuration;
    }

    /**
     * The minimum laps of time between 2 consecutive visits.
       * 
       * Use this constraint to specify a minimum drive time accounted when
       * consecutive visits are very close, in order to compute a realistic
       * timing.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default: : ** not used.
     *
     * @param string $minDriveDuration
     */
    public function setMinDriveDuration($minDriveDuration)
    {
        $this->minDriveDuration = $minDriveDuration;
    }
    /**
     * The night cost of a resource when planning night breaks.
       * 
       * Use this constrainte to specify how much a night out costs (lunch, bed,
       * breakfeast...) for a resource when night breaks are allowed.
       * 
       * **Type : ** float. **Default: : ** 0
     *
     * @return double
     */
    public function getNightPenalty()
    {
        return $this->nightPenalty;
    }

    /**
     * The night cost of a resource when planning night breaks.
       * 
       * Use this constrainte to specify how much a night out costs (lunch, bed,
       * breakfeast...) for a resource when night breaks are allowed.
       * 
       * **Type : ** float. **Default: : ** 0
     *
     * @param double $nightPenalty
     */
    public function setNightPenalty($nightPenalty)
    {
        $this->nightPenalty = $nightPenalty;
    }
    /**
     * A cost paid for NOT using a resource in the computed planning.
       * 
       * Use this constraint to penalize the fact that an available resource is
       * not used in the planning. It proves usefull when you must use all the
       * resources in the Resources collection: you will prevent the solver from
       * optimizing the number of resources, as using them would be too expensive
       * a solution.
       * 
       * **Type : ** float. **Default: : ** not used.
       * 
       * **Example : ** Use it to specify parking taxes when a vehicle performs no
       * tour.
     *
     * @return double
     */
    public function getNonUsePenalty()
    {
        return $this->nonUsePenalty;
    }

    /**
     * A cost paid for NOT using a resource in the computed planning.
       * 
       * Use this constraint to penalize the fact that an available resource is
       * not used in the planning. It proves usefull when you must use all the
       * resources in the Resources collection: you will prevent the solver from
       * optimizing the number of resources, as using them would be too expensive
       * a solution.
       * 
       * **Type : ** float. **Default: : ** not used.
       * 
       * **Example : ** Use it to specify parking taxes when a vehicle performs no
       * tour.
     *
     * @param double $nonUsePenalty
     */
    public function setNonUsePenalty($nonUsePenalty)
    {
        $this->nonUsePenalty = $nonUsePenalty;
    }
    /**
     * Indicates whether or not a tour evaluation starts from the resource start
       * location or from the first customer&#39;s place.
       * 
       * * Set it to True to begin the tour at the first customer (no cost will be
       * computed between the resource start location and the first customer).
       * 
       * * Set it to False to begin the tour at the resource start location.
       * 
       * **Type : ** Boolean. **Default: : ** False.
     *
     * @return boolean
     */
    public function getOpenStart()
    {
        return $this->openStart;
    }

    /**
     * Indicates whether or not a tour evaluation starts from the resource start
       * location or from the first customer&#39;s place.
       * 
       * * Set it to True to begin the tour at the first customer (no cost will be
       * computed between the resource start location and the first customer).
       * 
       * * Set it to False to begin the tour at the resource start location.
       * 
       * **Type : ** Boolean. **Default: : ** False.
     *
     * @param boolean $openStart
     */
    public function setOpenStart($openStart)
    {
        $this->openStart = $openStart;
    }
    /**
     * Indicates whether or not a tour evaluation ends at the last customer&#39;s
       * place or at the resource end location.
       * 
       * * Set it to True to finish the tour at the last customer location (no
       * cost will be computed between the last customer and the resource end
       * location).
       * 
       * * Set it to False to finish the tour at the resource end location.
       * 
       * **Type : ** Boolean. **Default: : ** False.
     *
     * @return boolean
     */
    public function getOpenStop()
    {
        return $this->openStop;
    }

    /**
     * Indicates whether or not a tour evaluation ends at the last customer&#39;s
       * place or at the resource end location.
       * 
       * * Set it to True to finish the tour at the last customer location (no
       * cost will be computed between the last customer and the resource end
       * location).
       * 
       * * Set it to False to finish the tour at the resource end location.
       * 
       * **Type : ** Boolean. **Default: : ** False.
     *
     * @param boolean $openStop
     */
    public function setOpenStop($openStop)
    {
        $this->openStop = $openStop;
    }
    /**
     * Adapts the resource start time to the best solution.
       * 
       * * Set this constraint to False to start the tour at the time indicated by
       * the workStartTime constraint.
       * 
       * * Set this constraint to True to optimize the resource start time and
       * enable the use of the dailyWorkTime constraint.
       * 
       * Notice that, in both cases, the tour will not start before the time
       * stored in the workStartTime constraint and that the use of the
       * weeklyWorkTime constraint is enabled.
       * 
       * **Type : ** Boolean. **Default: : ** False.
     *
     * @return boolean
     */
    public function getOptimumStartTime()
    {
        return $this->optimumStartTime;
    }

    /**
     * Adapts the resource start time to the best solution.
       * 
       * * Set this constraint to False to start the tour at the time indicated by
       * the workStartTime constraint.
       * 
       * * Set this constraint to True to optimize the resource start time and
       * enable the use of the dailyWorkTime constraint.
       * 
       * Notice that, in both cases, the tour will not start before the time
       * stored in the workStartTime constraint and that the use of the
       * weeklyWorkTime constraint is enabled.
       * 
       * **Type : ** Boolean. **Default: : ** False.
     *
     * @param boolean $optimumStartTime
     */
    public function setOptimumStartTime($optimumStartTime)
    {
        $this->optimumStartTime = $optimumStartTime;
    }
    /**
     * The max duration a resource can drive to go back to base at the end of a
       * tour when working with night breaks.
       * 
       * Use this constraint when a resource can end a tour at base instead of
       * having a night break on the road.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;. **Default: : ** not used.
     *
     * @return string
     */
    public function getOvernightMinDriving()
    {
        return $this->overnightMinDriving;
    }

    /**
     * The max duration a resource can drive to go back to base at the end of a
       * tour when working with night breaks.
       * 
       * Use this constraint when a resource can end a tour at base instead of
       * having a night break on the road.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;. **Default: : ** not used.
     *
     * @param string $overnightMinDriving
     */
    public function setOvernightMinDriving($overnightMinDriving)
    {
        $this->overnightMinDriving = $overnightMinDriving;
    }
    /**
     * The duration of the resource overwork periods. (max 2 periods)
       * 
       * Use this constraint when you need to define 2 different overwork periods
       * with regard to daily work time and their related surcharge. No overwork
       * period can be defined with regard to weekly work time.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default: : ** not used (no second
       * overtime period).
       * 
       * **Example : **
       * 
       * workPenalty = 10, first overtime duration = &quot;02:00:00&quot;, first overtime
       * penalty = 5,second overtime duration = &quot;01:00:00&quot;, second overtime
       * penalty = 10.
       * 
       * The cost of the resource during the daily working time is 10 euros per
       * hour. The resource can work during 3 more hours and each overworked hour
       * will cost 10 + 5 euros for 2 hours and 10 + 10 euros for the last hour.
     *
     * @return string[]
     */
    public function getOvertimeDurations()
    {
        return $this->overtimeDurations;
    }

    /**
     * The duration of the resource overwork periods. (max 2 periods)
       * 
       * Use this constraint when you need to define 2 different overwork periods
       * with regard to daily work time and their related surcharge. No overwork
       * period can be defined with regard to weekly work time.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default: : ** not used (no second
       * overtime period).
       * 
       * **Example : **
       * 
       * workPenalty = 10, first overtime duration = &quot;02:00:00&quot;, first overtime
       * penalty = 5,second overtime duration = &quot;01:00:00&quot;, second overtime
       * penalty = 10.
       * 
       * The cost of the resource during the daily working time is 10 euros per
       * hour. The resource can work during 3 more hours and each overworked hour
       * will cost 10 + 5 euros for 2 hours and 10 + 10 euros for the last hour.
     *
     * @param string[] $overtimeDurations
     */
    public function setOvertimeDurations($overtimeDurations)
    {
        $this->overtimeDurations = $overtimeDurations;
    }
    /**
     * A surcharge for a resource&#39;s overwork period (max 2 periods).
       * 
       * Use this constraint to specify additional cost to workPenalty as overwork
       * time. You can define up to 2 overwork periods with regard to daily work
       * time and their related surcharge. No overwork period can be defined with
       * regard to weekly work time.
       * 
       * **Type : ** float. **Default: : ** not used.
       * 
       * **Example : **
       * 
       * workPenalty = 10, first overtime duration = &quot;02:00:00&quot;, first overtime
       * penalty = 5.
       * 
       * The cost of the resource during the daily working time is 10 euros per
       * hour. The resource can work during 2 hours after the daily working time
       * and each overworked hour will cost 15 (10 + 5) euros.
     *
     * @return double[]
     */
    public function getOvertimePenalties()
    {
        return $this->overtimePenalties;
    }

    /**
     * A surcharge for a resource&#39;s overwork period (max 2 periods).
       * 
       * Use this constraint to specify additional cost to workPenalty as overwork
       * time. You can define up to 2 overwork periods with regard to daily work
       * time and their related surcharge. No overwork period can be defined with
       * regard to weekly work time.
       * 
       * **Type : ** float. **Default: : ** not used.
       * 
       * **Example : **
       * 
       * workPenalty = 10, first overtime duration = &quot;02:00:00&quot;, first overtime
       * penalty = 5.
       * 
       * The cost of the resource during the daily working time is 10 euros per
       * hour. The resource can work during 2 hours after the daily working time
       * and each overworked hour will cost 15 (10 + 5) euros.
     *
     * @param double[] $overtimePenalties
     */
    public function setOvertimePenalties($overtimePenalties)
    {
        $this->overtimePenalties = $overtimePenalties;
    }
    /**
     * Indicates whether or not a whole work day cost is computed as soon as a
       * resource works even a few hours.
       * 
       * * Set this constraint to True to account a whole day cost.
       * 
       * * Set it to False to account only effective worked hours.
       * 
       * **Type : ** Boolean. **Default: : ** False.
     *
     * @return boolean
     */
    public function getPayWholeDay()
    {
        return $this->payWholeDay;
    }

    /**
     * Indicates whether or not a whole work day cost is computed as soon as a
       * resource works even a few hours.
       * 
       * * Set this constraint to True to account a whole day cost.
       * 
       * * Set it to False to account only effective worked hours.
       * 
       * **Type : ** Boolean. **Default: : ** False.
     *
     * @param boolean $payWholeDay
     */
    public function setPayWholeDay($payWholeDay)
    {
        $this->payWholeDay = $payWholeDay;
    }
    /**
     * An additional fixed cost applied each time the resource performs a visit.
       * 
       * Use this constraint when the cost of a resource may vary according to the
       * number of visits it performs.
       * 
       * **Type : ** float. **Default: : ** 0.
     *
     * @return double
     */
    public function getPenaltyPerVisit()
    {
        return $this->penaltyPerVisit;
    }

    /**
     * An additional fixed cost applied each time the resource performs a visit.
       * 
       * Use this constraint when the cost of a resource may vary according to the
       * number of visits it performs.
       * 
       * **Type : ** float. **Default: : ** 0.
     *
     * @param double $penaltyPerVisit
     */
    public function setPenaltyPerVisit($penaltyPerVisit)
    {
        $this->penaltyPerVisit = $penaltyPerVisit;
    }
    /**
     * A factor to increase or decrease the vehicle speed.
       * 
       * Whenever users observe a significant gap between estimated speeds and the
       * real ones, they can adjust them by using this factor. It is expressed as
       * a percentage of the used speed.
       * 
       * **Type : ** float. **Default: : ** not used.
       * 
       * **Example : **
       * 
       * * speedAdjustment = 110: resource speeds will be 10% higher than the used
       * speeds.
       * 
       * * speedAdjustment = 80: resource speeds will be 20% lower than the used
       * speeds.
     *
     * @return integer
     */
    public function getSpeedAdjustment()
    {
        return $this->speedAdjustment;
    }

    /**
     * A factor to increase or decrease the vehicle speed.
       * 
       * Whenever users observe a significant gap between estimated speeds and the
       * real ones, they can adjust them by using this factor. It is expressed as
       * a percentage of the used speed.
       * 
       * **Type : ** float. **Default: : ** not used.
       * 
       * **Example : **
       * 
       * * speedAdjustment = 110: resource speeds will be 10% higher than the used
       * speeds.
       * 
       * * speedAdjustment = 80: resource speeds will be 20% lower than the used
       * speeds.
     *
     * @param integer $speedAdjustment
     */
    public function setSpeedAdjustment($speedAdjustment)
    {
        $this->speedAdjustment = $speedAdjustment;
    }
    /**
     * travel time modifier associated with the start location of the resource
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTravelTimeModifier
     */
    public function getStartTravelTimeModifier()
    {
        return $this->startTravelTimeModifier;
    }

    /**
     * travel time modifier associated with the start location of the resource
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTravelTimeModifier $startTravelTimeModifier
     */
    public function setStartTravelTimeModifier($startTravelTimeModifier)
    {
        $this->startTravelTimeModifier = $startTravelTimeModifier;
    }
    /**
     * travel time modifier associated with the stop location of the resource
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTravelTimeModifier
     */
    public function getStopTravelTimeModifier()
    {
        return $this->stopTravelTimeModifier;
    }

    /**
     * travel time modifier associated with the stop location of the resource
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTravelTimeModifier $stopTravelTimeModifier
     */
    public function setStopTravelTimeModifier($stopTravelTimeModifier)
    {
        $this->stopTravelTimeModifier = $stopTravelTimeModifier;
    }
    /**
     * The costs for a resource of driving for one distance unit.
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTravelPenalty[]
     */
    public function getExtraTravelPenalties()
    {
        return $this->extraTravelPenalties;
    }

    /**
     * The costs for a resource of driving for one distance unit.
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTravelPenalty[] $extraTravelPenalties
     */
    public function setExtraTravelPenalties($extraTravelPenalties)
    {
        $this->extraTravelPenalties = $extraTravelPenalties;
    }
    /**
     * travel time modifiers
       * 
       * When reaching a location situated in a large city, one may want to take
       * into account driving difficulties, such as narrow streets and congestion.
       * The travel time modifier enables to increase the travel times around a
       * location. It is describes by three values. The value by which multiply
       * the travel times around the location travelTimeModifierValue), the
       * portion of the travel time on which the modifier applies
       * (travelTimeModifierLength) an offset to add to any travel duration
       * leaving or reaching the location (travelTimeModifierOffSet).
       * 
       * **Example : **
       * 
       * * Set travelTimeModifierValue to 1.5, travelTimeModifierLength to 300 and
       * travelTimeModifierOffSet to 60 for Resource 1
       * 
       * * Set travelTimeModifierValue to 2, travelTimeModifierLength to 420 and
       * travelTimeModifierOffSet to 0 for Order 1 If the initial travel duration
       * between Resource 1 and Order 1 was 1000, one obtains a travel time 360 *
       * 1.5 + 60 + 280 + 420 * 2 + 0 = 1660
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTravelTimeModifier
     */
    public function getTravelTimeModifier()
    {
        return $this->travelTimeModifier;
    }

    /**
     * travel time modifiers
       * 
       * When reaching a location situated in a large city, one may want to take
       * into account driving difficulties, such as narrow streets and congestion.
       * The travel time modifier enables to increase the travel times around a
       * location. It is describes by three values. The value by which multiply
       * the travel times around the location travelTimeModifierValue), the
       * portion of the travel time on which the modifier applies
       * (travelTimeModifierLength) an offset to add to any travel duration
       * leaving or reaching the location (travelTimeModifierOffSet).
       * 
       * **Example : **
       * 
       * * Set travelTimeModifierValue to 1.5, travelTimeModifierLength to 300 and
       * travelTimeModifierOffSet to 60 for Resource 1
       * 
       * * Set travelTimeModifierValue to 2, travelTimeModifierLength to 420 and
       * travelTimeModifierOffSet to 0 for Order 1 If the initial travel duration
       * between Resource 1 and Order 1 was 1000, one obtains a travel time 360 *
       * 1.5 + 60 + 280 + 420 * 2 + 0 = 1660
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTravelTimeModifier $travelTimeModifier
     */
    public function setTravelTimeModifier($travelTimeModifier)
    {
        $this->travelTimeModifier = $travelTimeModifier;
    }
    /**
     * A cost paid for using the resource in the computed planning. Use this
       * constraint to ponderate the cost of using a resource element of the
       * Resources collection, when working with rented vehicle for instance. You
       * can use it as well to reduce the number of resources used to perform the
       * deliveries.
       * 
       * **Type : ** float. **Default: : ** not used.
       * 
       * **Example : **
       * 
       * Add the cost of use to the distance and hourly costs when working with a
       * service provider. The solver, aiming at cost reduction, will try to
       * eliminate this resource first, as it is the most expensive.
     *
     * @return double
     */
    public function getUsePenalty()
    {
        return $this->usePenalty;
    }

    /**
     * A cost paid for using the resource in the computed planning. Use this
       * constraint to ponderate the cost of using a resource element of the
       * Resources collection, when working with rented vehicle for instance. You
       * can use it as well to reduce the number of resources used to perform the
       * deliveries.
       * 
       * **Type : ** float. **Default: : ** not used.
       * 
       * **Example : **
       * 
       * Add the cost of use to the distance and hourly costs when working with a
       * service provider. The solver, aiming at cost reduction, will try to
       * eliminate this resource first, as it is the most expensive.
     *
     * @param double $usePenalty
     */
    public function setUsePenalty($usePenalty)
    {
        $this->usePenalty = $usePenalty;
    }
    /**
     * The maximum resource work duration over a week.
       * 
       * Use this constraint to specify the maximum weekly work duration. Weeks
       * are defined as follows:
       * 
       * * year&#39;s week, from monday to sunday, if a date has been specified in the
       * workDays constraint
       * 
       * * days 1 to 7 are the days of the first week and the second week start on
       * day 8 if no date has been specified in the workDays constraint. No over
       * work with regard to the weekly work duration is allowed.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default: : ** &quot;168:00:00&quot;.
     *
     * @return string
     */
    public function getWeeklyWorkTime()
    {
        return $this->weeklyWorkTime;
    }

    /**
     * The maximum resource work duration over a week.
       * 
       * Use this constraint to specify the maximum weekly work duration. Weeks
       * are defined as follows:
       * 
       * * year&#39;s week, from monday to sunday, if a date has been specified in the
       * workDays constraint
       * 
       * * days 1 to 7 are the days of the first week and the second week start on
       * day 8 if no date has been specified in the workDays constraint. No over
       * work with regard to the weekly work duration is allowed.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default: : ** &quot;168:00:00&quot;.
     *
     * @param string $weeklyWorkTime
     */
    public function setWeeklyWorkTime($weeklyWorkTime)
    {
        $this->weeklyWorkTime = $weeklyWorkTime;
    }
    /**
     * The end time of a resource work time window.
       * 
       * Use this constraint to specify the time at which the tour must be over or
       * the daily work duration.
       * 
       * * If the optimumStartTime parameter is set to True and the dailyWorkTime
       * or weeklyWorkTime constraint value is set by user, the tour cannot finish
       * later than the value of the workEndTime parameter, whatever overtime may
       * be allowed by the overtime1_Duration and overtime2_Duration constraints.
       * 
       * * If the optimumStartTime parameter is set to True and the dailyWorkTime
       * constraint value is not set, the end time of the tour can be adjusted to
       * match the begining of the work time window. In this case, this parameter
       * is used only to compute the resource daily work time and the tour can
       * finish at midnight.
       * 
       * * If the optimumStartTime parameter is set to False, then this parameter
       * is used to compute the resource daily work time and the tour can finish
       * no later than the specified end time plus the values of the first
       * overtime duration and the second overtime duration constraints. If the
       * daily work duration is specified by the workEndTime constraint&#39;s value,
       * then it is equal to workEndTime minus workStartTime and lunchDuration.
       * 
       * **Example : ** For a vehicle to work for 6 hours between 7PM and 7AM, set
       * 
       * * optimumStartTime=True
       * 
       * * dailyWorkTime=&quot;06:00:00&quot;
       * 
       * * workStartTime=&quot;07:00:00&quot;
       * 
       * * workEndTime=&quot;19:00:00&quot;
       * 
       * For a vehicle to work for 8 hour between 8PM and 5AM with a one-hour
       * break at 12:30, set
       * 
       * * workStartTime=&quot;08:00:00&quot;
       * 
       * * workEndTime=&quot;17:00:00&quot;
       * 
       * * lunchDuration=&quot;01:00:00&quot;
       * 
       * * lunchTime=&quot;12:30:00&quot;
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default: : ** &quot;24:00:00&quot;.
     *
     * @return string
     */
    public function getWorkEndTime()
    {
        return $this->workEndTime;
    }

    /**
     * The end time of a resource work time window.
       * 
       * Use this constraint to specify the time at which the tour must be over or
       * the daily work duration.
       * 
       * * If the optimumStartTime parameter is set to True and the dailyWorkTime
       * or weeklyWorkTime constraint value is set by user, the tour cannot finish
       * later than the value of the workEndTime parameter, whatever overtime may
       * be allowed by the overtime1_Duration and overtime2_Duration constraints.
       * 
       * * If the optimumStartTime parameter is set to True and the dailyWorkTime
       * constraint value is not set, the end time of the tour can be adjusted to
       * match the begining of the work time window. In this case, this parameter
       * is used only to compute the resource daily work time and the tour can
       * finish at midnight.
       * 
       * * If the optimumStartTime parameter is set to False, then this parameter
       * is used to compute the resource daily work time and the tour can finish
       * no later than the specified end time plus the values of the first
       * overtime duration and the second overtime duration constraints. If the
       * daily work duration is specified by the workEndTime constraint&#39;s value,
       * then it is equal to workEndTime minus workStartTime and lunchDuration.
       * 
       * **Example : ** For a vehicle to work for 6 hours between 7PM and 7AM, set
       * 
       * * optimumStartTime=True
       * 
       * * dailyWorkTime=&quot;06:00:00&quot;
       * 
       * * workStartTime=&quot;07:00:00&quot;
       * 
       * * workEndTime=&quot;19:00:00&quot;
       * 
       * For a vehicle to work for 8 hour between 8PM and 5AM with a one-hour
       * break at 12:30, set
       * 
       * * workStartTime=&quot;08:00:00&quot;
       * 
       * * workEndTime=&quot;17:00:00&quot;
       * 
       * * lunchDuration=&quot;01:00:00&quot;
       * 
       * * lunchTime=&quot;12:30:00&quot;
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default: : ** &quot;24:00:00&quot;.
     *
     * @param string $workEndTime
     */
    public function setWorkEndTime($workEndTime)
    {
        $this->workEndTime = $workEndTime;
    }
    /**
     * The resource&#39;s work days. Use this constraint to specify the days a
       * resource works in the planning period. This constraint is linked with the
       * orders possible visit days constraints of Orders object elements and with
       * the depot days of opening constraints of Depots object elements. Thus,
       * customers and resources must have matching days for deliveries to be
       * possible, and depots must be opened on resources working days to be used.
       * A maximum of 64 days can be defined as work days. Working days can be
       * written as integers (1,2...) or dates (14/05/2010, 15/05/2010, ...). If
       * you are using dates, the oldest date in the workDays constraint defines
       * day 1.
       * 
       * **Type : ** string values containing days separated with commas (like &quot;1,
       * 2, 5&quot; or &quot;14/05/2010, 15/05/2010, 18/05/2010&quot; to specify day 1, day 2 and
       * day 5) or intervals (like &quot;1-10&quot;, &quot;2=&gt;5&quot; or &quot;14/05/2010=&gt;24/05/2010&quot;)
       * where 1 (or 14/05/2010) is the first day of the planning period. For day
       * intervals, prefer the &quot;=&gt;&quot; separator. Be careful, if the separator of
       * date is - then &quot;1-5&quot; corresponds to May 1st of the current year. If you
       * mix integer and date formats, beware that day 1 will all the same be
       * defined by the oldest available date.
       * 
       * **Default: : ** &quot;1&quot;.
       * 
       * **Example : **
       * 
       * You can define a single working day: Specify &quot;1&quot;, &quot;3&quot; or &quot;10&quot; for the
       * resource to work on day 1, day 3 or day 10 of the planning period. You
       * can also define working periods. Specify &quot;1-5&quot; or &quot;1=&gt;5&quot; or
       * &quot;14/05/2010=&gt;18/05/2010&quot; for the resource to work on a 5-days period
       * (from day 1 to day 5 included).
       * 
       * You can also mix single day and periods. Specify &quot;1, 3=&gt;5&quot; for the
       * resource to work on day 1 and from day 3 to 5 of the planning period.
     *
     * @return string
     */
    public function getWorkingDays()
    {
        return $this->workingDays;
    }

    /**
     * The resource&#39;s work days. Use this constraint to specify the days a
       * resource works in the planning period. This constraint is linked with the
       * orders possible visit days constraints of Orders object elements and with
       * the depot days of opening constraints of Depots object elements. Thus,
       * customers and resources must have matching days for deliveries to be
       * possible, and depots must be opened on resources working days to be used.
       * A maximum of 64 days can be defined as work days. Working days can be
       * written as integers (1,2...) or dates (14/05/2010, 15/05/2010, ...). If
       * you are using dates, the oldest date in the workDays constraint defines
       * day 1.
       * 
       * **Type : ** string values containing days separated with commas (like &quot;1,
       * 2, 5&quot; or &quot;14/05/2010, 15/05/2010, 18/05/2010&quot; to specify day 1, day 2 and
       * day 5) or intervals (like &quot;1-10&quot;, &quot;2=&gt;5&quot; or &quot;14/05/2010=&gt;24/05/2010&quot;)
       * where 1 (or 14/05/2010) is the first day of the planning period. For day
       * intervals, prefer the &quot;=&gt;&quot; separator. Be careful, if the separator of
       * date is - then &quot;1-5&quot; corresponds to May 1st of the current year. If you
       * mix integer and date formats, beware that day 1 will all the same be
       * defined by the oldest available date.
       * 
       * **Default: : ** &quot;1&quot;.
       * 
       * **Example : **
       * 
       * You can define a single working day: Specify &quot;1&quot;, &quot;3&quot; or &quot;10&quot; for the
       * resource to work on day 1, day 3 or day 10 of the planning period. You
       * can also define working periods. Specify &quot;1-5&quot; or &quot;1=&gt;5&quot; or
       * &quot;14/05/2010=&gt;18/05/2010&quot; for the resource to work on a 5-days period
       * (from day 1 to day 5 included).
       * 
       * You can also mix single day and periods. Specify &quot;1, 3=&gt;5&quot; for the
       * resource to work on day 1 and from day 3 to 5 of the planning period.
     *
     * @param string $workingDays
     */
    public function setWorkingDays($workingDays)
    {
        $this->workingDays = $workingDays;
    }
    /**
     * The cost of a resource working for an hour.
       * 
       * Use this constraint to specify the resource wages when working for an
       * hour.
       * 
       * **Type : ** float. **Default: : ** 9.
       * 
       * **Example : **
       * 
       * If workPenalty = 10 (euros per hour) and daily work time is about 8
       * hours, the total daily work cost is 10 * 8 = 80 euros.
     *
     * @return double
     */
    public function getWorkPenalty()
    {
        return $this->workPenalty;
    }

    /**
     * The cost of a resource working for an hour.
       * 
       * Use this constraint to specify the resource wages when working for an
       * hour.
       * 
       * **Type : ** float. **Default: : ** 9.
       * 
       * **Example : **
       * 
       * If workPenalty = 10 (euros per hour) and daily work time is about 8
       * hours, the total daily work cost is 10 * 8 = 80 euros.
     *
     * @param double $workPenalty
     */
    public function setWorkPenalty($workPenalty)
    {
        $this->workPenalty = $workPenalty;
    }
    /**
     * The start time of the resource work time window.
       * 
       * Use this constraint to specify the time at which the tour must start.
       * This time can be adjusted using the optimumStartTime parameter.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default: : ** &quot;00:00:00&quot;.
     *
     * @return string
     */
    public function getWorkStartTime()
    {
        return $this->workStartTime;
    }

    /**
     * The start time of the resource work time window.
       * 
       * Use this constraint to specify the time at which the tour must start.
       * This time can be adjusted using the optimumStartTime parameter.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default: : ** &quot;00:00:00&quot;.
     *
     * @param string $workStartTime
     */
    public function setWorkStartTime($workStartTime)
    {
        $this->workStartTime = $workStartTime;
    }
    /**
     * longitude of resource start (and arrival if no endX provided)
     *
     * @return double
     */
    public function getStartX()
    {
        return $this->startX;
    }

    /**
     * longitude of resource start (and arrival if no endX provided)
     *
     * @param double $startX
     */
    public function setStartX($startX)
    {
        $this->startX = $startX;
    }
    /**
     * longitude of resource arrival
       * 
       * Specify it only if arrival and start are not the same.
     *
     * @return double
     */
    public function getEndX()
    {
        return $this->endX;
    }

    /**
     * longitude of resource arrival
       * 
       * Specify it only if arrival and start are not the same.
     *
     * @param double $endX
     */
    public function setEndX($endX)
    {
        $this->endX = $endX;
    }
    /**
     * latitude of resource start (and arrival if no endY provided)
     *
     * @return double
     */
    public function getStartY()
    {
        return $this->startY;
    }

    /**
     * latitude of resource start (and arrival if no endY provided)
     *
     * @param double $startY
     */
    public function setStartY($startY)
    {
        $this->startY = $startY;
    }
    /**
     * latitude of resource arrival
       * 
       * Specify it only if arrival and start are not the same.
     *
     * @return double
     */
    public function getEndY()
    {
        return $this->endY;
    }

    /**
     * latitude of resource arrival
       * 
       * Specify it only if arrival and start are not the same.
     *
     * @param double $endY
     */
    public function setEndY($endY)
    {
        $this->endY = $endY;
    }
    /**
     * The cost for a resource of driving for one distance unit.
       * 
       * Use this constraint to specify the average resource taxes (gazoline,
       * wear,...) when driving one distance unit.
       * 
       * **Type : ** float **Default : ** 1.5
       * 
       * **Example : ** if travelPenalty = 0.5 (euro per distance unit) and the
       * driven distance is about 100 unit (km or miles), the total distance cost
       * is 0,5 * 100 = 50 euros.
     *
     * @return double
     */
    public function getTravelPenalty()
    {
        return $this->travelPenalty;
    }

    /**
     * The cost for a resource of driving for one distance unit.
       * 
       * Use this constraint to specify the average resource taxes (gazoline,
       * wear,...) when driving one distance unit.
       * 
       * **Type : ** float **Default : ** 1.5
       * 
       * **Example : ** if travelPenalty = 0.5 (euro per distance unit) and the
       * driven distance is about 100 unit (km or miles), the total distance cost
       * is 0,5 * 100 = 50 euros.
     *
     * @param double $travelPenalty
     */
    public function setTravelPenalty($travelPenalty)
    {
        $this->travelPenalty = $travelPenalty;
    }
    /**
     * Value for minimum quantity to deliver.
       * 
       * If the resource has a non null minimum quantity to deliver constraint
       * value, the resource can visit on order only if the quantity to be
       * picked-up or delivered at this order is higher than the constraint value.
       * 
       * *Example : *
       * 
       * * set order *quantity* to 3 and resource *minimumQuantity* to 2 :
       * resource might visit the order
       * 
       * * set order *quantity* to 3 and resource *minimumQuantity* to 5 :
       * resource can not visit the order
       * 
       * **Type : ** float
     *
     * @return double
     */
    public function getMinimumQuantity()
    {
        return $this->minimumQuantity;
    }

    /**
     * Value for minimum quantity to deliver.
       * 
       * If the resource has a non null minimum quantity to deliver constraint
       * value, the resource can visit on order only if the quantity to be
       * picked-up or delivered at this order is higher than the constraint value.
       * 
       * *Example : *
       * 
       * * set order *quantity* to 3 and resource *minimumQuantity* to 2 :
       * resource might visit the order
       * 
       * * set order *quantity* to 3 and resource *minimumQuantity* to 5 :
       * resource can not visit the order
       * 
       * **Type : ** float
     *
     * @param double $minimumQuantity
     */
    public function setMinimumQuantity($minimumQuantity)
    {
        $this->minimumQuantity = $minimumQuantity;
    }
    /**
     * The fixed time needed for the resource to deliver/pick-up at the
       * customer&#39;s place.
       * 
       * This fixed resource&#39;s unloading duration is added to the resource&#39;s
       * unloading duration depending on the quantity to deliver/pick-up and to
       * the order&#39;s unloading duration depending on the quantity to
       * deliver/pick-up. See also tsResource unloadingDurationPerUnit and tsOrder
       * unloadingDurationPerUnit. **Example : **
       * 
       * * Set tsOrderQuantity to 3.
       * 
       * * Set tsOrder unloadingDurationPerUnit to 2 mn and tsResource
       * fixedUnloadingDuration and tsResource unloadingPerUnit to 0 or empty: the
       * variable part of the order is 6 mn
       * 
       * * Set tsOrder unloadingDurationPerUnit to 2 mn and tsResource
       * fixedUnloadingDuration to 10 mn and tsResource unloadingPerUnit to 0 or
       * empty: the variable part of the order is 10 mn
       * 
       * * Set tsOrder unloadingDurationPerUnit to 2 mn and tsResource
       * fixedUnloadingDuration empty and tsResource unloadingPerUnit to 1 mn: the
       * variable part of the order is 3 mn
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** &quot;&quot;
       * 
       * **Warning : ** the fixed/per unit unloading duration for resource is not
       * compatible with the orders constraints: partition and whole visit in time
       * window. Hence if one of the constraint at least tsResource
       * fixedUnloadingDuration and tsResource unloadingDurationPerUnit is non
       * null, partition and whole visit in time window are disabled.
     *
     * @return string
     */
    public function getFixedUnloadingDuration()
    {
        return $this->fixedUnloadingDuration;
    }

    /**
     * The fixed time needed for the resource to deliver/pick-up at the
       * customer&#39;s place.
       * 
       * This fixed resource&#39;s unloading duration is added to the resource&#39;s
       * unloading duration depending on the quantity to deliver/pick-up and to
       * the order&#39;s unloading duration depending on the quantity to
       * deliver/pick-up. See also tsResource unloadingDurationPerUnit and tsOrder
       * unloadingDurationPerUnit. **Example : **
       * 
       * * Set tsOrderQuantity to 3.
       * 
       * * Set tsOrder unloadingDurationPerUnit to 2 mn and tsResource
       * fixedUnloadingDuration and tsResource unloadingPerUnit to 0 or empty: the
       * variable part of the order is 6 mn
       * 
       * * Set tsOrder unloadingDurationPerUnit to 2 mn and tsResource
       * fixedUnloadingDuration to 10 mn and tsResource unloadingPerUnit to 0 or
       * empty: the variable part of the order is 10 mn
       * 
       * * Set tsOrder unloadingDurationPerUnit to 2 mn and tsResource
       * fixedUnloadingDuration empty and tsResource unloadingPerUnit to 1 mn: the
       * variable part of the order is 3 mn
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** &quot;&quot;
       * 
       * **Warning : ** the fixed/per unit unloading duration for resource is not
       * compatible with the orders constraints: partition and whole visit in time
       * window. Hence if one of the constraint at least tsResource
       * fixedUnloadingDuration and tsResource unloadingDurationPerUnit is non
       * null, partition and whole visit in time window are disabled.
     *
     * @param string $fixedUnloadingDuration
     */
    public function setFixedUnloadingDuration($fixedUnloadingDuration)
    {
        $this->fixedUnloadingDuration = $fixedUnloadingDuration;
    }
    /**
     * the time needed to the resource to deliver/pick-up one unit of product at
       * the customer&#39;s place.
       * 
       * This resource&#39;s duration is added to the fixed resource&#39;s unloading
       * duration and to the order&#39;s unloading duration depending on quantity to
       * deliver/pick-up. See also tsResource fixedUnloadingDuration and tsOrder
       * unloadingDurationPerUnit.
       * 
       * **Example : **
       * 
       * * Set tsOrderQuantity to 3.
       * 
       * * Set tsOrder unloadingDurationPerUnit to 2 mn and tsResource
       * fixedUnloadingDuration and tsResource unloadingPerUnit to 0 or empty: the
       * variable part of the order is 6 mn
       * 
       * * Set tsOrder unloadingDurationPerUnit to 2 mn and tsResource
       * fixedUnloadingDuration to 10 mn and tsResource unloadingPerUnit to 0 or
       * empty: the variable part of the order is 10 mn
       * 
       * * Set tsOrder unloadingDurationPerUnit to 2 mn and tsResource
       * fixedUnloadingDuration empty and tsResource unloadingPerUnit to 1 mn: the
       * variable part of the order is 3 mn
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime.
     *
     * @return string
     */
    public function getUnloadingDurationPerUnit()
    {
        return $this->unloadingDurationPerUnit;
    }

    /**
     * the time needed to the resource to deliver/pick-up one unit of product at
       * the customer&#39;s place.
       * 
       * This resource&#39;s duration is added to the fixed resource&#39;s unloading
       * duration and to the order&#39;s unloading duration depending on quantity to
       * deliver/pick-up. See also tsResource fixedUnloadingDuration and tsOrder
       * unloadingDurationPerUnit.
       * 
       * **Example : **
       * 
       * * Set tsOrderQuantity to 3.
       * 
       * * Set tsOrder unloadingDurationPerUnit to 2 mn and tsResource
       * fixedUnloadingDuration and tsResource unloadingPerUnit to 0 or empty: the
       * variable part of the order is 6 mn
       * 
       * * Set tsOrder unloadingDurationPerUnit to 2 mn and tsResource
       * fixedUnloadingDuration to 10 mn and tsResource unloadingPerUnit to 0 or
       * empty: the variable part of the order is 10 mn
       * 
       * * Set tsOrder unloadingDurationPerUnit to 2 mn and tsResource
       * fixedUnloadingDuration empty and tsResource unloadingPerUnit to 1 mn: the
       * variable part of the order is 3 mn
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime.
     *
     * @param string $unloadingDurationPerUnit
     */
    public function setUnloadingDurationPerUnit($unloadingDurationPerUnit)
    {
        $this->unloadingDurationPerUnit = $unloadingDurationPerUnit;
    }
    /**
     * Value for maximum number of reloads per day.
     *
     * @return integer
     */
    public function getMaximumReloads()
    {
        return $this->maximumReloads;
    }

    /**
     * Value for maximum number of reloads per day.
     *
     * @param integer $maximumReloads
     */
    public function setMaximumReloads($maximumReloads)
    {
        $this->maximumReloads = $maximumReloads;
    }
    /**
     * Value of the penalty if the resource exceeds the maximum number of
       * reloads per day.
       * 
       * If the resource exceeds the maximum number of reloads per day, it will be
       * penalized by the maximum reloads penalty multiplied by the number of
       * reloads&#39; overtaking. The default value is 1024 if the constraint
       * maximumReloads is set. See also maximumReloads.
     *
     * @return double
     */
    public function getMaximumReloadsPenalty()
    {
        return $this->maximumReloadsPenalty;
    }

    /**
     * Value of the penalty if the resource exceeds the maximum number of
       * reloads per day.
       * 
       * If the resource exceeds the maximum number of reloads per day, it will be
       * penalized by the maximum reloads penalty multiplied by the number of
       * reloads&#39; overtaking. The default value is 1024 if the constraint
       * maximumReloads is set. See also maximumReloads.
     *
     * @param double $maximumReloadsPenalty
     */
    public function setMaximumReloadsPenalty($maximumReloadsPenalty)
    {
        $this->maximumReloadsPenalty = $maximumReloadsPenalty;
    }
    /**
     * Constraint providing resource to reload at depot during a tour.
       * 
       * If none of the constraints loadBeforeDeparture and loadOnReturn is
       * activated, the resource is never loading at depot. If one of these
       * constraint is activated the resource is loading once per tour, either at
       * the beginning of the tour or at the end of it. If both constraints are
       * activated then the resource is loading twice a tour, at the beginning and
       * at the end.
       * 
       * With standard solver only : solver always works with solution cost
       * comparison, so it may allow reloads even if you set noReload to true if
       * the solution cost is really lower. The only way to totally prevent
       * reloads is to set fixedLoadingDuration to a very long duration (20:00:00
       * for instance). The solver will warn you about this long duration but will
       * not add reloads to the tours. Caution : Don&#39;t do this if you are using
       * loadOnReturn or loadBeforeDeparture
       * 
       * **Default : ** False
     *
     * @return boolean
     */
    public function getNoReload()
    {
        return $this->noReload;
    }

    /**
     * Constraint providing resource to reload at depot during a tour.
       * 
       * If none of the constraints loadBeforeDeparture and loadOnReturn is
       * activated, the resource is never loading at depot. If one of these
       * constraint is activated the resource is loading once per tour, either at
       * the beginning of the tour or at the end of it. If both constraints are
       * activated then the resource is loading twice a tour, at the beginning and
       * at the end.
       * 
       * With standard solver only : solver always works with solution cost
       * comparison, so it may allow reloads even if you set noReload to true if
       * the solution cost is really lower. The only way to totally prevent
       * reloads is to set fixedLoadingDuration to a very long duration (20:00:00
       * for instance). The solver will warn you about this long duration but will
       * not add reloads to the tours. Caution : Don&#39;t do this if you are using
       * loadOnReturn or loadBeforeDeparture
       * 
       * **Default : ** False
     *
     * @param boolean $noReload
     */
    public function setNoReload($noReload)
    {
        $this->noReload = $noReload;
    }
    /**
     * The start time of the resource work time window for the &quot;other working
       * days&quot; (see otherWorkDaysList).
       * 
       * If you defined other working days, use this constraint to specify the
       * time at which the tour must start. These times can be adjusted using the
       * optimumStartTime parameter.
       * 
       * You can define up to 3 different start times here, corresponding to the
       * different &quot;other working days&quot; slots.
       * 
       * **Type : ** List of &quot;hh:mm:ss&quot;, DateTime. **Example : **
       * [&quot;08:00:00&quot;,&quot;09:00:00]
     *
     * @return string[]
     */
    public function getOtherWorkStartTimes()
    {
        return $this->otherWorkStartTimes;
    }

    /**
     * The start time of the resource work time window for the &quot;other working
       * days&quot; (see otherWorkDaysList).
       * 
       * If you defined other working days, use this constraint to specify the
       * time at which the tour must start. These times can be adjusted using the
       * optimumStartTime parameter.
       * 
       * You can define up to 3 different start times here, corresponding to the
       * different &quot;other working days&quot; slots.
       * 
       * **Type : ** List of &quot;hh:mm:ss&quot;, DateTime. **Example : **
       * [&quot;08:00:00&quot;,&quot;09:00:00]
     *
     * @param string[] $otherWorkStartTimes
     */
    public function setOtherWorkStartTimes($otherWorkStartTimes)
    {
        $this->otherWorkStartTimes = $otherWorkStartTimes;
    }
    /**
     * The end time of the resource work time window for the &quot;other working
       * days&quot; (see otherWorkDaysList).
       * 
       * If you defined other working days, use this constraint to specify the
       * time at which the tour must end. These times can be adjusted using the
       * optimumStartTime parameter.
       * 
       * You can define up to 3 different end times here, corresponding to the
       * different &quot;other working days&quot; slots.
       * 
       * **Type : ** List of &quot;hh:mm:ss&quot;, DateTime. **Example : **
       * [&quot;18:00:00&quot;,&quot;19:00:00]
     *
     * @return string[]
     */
    public function getOtherWorkEndTimes()
    {
        return $this->otherWorkEndTimes;
    }

    /**
     * The end time of the resource work time window for the &quot;other working
       * days&quot; (see otherWorkDaysList).
       * 
       * If you defined other working days, use this constraint to specify the
       * time at which the tour must end. These times can be adjusted using the
       * optimumStartTime parameter.
       * 
       * You can define up to 3 different end times here, corresponding to the
       * different &quot;other working days&quot; slots.
       * 
       * **Type : ** List of &quot;hh:mm:ss&quot;, DateTime. **Example : **
       * [&quot;18:00:00&quot;,&quot;19:00:00]
     *
     * @param string[] $otherWorkEndTimes
     */
    public function setOtherWorkEndTimes($otherWorkEndTimes)
    {
        $this->otherWorkEndTimes = $otherWorkEndTimes;
    }
    /**
     * Other working days (see workingDays)
       * 
       * You can define up to 3 different working days slots. If you do so, you
       * can then specify distinct work start and end times with
       * otherWorkStartTimes and otherWorkEndTimes.
       * 
       * **Type : ** List of string (see workingDays format) **Example : **
       * [&quot;2&quot;,&quot;3=&gt;5&quot;]
     *
     * @return string[]
     */
    public function getOtherWorkDaysList()
    {
        return $this->otherWorkDaysList;
    }

    /**
     * Other working days (see workingDays)
       * 
       * You can define up to 3 different working days slots. If you do so, you
       * can then specify distinct work start and end times with
       * otherWorkStartTimes and otherWorkEndTimes.
       * 
       * **Type : ** List of string (see workingDays format) **Example : **
       * [&quot;2&quot;,&quot;3=&gt;5&quot;]
     *
     * @param string[] $otherWorkDaysList
     */
    public function setOtherWorkDaysList($otherWorkDaysList)
    {
        $this->otherWorkDaysList = $otherWorkDaysList;
    }
    /**
     * The list of products provided by a resource.
       * 
       * This constraint is linked with tsDepot requiredProducts constraint: a
       * depot with a required product can only be visited by a resource providing
       * it.
       * 
       * **Type : ** string as a list of products separated with commas. **Default
       * : ** not used.
       * 
       * ** Example : ** Specify &quot;Oxygen&quot; in the resource can provide oxygen.
     *
     * @return string
     */
    public function getProvidedProducts()
    {
        return $this->providedProducts;
    }

    /**
     * The list of products provided by a resource.
       * 
       * This constraint is linked with tsDepot requiredProducts constraint: a
       * depot with a required product can only be visited by a resource providing
       * it.
       * 
       * **Type : ** string as a list of products separated with commas. **Default
       * : ** not used.
       * 
       * ** Example : ** Specify &quot;Oxygen&quot; in the resource can provide oxygen.
     *
     * @param string $providedProducts
     */
    public function setProvidedProducts($providedProducts)
    {
        $this->providedProducts = $providedProducts;
    }
    /**
     * Penalty value if the resource is used in the planning.
       * 
       * Use this constraint to specify the penalty if the resource is used at
       * least one day in the planning
       * 
       * **Type : ** float **Default : ** 0
     *
     * @return double
     */
    public function getUseInPlanningPenalty()
    {
        return $this->useInPlanningPenalty;
    }

    /**
     * Penalty value if the resource is used in the planning.
       * 
       * Use this constraint to specify the penalty if the resource is used at
       * least one day in the planning
       * 
       * **Type : ** float **Default : ** 0
     *
     * @param double $useInPlanningPenalty
     */
    public function setUseInPlanningPenalty($useInPlanningPenalty)
    {
        $this->useInPlanningPenalty = $useInPlanningPenalty;
    }
    /**
     * The maximum distance the resource should travel per day.
       * 
       * Use this constraint to specify the distance the resource should not
       * exceed in one day
       * 
       * **Type : ** integer **Default : ** -1 (no limit)
     *
     * @return integer
     */
    public function getMaximumDistance()
    {
        return $this->maximumDistance;
    }

    /**
     * The maximum distance the resource should travel per day.
       * 
       * Use this constraint to specify the distance the resource should not
       * exceed in one day
       * 
       * **Type : ** integer **Default : ** -1 (no limit)
     *
     * @param integer $maximumDistance
     */
    public function setMaximumDistance($maximumDistance)
    {
        $this->maximumDistance = $maximumDistance;
    }
    /**
     * The maximum number of visits the resource can perform in one day.
       * 
       * 
       * **Type : ** integer **Default : ** -1 (no limit) **Max : ** 2,147,483.
     *
     * @return integer
     */
    public function getMaximumVisits()
    {
        return $this->maximumVisits;
    }

    /**
     * The maximum number of visits the resource can perform in one day.
       * 
       * 
       * **Type : ** integer **Default : ** -1 (no limit) **Max : ** 2,147,483.
     *
     * @param integer $maximumVisits
     */
    public function setMaximumVisits($maximumVisits)
    {
        $this->maximumVisits = $maximumVisits;
    }
    /**
     * Mobile login to be specified only if you need to be able to export the
       * optimization result to operation planning from TsCloud GUI. If you
       * trigger operational planning export from the API, you will still need to
       * specify the mapping between resource name and login.
     *
     * @return string
     */
    public function getMobileLogin()
    {
        return $this->mobileLogin;
    }

    /**
     * Mobile login to be specified only if you need to be able to export the
       * optimization result to operation planning from TsCloud GUI. If you
       * trigger operational planning export from the API, you will still need to
       * specify the mapping between resource name and login.
     *
     * @param string $mobileLogin
     */
    public function setMobileLogin($mobileLogin)
    {
        $this->mobileLogin = $mobileLogin;
    }
    /**
     * Determines if both global capacity and capacities per product should be
       * considered in the optimization or only global capacity.
       * 
       * **Type : ** Boolean **Default : ** False
       * 
       * ** Example : ** Set globalCapacity = 15 and useAllCapacities = False. The
       * global capacity only is considered: the vehicle can carry 15 quantities
       * of products, whatever product is to be carried.
     *
     * @return boolean
     */
    public function getUseAllCapacities()
    {
        return $this->useAllCapacities;
    }

    /**
     * Determines if both global capacity and capacities per product should be
       * considered in the optimization or only global capacity.
       * 
       * **Type : ** Boolean **Default : ** False
       * 
       * ** Example : ** Set globalCapacity = 15 and useAllCapacities = False. The
       * global capacity only is considered: the vehicle can carry 15 quantities
       * of products, whatever product is to be carried.
     *
     * @param boolean $useAllCapacities
     */
    public function setUseAllCapacities($useAllCapacities)
    {
        $this->useAllCapacities = $useAllCapacities;
    }
    /**
     * Global capacity for a resource. This constraint unables to set a maximum
       * capacity on a resource, whatever product is carried. If both global
       * capacity and capacity per product are to be used, set True for the value
       * of *useAllCapacities*.
       * 
       * **Type : ** Float **Default : ** None **Max : ** 2,147,483.
       * 
       * ** Example : ** Set globalCapacity = 15 and useAllCapacities = False. The
       * global capacity only is considered: the vehicle can carry 15 quantities
       * of products, whatever product is to be carried.
     *
     * @return double
     */
    public function getGlobalCapacity()
    {
        return $this->globalCapacity;
    }

    /**
     * Global capacity for a resource. This constraint unables to set a maximum
       * capacity on a resource, whatever product is carried. If both global
       * capacity and capacity per product are to be used, set True for the value
       * of *useAllCapacities*.
       * 
       * **Type : ** Float **Default : ** None **Max : ** 2,147,483.
       * 
       * ** Example : ** Set globalCapacity = 15 and useAllCapacities = False. The
       * global capacity only is considered: the vehicle can carry 15 quantities
       * of products, whatever product is to be carried.
     *
     * @param double $globalCapacity
     */
    public function setGlobalCapacity($globalCapacity)
    {
        $this->globalCapacity = $globalCapacity;
    }
    /**
     * Name of TSOrder customData that will contain the TSOrder type used for
       * additional cost computation (see toursResult object)
     *
     * @return string
     */
    public function getAdditionalCostOrderCustomDataName()
    {
        return $this->additionalCostOrderCustomDataName;
    }

    /**
     * Name of TSOrder customData that will contain the TSOrder type used for
       * additional cost computation (see toursResult object)
     *
     * @param string $additionalCostOrderCustomDataName
     */
    public function setAdditionalCostOrderCustomDataName($additionalCostOrderCustomDataName)
    {
        $this->additionalCostOrderCustomDataName = $additionalCostOrderCustomDataName;
    }
    /**
     * Operator used to compute additional cost (see toursResult object)
       * 
       * Possible values are :
       * 
       * * SUM : tour additional cost will be the sum of additional costs of
       * planned orders
       * 
       * * MAX : tour additional cost will be the maximum value of additional
       * costs of planned orders
       * 
       * * MIN : tour additional cost will be the minimum value of additional
       * costs of planned orders
       * 
       * * AVERAGE : tour additional cost will be the average of additional costs
       * of planned orders
     *
     * @return string
     */
    public function getAdditionalCostOperator()
    {
        return $this->additionalCostOperator;
    }

    /**
     * Operator used to compute additional cost (see toursResult object)
       * 
       * Possible values are :
       * 
       * * SUM : tour additional cost will be the sum of additional costs of
       * planned orders
       * 
       * * MAX : tour additional cost will be the maximum value of additional
       * costs of planned orders
       * 
       * * MIN : tour additional cost will be the minimum value of additional
       * costs of planned orders
       * 
       * * AVERAGE : tour additional cost will be the average of additional costs
       * of planned orders
     *
     * @param string $additionalCostOperator
     */
    public function setAdditionalCostOperator($additionalCostOperator)
    {
        $this->additionalCostOperator = $additionalCostOperator;
    }
    /**
     * List of additional cost (cost per order type)
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSAdditionalCost[]
     */
    public function getAdditionalCosts()
    {
        return $this->additionalCosts;
    }

    /**
     * List of additional cost (cost per order type)
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSAdditionalCost[] $additionalCosts
     */
    public function setAdditionalCosts($additionalCosts)
    {
        $this->additionalCosts = $additionalCosts;
    }
    /**
     * (no documentation provided)
     *
     * @return boolean
     */
    public function getOpenTimeStart()
    {
        return $this->openTimeStart;
    }

    /**
     * (no documentation provided)
     *
     * @param boolean $openTimeStart
     */
    public function setOpenTimeStart($openTimeStart)
    {
        $this->openTimeStart = $openTimeStart;
    }
    /**
     * (no documentation provided)
     *
     * @return boolean
     */
    public function getOpenDistanceStart()
    {
        return $this->openDistanceStart;
    }

    /**
     * (no documentation provided)
     *
     * @param boolean $openDistanceStart
     */
    public function setOpenDistanceStart($openDistanceStart)
    {
        $this->openDistanceStart = $openDistanceStart;
    }
    /**
     * (no documentation provided)
     *
     * @return boolean
     */
    public function getOpenTimeStop()
    {
        return $this->openTimeStop;
    }

    /**
     * (no documentation provided)
     *
     * @param boolean $openTimeStop
     */
    public function setOpenTimeStop($openTimeStop)
    {
        $this->openTimeStop = $openTimeStop;
    }
    /**
     * (no documentation provided)
     *
     * @return boolean
     */
    public function getOpenDistanceStop()
    {
        return $this->openDistanceStop;
    }

    /**
     * (no documentation provided)
     *
     * @param boolean $openDistanceStop
     */
    public function setOpenDistanceStop($openDistanceStop)
    {
        $this->openDistanceStop = $openDistanceStop;
    }
    /**
     * (no documentation provided)
     *
     * @return boolean
     */
    public function getTomTomWebFleetEnabled()
    {
        return $this->tomTomWebFleetEnabled;
    }

    /**
     * (no documentation provided)
     *
     * @param boolean $tomTomWebFleetEnabled
     */
    public function setTomTomWebFleetEnabled($tomTomWebFleetEnabled)
    {
        $this->tomTomWebFleetEnabled = $tomTomWebFleetEnabled;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getTomTomWebFleetIdentifier()
    {
        return $this->tomTomWebFleetIdentifier;
    }

    /**
     * (no documentation provided)
     *
     * @param string $tomTomWebFleetIdentifier
     */
    public function setTomTomWebFleetIdentifier($tomTomWebFleetIdentifier)
    {
        $this->tomTomWebFleetIdentifier = $tomTomWebFleetIdentifier;
    }
    /**
     * Vehicles regulations.
       * 
       * Possible values are :
       * 
       * * bicycle
       * 
       * * bus
       * 
       * * car
       * 
       * * deliveryIntermediateVehicle
       * 
       * * deliveryLightCommercialVehicle
       * 
       * * emergencyTruck
       * 
       * * emergencyVehicle
       * 
       * * intermediateVehicle
       * 
       * * lightCommercialVehicle
       * 
       * * pedestrian
       * 
       * * taxi
       * 
       * * truck
       * 
       * If not specified, vehicle type defined in UI will be used
       * 
       * Only new solver can handle optimization with several types of vehicle. If
       * you use standard solver, you should specify the vehicle code only in the
       * options object.
     *
     * @return string
     */
    public function getVehicleCode()
    {
        return $this->vehicleCode;
    }

    /**
     * Vehicles regulations.
       * 
       * Possible values are :
       * 
       * * bicycle
       * 
       * * bus
       * 
       * * car
       * 
       * * deliveryIntermediateVehicle
       * 
       * * deliveryLightCommercialVehicle
       * 
       * * emergencyTruck
       * 
       * * emergencyVehicle
       * 
       * * intermediateVehicle
       * 
       * * lightCommercialVehicle
       * 
       * * pedestrian
       * 
       * * taxi
       * 
       * * truck
       * 
       * If not specified, vehicle type defined in UI will be used
       * 
       * Only new solver can handle optimization with several types of vehicle. If
       * you use standard solver, you should specify the vehicle code only in the
       * options object.
     *
     * @param string $vehicleCode
     */
    public function setVehicleCode($vehicleCode)
    {
        $this->vehicleCode = $vehicleCode;
    }
    /**
     * Vehicles fuel type. Possible values are :
       * 
       * * diesel
       * 
       * * undefined
       * 
       * * unleaded
     *
     * @return string
     */
    public function getFuelCode()
    {
        return $this->fuelCode;
    }

    /**
     * Vehicles fuel type. Possible values are :
       * 
       * * diesel
       * 
       * * undefined
       * 
       * * unleaded
     *
     * @param string $fuelCode
     */
    public function setFuelCode($fuelCode)
    {
        $this->fuelCode = $fuelCode;
    }
    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Resource\DayOff[]
     */
    public function getDaysOff()
    {
        return $this->daysOff;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Resource\DayOff[] $daysOff
     */
    public function setDaysOff($daysOff)
    {
        $this->daysOff = $daysOff;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getAllowedNights()
    {
        return $this->allowedNights;
    }

    /**
     * (no documentation provided)
     *
     * @param string $allowedNights
     */
    public function setAllowedNights($allowedNights)
    {
        $this->allowedNights = $allowedNights;
    }
    /**
     * Parking time in seconds added to the travel time before each order (new engine only).
       * 
       * This parking time is applied only once for a group of aggregated orders.
     *
     * @return integer
     */
    public function getParkingTime()
    {
        return $this->parkingTime;
    }

    /**
     * Parking time in seconds added to the travel time before each order (new engine only).
       * 
       * This parking time is applied only once for a group of aggregated orders.
     *
     * @param integer $parkingTime
     */
    public function setParkingTime($parkingTime)
    {
        $this->parkingTime = $parkingTime;
    }

    /**
     * Sets a known child element of TSResource from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'available') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->available = $child;
            $happened = true;
        }
        else if (($xml->localName == 'avgConsumption') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->avgConsumption = $child;
            $happened = true;
        }
        else if (($xml->localName == 'briefingDuration') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->briefingDuration = $child;
            $happened = true;
        }
        else if (($xml->localName == 'capacities') && (empty($xml->namespaceURI)) && (!$xml->isEmptyElement)) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc. in the wrapper
                }
        if (($xml->localName == 'capacity') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->capacities)) {
                $this->capacities = array();
            }
            array_push($this->capacities, $child);
            $happened = true;
        }
                $xml->read();
            }
            $happened = true;
        }
        else if (($xml->localName == 'providedSkills') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->providedSkills = $child;
            $happened = true;
        }
        else if (($xml->localName == 'customDataMap') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->customDataMap = $child;
            $happened = true;
        }
        else if (($xml->localName == 'dailyWorkTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->dailyWorkTime = $child;
            $happened = true;
        }
        else if (($xml->localName == 'debriefingDuration') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->debriefingDuration = $child;
            $happened = true;
        }
        else if (($xml->localName == 'driveRestAtCustomer') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->driveRestAtCustomer = $child;
            $happened = true;
        }
        else if (($xml->localName == 'driveRestAtDepot') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->driveRestAtDepot = $child;
            $happened = true;
        }
        else if (($xml->localName == 'fixedLoadingDuration') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->fixedLoadingDuration = $child;
            $happened = true;
        }
        else if (($xml->localName == 'fuelType') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->fuelType = $child;
            $happened = true;
        }
        else if (($xml->localName == 'id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'legalDailyDriveDuration') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->legalDailyDriveDuration = $child;
            $happened = true;
        }
        else if (($xml->localName == 'legalDailyRestDuration') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->legalDailyRestDuration = $child;
            $happened = true;
        }
        else if (($xml->localName == 'legalDriveRestDuration') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->legalDriveRestDuration = $child;
            $happened = true;
        }
        else if (($xml->localName == 'legalMaxDriveDuration') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->legalMaxDriveDuration = $child;
            $happened = true;
        }
        else if (($xml->localName == 'legalMinRestDuration') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->legalMinRestDuration = $child;
            $happened = true;
        }
        else if (($xml->localName == 'loadBeforeDeparture') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->loadBeforeDeparture = $child;
            $happened = true;
        }
        else if (($xml->localName == 'loadingDurationPerUnit') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->loadingDurationPerUnit = $child;
            $happened = true;
        }
        else if (($xml->localName == 'loadOnReturn') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->loadOnReturn = $child;
            $happened = true;
        }
        else if (($xml->localName == 'lunch') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSPause($xml);
            $this->lunch = $child;
            $happened = true;
        }
        else if (($xml->localName == 'maxNightsOutPerJourney') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->maxNightsOutPerJourney = $child;
            $happened = true;
        }
        else if (($xml->localName == 'maxNightsOutPerWeek') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->maxNightsOutPerWeek = $child;
            $happened = true;
        }
        else if (($xml->localName == 'minDriveDuration') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->minDriveDuration = $child;
            $happened = true;
        }
        else if (($xml->localName == 'nightPenalty') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->nightPenalty = $child;
            $happened = true;
        }
        else if (($xml->localName == 'nonUsePenalty') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->nonUsePenalty = $child;
            $happened = true;
        }
        else if (($xml->localName == 'openStart') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->openStart = $child;
            $happened = true;
        }
        else if (($xml->localName == 'openStop') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->openStop = $child;
            $happened = true;
        }
        else if (($xml->localName == 'optimumStartTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->optimumStartTime = $child;
            $happened = true;
        }
        else if (($xml->localName == 'overnightMinDriving') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->overnightMinDriving = $child;
            $happened = true;
        }
        else if (($xml->localName == 'overtimeDurations') && (empty($xml->namespaceURI)) && (!$xml->isEmptyElement)) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc. in the wrapper
                }
        if (($xml->localName == 'overtimeDuration') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->overtimeDurations)) {
                $this->overtimeDurations = array();
            }
            array_push($this->overtimeDurations, $child);
            $happened = true;
        }
                $xml->read();
            }
            $happened = true;
        }
        else if (($xml->localName == 'overtimePenalties') && (empty($xml->namespaceURI)) && (!$xml->isEmptyElement)) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc. in the wrapper
                }
        if (($xml->localName == 'overtimePenalty') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->overtimePenalties)) {
                $this->overtimePenalties = array();
            }
            array_push($this->overtimePenalties, $child);
            $happened = true;
        }
                $xml->read();
            }
            $happened = true;
        }
        else if (($xml->localName == 'payWholeDay') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->payWholeDay = $child;
            $happened = true;
        }
        else if (($xml->localName == 'penaltyPerVisit') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->penaltyPerVisit = $child;
            $happened = true;
        }
        else if (($xml->localName == 'speedAdjustment') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->speedAdjustment = $child;
            $happened = true;
        }
        else if (($xml->localName == 'startTravelTimeModifier') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTravelTimeModifier($xml);
            $this->startTravelTimeModifier = $child;
            $happened = true;
        }
        else if (($xml->localName == 'stopTravelTimeModifier') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTravelTimeModifier($xml);
            $this->stopTravelTimeModifier = $child;
            $happened = true;
        }
        else if (($xml->localName == 'extraTravelPenalties') && (empty($xml->namespaceURI)) && (!$xml->isEmptyElement)) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc. in the wrapper
                }
        if (($xml->localName == 'extraTravelPenalty') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTravelPenalty($xml);
            if (!isset($this->extraTravelPenalties)) {
                $this->extraTravelPenalties = array();
            }
            array_push($this->extraTravelPenalties, $child);
            $happened = true;
        }
                $xml->read();
            }
            $happened = true;
        }
        else if (($xml->localName == 'travelTimeModifier') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTravelTimeModifier($xml);
            $this->travelTimeModifier = $child;
            $happened = true;
        }
        else if (($xml->localName == 'usePenalty') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->usePenalty = $child;
            $happened = true;
        }
        else if (($xml->localName == 'weeklyWorkTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->weeklyWorkTime = $child;
            $happened = true;
        }
        else if (($xml->localName == 'workEndTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->workEndTime = $child;
            $happened = true;
        }
        else if (($xml->localName == 'workingDays') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->workingDays = $child;
            $happened = true;
        }
        else if (($xml->localName == 'workPenalty') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->workPenalty = $child;
            $happened = true;
        }
        else if (($xml->localName == 'workStartTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->workStartTime = $child;
            $happened = true;
        }
        else if (($xml->localName == 'startX') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->startX = $child;
            $happened = true;
        }
        else if (($xml->localName == 'endX') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->endX = $child;
            $happened = true;
        }
        else if (($xml->localName == 'startY') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->startY = $child;
            $happened = true;
        }
        else if (($xml->localName == 'endY') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->endY = $child;
            $happened = true;
        }
        else if (($xml->localName == 'travelPenalty') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->travelPenalty = $child;
            $happened = true;
        }
        else if (($xml->localName == 'minimumQuantity') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->minimumQuantity = $child;
            $happened = true;
        }
        else if (($xml->localName == 'fixedUnloadingDuration') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->fixedUnloadingDuration = $child;
            $happened = true;
        }
        else if (($xml->localName == 'unloadingDurationPerUnit') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->unloadingDurationPerUnit = $child;
            $happened = true;
        }
        else if (($xml->localName == 'maximumReloads') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->maximumReloads = $child;
            $happened = true;
        }
        else if (($xml->localName == 'maximumReloadsPenalty') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->maximumReloadsPenalty = $child;
            $happened = true;
        }
        else if (($xml->localName == 'noReload') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->noReload = $child;
            $happened = true;
        }
        else if (($xml->localName == 'otherWorkStartTimes') && (empty($xml->namespaceURI)) && (!$xml->isEmptyElement)) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc. in the wrapper
                }
        if (($xml->localName == 'otherWorkStartTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->otherWorkStartTimes)) {
                $this->otherWorkStartTimes = array();
            }
            array_push($this->otherWorkStartTimes, $child);
            $happened = true;
        }
                $xml->read();
            }
            $happened = true;
        }
        else if (($xml->localName == 'otherWorkEndTimes') && (empty($xml->namespaceURI)) && (!$xml->isEmptyElement)) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc. in the wrapper
                }
        if (($xml->localName == 'otherWorkEndTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->otherWorkEndTimes)) {
                $this->otherWorkEndTimes = array();
            }
            array_push($this->otherWorkEndTimes, $child);
            $happened = true;
        }
                $xml->read();
            }
            $happened = true;
        }
        else if (($xml->localName == 'otherWorkingDays') && (empty($xml->namespaceURI)) && (!$xml->isEmptyElement)) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc. in the wrapper
                }
        if (($xml->localName == 'otherWorkingDay') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->otherWorkDaysList)) {
                $this->otherWorkDaysList = array();
            }
            array_push($this->otherWorkDaysList, $child);
            $happened = true;
        }
                $xml->read();
            }
            $happened = true;
        }
        else if (($xml->localName == 'providedProducts') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->providedProducts = $child;
            $happened = true;
        }
        else if (($xml->localName == 'useInPlanningPenalty') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->useInPlanningPenalty = $child;
            $happened = true;
        }
        else if (($xml->localName == 'maximumDistance') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->maximumDistance = $child;
            $happened = true;
        }
        else if (($xml->localName == 'maximumVisits') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->maximumVisits = $child;
            $happened = true;
        }
        else if (($xml->localName == 'mobileLogin') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->mobileLogin = $child;
            $happened = true;
        }
        else if (($xml->localName == 'useAllCapacities') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->useAllCapacities = $child;
            $happened = true;
        }
        else if (($xml->localName == 'globalCapacity') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->globalCapacity = $child;
            $happened = true;
        }
        else if (($xml->localName == 'additionalCostOrderCustomDataName') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->additionalCostOrderCustomDataName = $child;
            $happened = true;
        }
        else if (($xml->localName == 'additionalCostOperator') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->additionalCostOperator = $child;
            $happened = true;
        }
        else if (($xml->localName == 'additionalCosts') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSAdditionalCost($xml);
            if (!isset($this->additionalCosts)) {
                $this->additionalCosts = array();
            }
            array_push($this->additionalCosts, $child);
            $happened = true;
        }
        else if (($xml->localName == 'openTimeStart') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->openTimeStart = $child;
            $happened = true;
        }
        else if (($xml->localName == 'openDistanceStart') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->openDistanceStart = $child;
            $happened = true;
        }
        else if (($xml->localName == 'openTimeStop') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->openTimeStop = $child;
            $happened = true;
        }
        else if (($xml->localName == 'openDistanceStop') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->openDistanceStop = $child;
            $happened = true;
        }
        else if (($xml->localName == 'tomTomWebFleetEnabled') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->tomTomWebFleetEnabled = $child;
            $happened = true;
        }
        else if (($xml->localName == 'tomTomWebFleetIdentifier') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->tomTomWebFleetIdentifier = $child;
            $happened = true;
        }
        else if (($xml->localName == 'vehicleCode') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->vehicleCode = $child;
            $happened = true;
        }
        else if (($xml->localName == 'fuelCode') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->fuelCode = $child;
            $happened = true;
        }
        else if (($xml->localName == 'daysOff') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Resource\DayOff($xml);
            if (!isset($this->daysOff)) {
                $this->daysOff = array();
            }
            array_push($this->daysOff, $child);
            $happened = true;
        }
        else if (($xml->localName == 'allowedNights') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->allowedNights = $child;
            $happened = true;
        }
        else if (($xml->localName == 'parkingTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->parkingTime = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of TSResource from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes this TSResource to an XML writer.
     *
     * @param \XMLWriter $writer The XML writer.
     * @param bool $includeNamespaces Whether to write out the namespaces in the element.
     */
    public function toXml($writer, $includeNamespaces = true)
    {
        $writer->startElementNS(null, 'TSResource', null);
        $this->writeXmlContents($writer);
        $writer->endElement();
    }

    /**
     * Writes the contents of this TSResource to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->available) {
            $writer->startElementNs(null, 'available', null);
            $writer->text($this->available);
            $writer->endElement();
        }
        if ($this->avgConsumption) {
            $writer->startElementNs(null, 'avgConsumption', null);
            $writer->text($this->avgConsumption);
            $writer->endElement();
        }
        if ($this->briefingDuration) {
            $writer->startElementNs(null, 'briefingDuration', null);
            $writer->text($this->briefingDuration);
            $writer->endElement();
        }
        if ($this->capacities) {
            $writer->startElementNs(null, 'capacities', null);
            foreach ($this->capacities as $i => $x) {
                $writer->startElementNs(null, 'capacity', null);
                $writer->text($x);
                $writer->endElement();
            }
            $writer->endElement();
        }
        if ($this->providedSkills) {
            $writer->startElementNs(null, 'providedSkills', null);
            $writer->text($this->providedSkills);
            $writer->endElement();
        }
        if ($this->customDataMap) {
            $writer->startElementNs(null, 'customDataMap', null);
            $writer->text($this->customDataMap);
            $writer->endElement();
        }
        if ($this->dailyWorkTime) {
            $writer->startElementNs(null, 'dailyWorkTime', null);
            $writer->text($this->dailyWorkTime);
            $writer->endElement();
        }
        if ($this->debriefingDuration) {
            $writer->startElementNs(null, 'debriefingDuration', null);
            $writer->text($this->debriefingDuration);
            $writer->endElement();
        }
        if ($this->driveRestAtCustomer) {
            $writer->startElementNs(null, 'driveRestAtCustomer', null);
            $writer->text($this->driveRestAtCustomer);
            $writer->endElement();
        }
        if ($this->driveRestAtDepot) {
            $writer->startElementNs(null, 'driveRestAtDepot', null);
            $writer->text($this->driveRestAtDepot);
            $writer->endElement();
        }
        if ($this->fixedLoadingDuration) {
            $writer->startElementNs(null, 'fixedLoadingDuration', null);
            $writer->text($this->fixedLoadingDuration);
            $writer->endElement();
        }
        if ($this->fuelType) {
            $writer->startElementNs(null, 'fuelType', null);
            $writer->text($this->fuelType);
            $writer->endElement();
        }
        if ($this->id) {
            $writer->startElementNs(null, 'id', null);
            $writer->text($this->id);
            $writer->endElement();
        }
        if ($this->legalDailyDriveDuration) {
            $writer->startElementNs(null, 'legalDailyDriveDuration', null);
            $writer->text($this->legalDailyDriveDuration);
            $writer->endElement();
        }
        if ($this->legalDailyRestDuration) {
            $writer->startElementNs(null, 'legalDailyRestDuration', null);
            $writer->text($this->legalDailyRestDuration);
            $writer->endElement();
        }
        if ($this->legalDriveRestDuration) {
            $writer->startElementNs(null, 'legalDriveRestDuration', null);
            $writer->text($this->legalDriveRestDuration);
            $writer->endElement();
        }
        if ($this->legalMaxDriveDuration) {
            $writer->startElementNs(null, 'legalMaxDriveDuration', null);
            $writer->text($this->legalMaxDriveDuration);
            $writer->endElement();
        }
        if ($this->legalMinRestDuration) {
            $writer->startElementNs(null, 'legalMinRestDuration', null);
            $writer->text($this->legalMinRestDuration);
            $writer->endElement();
        }
        if ($this->loadBeforeDeparture) {
            $writer->startElementNs(null, 'loadBeforeDeparture', null);
            $writer->text($this->loadBeforeDeparture);
            $writer->endElement();
        }
        if ($this->loadingDurationPerUnit) {
            $writer->startElementNs(null, 'loadingDurationPerUnit', null);
            $writer->text($this->loadingDurationPerUnit);
            $writer->endElement();
        }
        if ($this->loadOnReturn) {
            $writer->startElementNs(null, 'loadOnReturn', null);
            $writer->text($this->loadOnReturn);
            $writer->endElement();
        }
        if ($this->lunch) {
            $writer->startElementNs(null, 'lunch', null);
            $this->lunch->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->maxNightsOutPerJourney) {
            $writer->startElementNs(null, 'maxNightsOutPerJourney', null);
            $writer->text($this->maxNightsOutPerJourney);
            $writer->endElement();
        }
        if ($this->maxNightsOutPerWeek) {
            $writer->startElementNs(null, 'maxNightsOutPerWeek', null);
            $writer->text($this->maxNightsOutPerWeek);
            $writer->endElement();
        }
        if ($this->minDriveDuration) {
            $writer->startElementNs(null, 'minDriveDuration', null);
            $writer->text($this->minDriveDuration);
            $writer->endElement();
        }
        if ($this->nightPenalty) {
            $writer->startElementNs(null, 'nightPenalty', null);
            $writer->text($this->nightPenalty);
            $writer->endElement();
        }
        if ($this->nonUsePenalty) {
            $writer->startElementNs(null, 'nonUsePenalty', null);
            $writer->text($this->nonUsePenalty);
            $writer->endElement();
        }
        if ($this->openStart) {
            $writer->startElementNs(null, 'openStart', null);
            $writer->text($this->openStart);
            $writer->endElement();
        }
        if ($this->openStop) {
            $writer->startElementNs(null, 'openStop', null);
            $writer->text($this->openStop);
            $writer->endElement();
        }
        if ($this->optimumStartTime) {
            $writer->startElementNs(null, 'optimumStartTime', null);
            $writer->text($this->optimumStartTime);
            $writer->endElement();
        }
        if ($this->overnightMinDriving) {
            $writer->startElementNs(null, 'overnightMinDriving', null);
            $writer->text($this->overnightMinDriving);
            $writer->endElement();
        }
        if ($this->overtimeDurations) {
            $writer->startElementNs(null, 'overtimeDurations', null);
            foreach ($this->overtimeDurations as $i => $x) {
                $writer->startElementNs(null, 'overtimeDuration', null);
                $writer->text($x);
                $writer->endElement();
            }
            $writer->endElement();
        }
        if ($this->overtimePenalties) {
            $writer->startElementNs(null, 'overtimePenalties', null);
            foreach ($this->overtimePenalties as $i => $x) {
                $writer->startElementNs(null, 'overtimePenalty', null);
                $writer->text($x);
                $writer->endElement();
            }
            $writer->endElement();
        }
        if ($this->payWholeDay) {
            $writer->startElementNs(null, 'payWholeDay', null);
            $writer->text($this->payWholeDay);
            $writer->endElement();
        }
        if ($this->penaltyPerVisit) {
            $writer->startElementNs(null, 'penaltyPerVisit', null);
            $writer->text($this->penaltyPerVisit);
            $writer->endElement();
        }
        if ($this->speedAdjustment) {
            $writer->startElementNs(null, 'speedAdjustment', null);
            $writer->text($this->speedAdjustment);
            $writer->endElement();
        }
        if ($this->startTravelTimeModifier) {
            $writer->startElementNs(null, 'startTravelTimeModifier', null);
            $this->startTravelTimeModifier->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->stopTravelTimeModifier) {
            $writer->startElementNs(null, 'stopTravelTimeModifier', null);
            $this->stopTravelTimeModifier->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->extraTravelPenalties) {
            $writer->startElementNs(null, 'extraTravelPenalties', null);
            foreach ($this->extraTravelPenalties as $i => $x) {
                $writer->startElementNs(null, 'extraTravelPenalty', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
            $writer->endElement();
        }
        if ($this->travelTimeModifier) {
            $writer->startElementNs(null, 'travelTimeModifier', null);
            $this->travelTimeModifier->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->usePenalty) {
            $writer->startElementNs(null, 'usePenalty', null);
            $writer->text($this->usePenalty);
            $writer->endElement();
        }
        if ($this->weeklyWorkTime) {
            $writer->startElementNs(null, 'weeklyWorkTime', null);
            $writer->text($this->weeklyWorkTime);
            $writer->endElement();
        }
        if ($this->workEndTime) {
            $writer->startElementNs(null, 'workEndTime', null);
            $writer->text($this->workEndTime);
            $writer->endElement();
        }
        if ($this->workingDays) {
            $writer->startElementNs(null, 'workingDays', null);
            $writer->text($this->workingDays);
            $writer->endElement();
        }
        if ($this->workPenalty) {
            $writer->startElementNs(null, 'workPenalty', null);
            $writer->text($this->workPenalty);
            $writer->endElement();
        }
        if ($this->workStartTime) {
            $writer->startElementNs(null, 'workStartTime', null);
            $writer->text($this->workStartTime);
            $writer->endElement();
        }
        if ($this->startX) {
            $writer->startElementNs(null, 'startX', null);
            $writer->text($this->startX);
            $writer->endElement();
        }
        if ($this->endX) {
            $writer->startElementNs(null, 'endX', null);
            $writer->text($this->endX);
            $writer->endElement();
        }
        if ($this->startY) {
            $writer->startElementNs(null, 'startY', null);
            $writer->text($this->startY);
            $writer->endElement();
        }
        if ($this->endY) {
            $writer->startElementNs(null, 'endY', null);
            $writer->text($this->endY);
            $writer->endElement();
        }
        if ($this->travelPenalty) {
            $writer->startElementNs(null, 'travelPenalty', null);
            $writer->text($this->travelPenalty);
            $writer->endElement();
        }
        if ($this->minimumQuantity) {
            $writer->startElementNs(null, 'minimumQuantity', null);
            $writer->text($this->minimumQuantity);
            $writer->endElement();
        }
        if ($this->fixedUnloadingDuration) {
            $writer->startElementNs(null, 'fixedUnloadingDuration', null);
            $writer->text($this->fixedUnloadingDuration);
            $writer->endElement();
        }
        if ($this->unloadingDurationPerUnit) {
            $writer->startElementNs(null, 'unloadingDurationPerUnit', null);
            $writer->text($this->unloadingDurationPerUnit);
            $writer->endElement();
        }
        if ($this->maximumReloads) {
            $writer->startElementNs(null, 'maximumReloads', null);
            $writer->text($this->maximumReloads);
            $writer->endElement();
        }
        if ($this->maximumReloadsPenalty) {
            $writer->startElementNs(null, 'maximumReloadsPenalty', null);
            $writer->text($this->maximumReloadsPenalty);
            $writer->endElement();
        }
        if ($this->noReload) {
            $writer->startElementNs(null, 'noReload', null);
            $writer->text($this->noReload);
            $writer->endElement();
        }
        if ($this->otherWorkStartTimes) {
            $writer->startElementNs(null, 'otherWorkStartTimes', null);
            foreach ($this->otherWorkStartTimes as $i => $x) {
                $writer->startElementNs(null, 'otherWorkStartTime', null);
                $writer->text($x);
                $writer->endElement();
            }
            $writer->endElement();
        }
        if ($this->otherWorkEndTimes) {
            $writer->startElementNs(null, 'otherWorkEndTimes', null);
            foreach ($this->otherWorkEndTimes as $i => $x) {
                $writer->startElementNs(null, 'otherWorkEndTime', null);
                $writer->text($x);
                $writer->endElement();
            }
            $writer->endElement();
        }
        if ($this->otherWorkDaysList) {
            $writer->startElementNs(null, 'otherWorkingDays', null);
            foreach ($this->otherWorkDaysList as $i => $x) {
                $writer->startElementNs(null, 'otherWorkingDay', null);
                $writer->text($x);
                $writer->endElement();
            }
            $writer->endElement();
        }
        if ($this->providedProducts) {
            $writer->startElementNs(null, 'providedProducts', null);
            $writer->text($this->providedProducts);
            $writer->endElement();
        }
        if ($this->useInPlanningPenalty) {
            $writer->startElementNs(null, 'useInPlanningPenalty', null);
            $writer->text($this->useInPlanningPenalty);
            $writer->endElement();
        }
        if ($this->maximumDistance) {
            $writer->startElementNs(null, 'maximumDistance', null);
            $writer->text($this->maximumDistance);
            $writer->endElement();
        }
        if ($this->maximumVisits) {
            $writer->startElementNs(null, 'maximumVisits', null);
            $writer->text($this->maximumVisits);
            $writer->endElement();
        }
        if ($this->mobileLogin) {
            $writer->startElementNs(null, 'mobileLogin', null);
            $writer->text($this->mobileLogin);
            $writer->endElement();
        }
        if ($this->useAllCapacities) {
            $writer->startElementNs(null, 'useAllCapacities', null);
            $writer->text($this->useAllCapacities);
            $writer->endElement();
        }
        if ($this->globalCapacity) {
            $writer->startElementNs(null, 'globalCapacity', null);
            $writer->text($this->globalCapacity);
            $writer->endElement();
        }
        if ($this->additionalCostOrderCustomDataName) {
            $writer->startElementNs(null, 'additionalCostOrderCustomDataName', null);
            $writer->text($this->additionalCostOrderCustomDataName);
            $writer->endElement();
        }
        if ($this->additionalCostOperator) {
            $writer->startElementNs(null, 'additionalCostOperator', null);
            $writer->text($this->additionalCostOperator);
            $writer->endElement();
        }
        if ($this->additionalCosts) {
            foreach ($this->additionalCosts as $i => $x) {
                $writer->startElementNs(null, 'additionalCosts', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->openTimeStart) {
            $writer->startElementNs(null, 'openTimeStart', null);
            $writer->text($this->openTimeStart);
            $writer->endElement();
        }
        if ($this->openDistanceStart) {
            $writer->startElementNs(null, 'openDistanceStart', null);
            $writer->text($this->openDistanceStart);
            $writer->endElement();
        }
        if ($this->openTimeStop) {
            $writer->startElementNs(null, 'openTimeStop', null);
            $writer->text($this->openTimeStop);
            $writer->endElement();
        }
        if ($this->openDistanceStop) {
            $writer->startElementNs(null, 'openDistanceStop', null);
            $writer->text($this->openDistanceStop);
            $writer->endElement();
        }
        if ($this->tomTomWebFleetEnabled) {
            $writer->startElementNs(null, 'tomTomWebFleetEnabled', null);
            $writer->text($this->tomTomWebFleetEnabled);
            $writer->endElement();
        }
        if ($this->tomTomWebFleetIdentifier) {
            $writer->startElementNs(null, 'tomTomWebFleetIdentifier', null);
            $writer->text($this->tomTomWebFleetIdentifier);
            $writer->endElement();
        }
        if ($this->vehicleCode) {
            $writer->startElementNs(null, 'vehicleCode', null);
            $writer->text($this->vehicleCode);
            $writer->endElement();
        }
        if ($this->fuelCode) {
            $writer->startElementNs(null, 'fuelCode', null);
            $writer->text($this->fuelCode);
            $writer->endElement();
        }
        if ($this->daysOff) {
            foreach ($this->daysOff as $i => $x) {
                $writer->startElementNs(null, 'daysOff', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->allowedNights) {
            $writer->startElementNs(null, 'allowedNights', null);
            $writer->text($this->allowedNights);
            $writer->endElement();
        }
        if ($this->parkingTime) {
            $writer->startElementNs(null, 'parkingTime', null);
            $writer->text($this->parkingTime);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Optim;

/**
 * (no documentation provided)
 */
class CostOperator
{

    /**
     * 
     */
    const SUM = "SUM";

    /**
     * 
     */
    const MAX = "MAX";

    /**
     * 
     */
    const MIN = "MIN";

    /**
     * 
     */
    const AVERAGE = "AVERAGE";
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Optim;

/**
 * (no documentation provided)
 */
class TSOrder extends \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSObject
{

    /**
     * Indicates whether a resource must provide all required skills or one at
     * least.
     * 
     * * Set it to True to indicate that a resource must provide all the
     * customer required skills.
     * 
     * * Set it to False to indicate that a resource must provide at least one
     * of the customer required skills.
     * 
     * **Default : ** True.
     *
     * @var boolean
     */
    private $allSkillsRequired;

    /**
     * The identities of the resources that can deliver a customer.
     * 
     * Use this constraint when you want some customers to be delivered by
     * specific resources.
     * 
     * **Type : ** string array containing resources tag ID
     * 
     * **Default : ** not used.
     *
     * @var string[]
     */
    private $assignResources;

    /**
     * The assignment cost of the resources that can deliver a customer (new solver only).
     * 
     * Use this constraint in conjunction with assignResources if you want to set preferences between the resources.
     * If you set assingResources=[&#39;R1&#39;,&#39;R2&#39;] and assignCosts=[10,100], it is very likely that the order will
     * be assigned to the resource R1 which have a lower assignment cost.
     * 
     * If you specified several resources in assignResources, you must specify the same number of costs (or none)
     * 
     * **Type : ** int array containing const values.
     * 
     * **Default : ** not used.
     *
     * @var integer[]
     */
    private $assignCosts;

    /**
     * (no documentation provided)
     *
     * @var string[]
     */
    private $documentReferences;

    /**
     * The cost of the order delivered by an independant transport device.
     * 
     * Use this constraint when an order can be delivered independantly to
     * specify the cost of the device. The solver engine will assign it to a
     * courier device or integrate it in a tour according to the least cost.
     * 
     * **Type : ** float.
     * 
     * **Default : ** not used.
     *
     * @var double
     */
    private $courierPenalty;

    /**
     * Private feature data.
     * 
     * Use this feature when you need to keep accessible private data about
     * customers. For instance if you need to export the address of an element
     * in a planning report, store it there. These informations can also be
     * exported to the mobile app.
     * 
     * max 50 fields
     * 
     * **Default : ** empty.
     *
     * @var array
     */
    private $customDataMap;

    /**
     * The penalty per hour for being late at a customer.
     * 
     * Use this constraint to allow a smarter control, with respect to time
     * windows, than with the use of the tsOrderPunctuality constraint.
     * 
     * **Type : ** float.
     * 
     * **Default : ** not used.
     *
     * @var double
     */
    private $delayPenaltyPerHour;

    /**
     * The identities of the resources which must not deliver a customer.
     * 
     * Use this constraint when you want to prevent some customers from being
     * delivered by specific resources.
     *
     * @var string[]
     */
    private $excludeResources;

    /**
     * The fixed part of the total time spent visiting a customer.
     * 
     * Use this constraint to specify the minimum time spent at a customer&#39;s.
     * Use it to store the time needed by a vehicle to park, for instance, or
     * the time planned for a commercial meeting.
     * 
     * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
     * 
     * **Default : ** not used.
     * 
     * **Example : **
     * 
     * * tsOrderFixedVisitDuration = &quot;00:30:00&quot; indicates that the visit will be
     * 30 minutes long.
     * 
     * * tsOrderUnloadingDurationPerUnit = 120 indicates that 120 seconds are
     * necessary to unload one unit. With a tsOrderQuantity equal to 8, for
     * instance, the variable part is 120*8 (960 seconds or 16 minutes) to
     * unload the customer ordered quantity.
     * 
     * * Total delivery time = 30 minutes + 16 minutes = 46 minutes accounted
     * for the customer delivery.
     *
     * @var string
     */
    private $fixedVisitDuration;

    /**
     * The visit occurrence within a defined period.
     * 
     * Use this constraint to plan multiple visits at a customer during a
     * period.
     * 
     * Type: string value describing the number of visits over a period.
     * Default: not used.
     * 
     * **Example : **
     * 
     * Frequency = &quot;3/5&quot; means a customer must be visited 3 times within a
     * 5-days long period. The solver engine will create and optimize routes
     * respecting an optimal duration between consecutive visits. Thus, back to
     * the example, the computed period is 5/3 rounded = 2. The best solution
     * will respect, as far as possible, a 2-days long period between each visit
     * (ex: day1, day3, day5 is a good solution).
     *
     * @var string
     */
    private $frequency;

    /**
     * The unique identifier of the order
     *
     * @var string
     */
    private $id;

    /**
     * The min duration of the visit that enables partition.
     * 
     * When the total duration of an order is very long, you may want to part it
     * into multiple consecutive visits. First use this constraint to specify a
     * duration threshold from which visit can be cut into multiple parts. Then
     * use the tsOrderMinPartDuration to specify the min duration of one part.
     * 
     * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
     * 
     * **Default : ** not used.
     *
     * @var string
     */
    private $minDuration;

    /**
     * The min duration of a part of a split visit.
     * 
     * When the total duration of an order is very long, you may want to part it
     * into multiple consecutive visits. First use the tsOrderMinDuration to
     * specify a duration threshold from which the visit can be cut into
     * multiple parts. Then use this constraint to specify the min duration of
     * one part. The visit is split into parts of the set duration, and
     * eventually a bigger one.
     * 
     * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
     * 
     * **Default : ** not used.
     *
     * @var string
     */
    private $minPartDuration;

    /**
     * The priority for a customer to be delivered on time (Old engine only).
     * With the new engine, use maxDelaytime and delayPenaltyPerHour instead.
     * 
     * Use this constraint to introduce different priority levels for the
     * respect of visit time windows (when defined). Specify a value from 1 to 5
     * to set the priority: customers with a punctuality set to 5 will have less
     * risk of delayed deliveries than a customer with a punctuality set to 1.
     * You can specify more precisely punctuality requirements to enforce delay
     * control by using the tsOrderDelayPenaltyPerHour constraint instead of the
     * tsOrderPunctuality constraint.
     * 
     * **Type : ** integer value from 1 to 5.
     * 
     * **Default : ** 1.
     *
     * @var integer
     */
    private $punctuality;

    /**
     * The requested product quantities for an order.
     * 
     * Use this constraint to specify the product quantities ordered by a
     * customer, for instance. Up to 24 quantities can be used to order
     * different products. Useless when planning commercial tours.
     * 
     * **Type : ** float array (maximum of 3 significant digits after decimal
     * separator).
     * 
     * **Default : ** 0 **Max : ** 2,147,483.
     * 
     * **Example : **
     * 
     * * Use this constraint to store the number of ordered packages, when
     * working with packages.
     * 
     * * Use this constraint to store the number of ordered liters, when working
     * with liquids.
     * 
     * * Use multiple dimensions when working with multiple products: when
     * delivering fuels for instance, you will use as many dimensions as types
     * of fuels
     * 
     * **Warning : ** The quantity constraint of the *Orders* elements must be
     * related to the corresponding capacity constraint of the *Resources*
     * elements: thus, an order will not be planned whenever no resource with
     * the related capacity has been defined.
     *
     * @var double[]
     */
    private $quantities;

    /**
     * The list of the skills a customer requires to be visited.
     * 
     * Use this constraint when an order must be affected to a specific kind of
     * resource: these resources will have to provide the required skills to be
     * able to visit the customer.
     * 
     * **Type : ** string array.
     * 
     * **Default : ** none.
     * 
     * **Example : **
     * 
     * * Specify the word &quot;Maintenance&quot; as a required skill for a maintenance
     * visit. Only the resources providing the &quot;Maintenance&quot; skill can perform
     * the visit.
     * 
     * * Specify &quot;Small vehicle&quot; as a required skill for a customer living down
     * town.
     *
     * @var string[]
     */
    private $requiredSkills;

    /**
     * Value for compatibility with resources.
     * 
     * If the order has a compatibility constraint value, a resource is
     * compatible with the order if its compatibility value is either
     * non-existent either larger or equal to the order&#39;s one. See
     * tsResourceOrderCompatibility.
     * 
     * **Example : **
     * 
     * * Set tsOrderResourceCompatibility to 254.18 and
     * tsResourceOrderCompatibility to 260.12: order and resource are compatible
     * 
     * * Set tsOrderResourceCompatibility to 254.18 and
     * tsResourceOrderCompatibility to 200: the order can not be affected to the
     * resource
     * 
     * * Set tsOrderResourceCompatibility to 254.18 and
     * tsResourceOrderCompatibility empty: order and resource are compatible
     * 
     * * Set tsOrderResourceCompatibility empty and tsResourceOrderCompatibility
     * to 260.12: order and resource are compatible
     * 
     * 
     * **Type : ** double
     * 
     * **Default :** -1
     *
     * @var double
     */
    private $resourceCompatibility;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $sequenceNumber;

    /**
     * The visit time windows.
     * 
     * Use this constraint to specify a visit time window during which the order
     * can be delivered. A visit time window is defined by its start time, its
     * end time and possible visit days (see tsOrderTimeWindow1_EndTime,
     * tsOrderPossibleVisitDays1). You can specify up to 4 visit time windows
     * for a customer.
     * 
     * **Type : ** array of time windows
     * 
     * **Default : ** &quot;00:00:00&quot;.
     * 
     * **Example : ** A customer can only be delivered: *
     * 
     * * on Monday from 11:00:00 to 12:00:00 AM and from 04:00:00 to 05:00:00
     * PM,
     * 
     * * on Tuesday, Wednesday, Thursday from 08:00:00 to 09:00:00 AM and from
     * 04:00:00 to 05:00:00 PM,
     * 
     * * on Friday from 08:00:00 to 09:00:00 AM.
     * 
     * Its visit time windows will be specified as follows:
     * 
     * * first time window StartTime = &quot;08:00:00&quot;, EndTime = &quot;09:00:00&quot;, first
     * set of possible days = &quot;2=&gt;5&quot;,
     * 
     * * second time window StartTime = &quot;11:00:00&quot;, EndTime = &quot;12:00:00&quot;, second
     * set of possible days = 1,
     * 
     * * third time window StartTime = &quot;16:00:00&quot;, EndTime = &quot;17:00:00&quot;, third
     * set of possible days = &quot;1=&gt;4&quot;.
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTimeWindow[]
     */
    private $timeWindows;

    /**
     * Indicates the value of the travel time modifier.
     * 
     * When reaching a location situated in a large city, one may want to take
     * into account driving difficulties, such as narrow streets and congestion.
     * The travel time modifier enables to increase the travel times around a
     * location. It is describes by three values. The value by which multiply
     * the travel times around the location (tsOrderTravelTimeModifierValue),
     * the portion of the travel time on which the modifier applies
     * (tsOrderTravelTimeModifierLength) an offset to add to any travel duration
     * leaving or reaching the location (tsOrderTravelTimeModifierOffSet).
     * 
     * **Example : **
     * 
     * * Set tsOrderTravelTimeModifierValue to 1.5,
     * tsOrderTravelTimeModifierLength to 300 and
     * tsOrderTravelTimeModifierOffSet to 60 for Order 1
     * 
     * * Set tsOrderTravelTimeModifierValue to 2,
     * tsOrderTravelTimeModifierLength to 420 and
     * tsOrderTravelTimeModifierOffSet to 0 for Order 2 If the initial travel
     * duration between Order 1 and Order 2 was 1000, one obtains a travel time
     * 360 * 1.5 + 60 + 280 + 420 * 2 + 0 = 1660
     * 
     * **Type : ** float
     * 
     * **Default : ** 1
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTravelTimeModifier
     */
    private $travelTimeModifier;

    /**
     * The type of visit at a customer.
     * 
     * * 0 (Delivery): the resource will delivere related quantities.
     * 
     * * 1 (PickUp): the resource will pick-up related quantities.
     * 
     * * 2 (DeliveryFirst): the resource will not mix deliveries and pick-ups in
     * a same rotation.
     * 
     * It is possible to mix pickups and 0 type deliveries in the same rotation.
     * However, the delivered products will come from the depot and the pickup
     * products will be unloaded at the depot. No product delivered to a
     * customer can come from a pickup at another customer&#39;s.
     * 
     * **Type : ** Integer.
     * 
     * **Default : ** 0 (Delivery).
     *
     * @var integer
     */
    private $type;

    /**
     * The time needed to deliver one unit of product.
     * 
     * Use this constraint when the time spent at a customer depends on the
     * quantity to deliver. It is the time needed to unload one unit of the
     * quantity stored in the customer tsOrderQuantity constraint.
     * 
     * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
     * 
     * **Default : ** not used.
     *
     * @var string
     */
    private $unloadingDurationPerUnit;

    /**
     * longitude of order location
     *
     * @var double
     */
    private $x;

    /**
     * latitude of order location
     *
     * @var double
     */
    private $y;

    /**
     * Indicates whether the order should scheduled or not
     * 
     * **Default : ** True.
     *
     * @var boolean
     */
    private $active;

    /**
     * Whole visit ends before time window end.
     * 
     * Use this constraint if you want that a visit ends before the end of the
     * time window.
     * 
     * **Default : ** false.
     *
     * @var boolean
     */
    private $wholeVisitInTimeWindow;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $label;

    /**
     * first order assignment (specifying resource, day and position in route).
     * 
     * Use it to compare optimization result with a previous optimization
     * 
     * **Warning : ** used only if startFromEvaluationInfo is set to true in
     * options.
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSEvaluationInfos
     */
    private $evaluationInfos;

    /**
     * The possible visit days related to each visit time window.
     * 
     * Use this constraint to specify the possible visit days of a customer
     * referring to a visit time window. It must be related to the
     * tsResourceWorkDays constraint of the resources, as resources work days
     * define the planning period. You can plan visits on a 64-days-long period
     * max.
     * 
     * **Type : ** array of string values containing visit days separated with
     * commas (like &quot;1, 2, 5&quot; or &quot;4, 20/05/2010&quot;) or intervals (like &quot;1-10&quot;,
     * &quot;2=&gt;5&quot; or &quot;22/05/2010=&gt;03/06/2010&quot;). For day intervals, prefer the &quot;=&gt;&quot;
     * separator. Be carrefull, if the separator of date is - then &quot;1-5&quot;
     * corresponds to May the 1st of the current year. 1 is the first day of the
     * planning period, the corresponding date, if any, is defined by the oldest
     * date, for all resources, in the tsResourceWorkDays constraint. No date in
     * the possible visit days description can precede the first day of the
     * planning period defined by the resources (which is day 1). Default:
     * 1=&gt;64.
     * 
     * You can set up to 4 sets of visit days in this array. If you define
     * several time windows, each time window will apply to corresponding set of
     * possible days : first time window applies to first possible days set,
     * second time window applies to second possible days set, etc.
     * 
     * **Example : **
     * 
     * - Set it to &quot;1&quot; (or &quot;14/05/2010) when a customer must be visited on the
     * first day of the planning period.
     * 
     * - Set it to &quot;1, 2, 4, 5&quot; (or
     * &quot;14/05/2010,15/05/2010,17/05/2010,18/05/2010&quot;) if the customer cannot be
     * visited on the third day of a five days planning period.
     * 
     * - Set it to &quot;1=&gt;5&quot; (or &quot;14/05/2010=&gt;18/05/2010&quot;) to define a 5-days long
     * period during which the customer can be visited.
     *
     * @var string[]
     */
    private $possibleVisitDaysList;

    /**
     * The maximum number of days required between two visits of a same order.
     * 
     * Use this constraint in case of frequency order to specify how many days
     * at most should be left between two visits of the order.
     * 
     * **Type : ** integer
     * 
     * **Max : ** 2,147,483.
     *
     * @var integer
     */
    private $tsOrderMaximumSpacing;

    /**
     * The minimum number of days required between two visits of a same order.
     * 
     * Use this constraint in case of frequency order to specify how many days
     * at least should be left between two visits of the order.
     * 
     * **Type : ** integer
     * 
     * **Default : ** 0 **Max : ** 2,147,483.
     * 
     * **Warning : ** if the number of occurences of the frequency is more than
     * one, the constraints tsOrderLastVisit and tsOrderMinimumSpacing are not
     * considered.
     *
     * @var integer
     */
    private $tsOrderMinimumSpacing;

    /**
     * The number of days before the beginning of the planning the last visit
     * belonging to the order has been performed
     * 
     * Use this constraint in case of a frequency order to specify from how many
     * days the last visit was performed before starting the current planning.
     * The default value indicates this constraint is to be unused in the
     * planning.
     * 
     * **Type : ** negative integer
     * 
     * **Default : ** 0 **Max : ** -2,147,483.
     * 
     * **Example : **
     * 
     * If *tsOrderLastVisit* = -2, the last visit of the same order has been
     * performed two days ago.
     * 
     * **Warning : ** if the number of occurences of the frequency is more than
     * one, the constraints tsOrderLastVisit and tsOrderMinimumSpacing are not
     * considered.
     *
     * @var integer
     */
    private $tsOrderLastVisit;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $customerId;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $email;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $phone;

    /**
     * This constraint lets you chain visits. Two chained visits will be performed the same day by the same driver.
     * The visit on which this constraint is defined will be placed after the one it defines. If a visit from the chain cannot be placed, then none will be.
     * You can specify one order id or several order ids (comma separated string).
     *
     * @var string
     */
    private $tsOrderBefore;

    /**
     * This constraint specifies the maximum spacing between the two chained visits.
     * 
     * * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
     * 
     * **Default : ** not used.
     *
     * @var string
     */
    private $tsOrderBeforeMaxTimeSpacing;

    /**
     * This constraint specifies the minimum spacing between the two chained visits.
     * 
     * * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
     * 
     * **Default : ** not used.
     *
     * @var string
     */
    private $tsOrderBeforeMinTimeSpacing;

    /**
     * Boolean.True if a visit can receive notification email/sms
     *
     * @var boolean
     */
    private $getNotifications;

    /**
     * If true, force the use of the specified day, resource and start time (new solver only)
     * 
     * You must specify orderOriginalResourceId and orderOriginalVisitDay of evaluationInfo and set the time window to the exact time (respecting the duration)
     *
     * @var boolean
     */
    private $tsOrderFixed;

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Model\ScanItem[]
     */
    private $scanItems;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $invoiceId;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $originalOperationalId;

    /**
     * This constraint specifies the maximum allowed delay (new solver only).
     * You must specify a cost per hour through the delayPenaltyPerHour constraint.
     * 
     * * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
     * 
     * **Default : ** not used.
     *
     * @var string
     */
    private $maxDelayTime;

    /**
     * Constructs a TSOrder from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * Indicates whether a resource must provide all required skills or one at
       * least.
       * 
       * * Set it to True to indicate that a resource must provide all the
       * customer required skills.
       * 
       * * Set it to False to indicate that a resource must provide at least one
       * of the customer required skills.
       * 
       * **Default : ** True.
     *
     * @return boolean
     */
    public function getAllSkillsRequired()
    {
        return $this->allSkillsRequired;
    }

    /**
     * Indicates whether a resource must provide all required skills or one at
       * least.
       * 
       * * Set it to True to indicate that a resource must provide all the
       * customer required skills.
       * 
       * * Set it to False to indicate that a resource must provide at least one
       * of the customer required skills.
       * 
       * **Default : ** True.
     *
     * @param boolean $allSkillsRequired
     */
    public function setAllSkillsRequired($allSkillsRequired)
    {
        $this->allSkillsRequired = $allSkillsRequired;
    }
    /**
     * The identities of the resources that can deliver a customer.
       * 
       * Use this constraint when you want some customers to be delivered by
       * specific resources.
       * 
       * **Type : ** string array containing resources tag ID
       * 
       * **Default : ** not used.
     *
     * @return string[]
     */
    public function getAssignResources()
    {
        return $this->assignResources;
    }

    /**
     * The identities of the resources that can deliver a customer.
       * 
       * Use this constraint when you want some customers to be delivered by
       * specific resources.
       * 
       * **Type : ** string array containing resources tag ID
       * 
       * **Default : ** not used.
     *
     * @param string[] $assignResources
     */
    public function setAssignResources($assignResources)
    {
        $this->assignResources = $assignResources;
    }
    /**
     * The assignment cost of the resources that can deliver a customer (new solver only).
       * 
       * Use this constraint in conjunction with assignResources if you want to set preferences between the resources.
       * If you set assingResources=[&#39;R1&#39;,&#39;R2&#39;] and assignCosts=[10,100], it is very likely that the order will
       * be assigned to the resource R1 which have a lower assignment cost.
       * 
       * If you specified several resources in assignResources, you must specify the same number of costs (or none)
       * 
       * **Type : ** int array containing const values.
       * 
       * **Default : ** not used.
     *
     * @return integer[]
     */
    public function getAssignCosts()
    {
        return $this->assignCosts;
    }

    /**
     * The assignment cost of the resources that can deliver a customer (new solver only).
       * 
       * Use this constraint in conjunction with assignResources if you want to set preferences between the resources.
       * If you set assingResources=[&#39;R1&#39;,&#39;R2&#39;] and assignCosts=[10,100], it is very likely that the order will
       * be assigned to the resource R1 which have a lower assignment cost.
       * 
       * If you specified several resources in assignResources, you must specify the same number of costs (or none)
       * 
       * **Type : ** int array containing const values.
       * 
       * **Default : ** not used.
     *
     * @param integer[] $assignCosts
     */
    public function setAssignCosts($assignCosts)
    {
        $this->assignCosts = $assignCosts;
    }
    /**
     * (no documentation provided)
     *
     * @return string[]
     */
    public function getDocumentReferences()
    {
        return $this->documentReferences;
    }

    /**
     * (no documentation provided)
     *
     * @param string[] $documentReferences
     */
    public function setDocumentReferences($documentReferences)
    {
        $this->documentReferences = $documentReferences;
    }
    /**
     * The cost of the order delivered by an independant transport device.
       * 
       * Use this constraint when an order can be delivered independantly to
       * specify the cost of the device. The solver engine will assign it to a
       * courier device or integrate it in a tour according to the least cost.
       * 
       * **Type : ** float.
       * 
       * **Default : ** not used.
     *
     * @return double
     */
    public function getCourierPenalty()
    {
        return $this->courierPenalty;
    }

    /**
     * The cost of the order delivered by an independant transport device.
       * 
       * Use this constraint when an order can be delivered independantly to
       * specify the cost of the device. The solver engine will assign it to a
       * courier device or integrate it in a tour according to the least cost.
       * 
       * **Type : ** float.
       * 
       * **Default : ** not used.
     *
     * @param double $courierPenalty
     */
    public function setCourierPenalty($courierPenalty)
    {
        $this->courierPenalty = $courierPenalty;
    }
    /**
     * Private feature data.
       * 
       * Use this feature when you need to keep accessible private data about
       * customers. For instance if you need to export the address of an element
       * in a planning report, store it there. These informations can also be
       * exported to the mobile app.
       * 
       * max 50 fields
       * 
       * **Default : ** empty.
     *
     * @return array
     */
    public function getCustomDataMap()
    {
        return $this->customDataMap;
    }

    /**
     * Private feature data.
       * 
       * Use this feature when you need to keep accessible private data about
       * customers. For instance if you need to export the address of an element
       * in a planning report, store it there. These informations can also be
       * exported to the mobile app.
       * 
       * max 50 fields
       * 
       * **Default : ** empty.
     *
     * @param array $customDataMap
     */
    public function setCustomDataMap($customDataMap)
    {
        $this->customDataMap = $customDataMap;
    }
    /**
     * The penalty per hour for being late at a customer.
       * 
       * Use this constraint to allow a smarter control, with respect to time
       * windows, than with the use of the tsOrderPunctuality constraint.
       * 
       * **Type : ** float.
       * 
       * **Default : ** not used.
     *
     * @return double
     */
    public function getDelayPenaltyPerHour()
    {
        return $this->delayPenaltyPerHour;
    }

    /**
     * The penalty per hour for being late at a customer.
       * 
       * Use this constraint to allow a smarter control, with respect to time
       * windows, than with the use of the tsOrderPunctuality constraint.
       * 
       * **Type : ** float.
       * 
       * **Default : ** not used.
     *
     * @param double $delayPenaltyPerHour
     */
    public function setDelayPenaltyPerHour($delayPenaltyPerHour)
    {
        $this->delayPenaltyPerHour = $delayPenaltyPerHour;
    }
    /**
     * The identities of the resources which must not deliver a customer.
       * 
       * Use this constraint when you want to prevent some customers from being
       * delivered by specific resources.
     *
     * @return string[]
     */
    public function getExcludeResources()
    {
        return $this->excludeResources;
    }

    /**
     * The identities of the resources which must not deliver a customer.
       * 
       * Use this constraint when you want to prevent some customers from being
       * delivered by specific resources.
     *
     * @param string[] $excludeResources
     */
    public function setExcludeResources($excludeResources)
    {
        $this->excludeResources = $excludeResources;
    }
    /**
     * The fixed part of the total time spent visiting a customer.
       * 
       * Use this constraint to specify the minimum time spent at a customer&#39;s.
       * Use it to store the time needed by a vehicle to park, for instance, or
       * the time planned for a commercial meeting.
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
       * 
       * **Default : ** not used.
       * 
       * **Example : **
       * 
       * * tsOrderFixedVisitDuration = &quot;00:30:00&quot; indicates that the visit will be
       * 30 minutes long.
       * 
       * * tsOrderUnloadingDurationPerUnit = 120 indicates that 120 seconds are
       * necessary to unload one unit. With a tsOrderQuantity equal to 8, for
       * instance, the variable part is 120*8 (960 seconds or 16 minutes) to
       * unload the customer ordered quantity.
       * 
       * * Total delivery time = 30 minutes + 16 minutes = 46 minutes accounted
       * for the customer delivery.
     *
     * @return string
     */
    public function getFixedVisitDuration()
    {
        return $this->fixedVisitDuration;
    }

    /**
     * The fixed part of the total time spent visiting a customer.
       * 
       * Use this constraint to specify the minimum time spent at a customer&#39;s.
       * Use it to store the time needed by a vehicle to park, for instance, or
       * the time planned for a commercial meeting.
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
       * 
       * **Default : ** not used.
       * 
       * **Example : **
       * 
       * * tsOrderFixedVisitDuration = &quot;00:30:00&quot; indicates that the visit will be
       * 30 minutes long.
       * 
       * * tsOrderUnloadingDurationPerUnit = 120 indicates that 120 seconds are
       * necessary to unload one unit. With a tsOrderQuantity equal to 8, for
       * instance, the variable part is 120*8 (960 seconds or 16 minutes) to
       * unload the customer ordered quantity.
       * 
       * * Total delivery time = 30 minutes + 16 minutes = 46 minutes accounted
       * for the customer delivery.
     *
     * @param string $fixedVisitDuration
     */
    public function setFixedVisitDuration($fixedVisitDuration)
    {
        $this->fixedVisitDuration = $fixedVisitDuration;
    }
    /**
     * The visit occurrence within a defined period.
       * 
       * Use this constraint to plan multiple visits at a customer during a
       * period.
       * 
       * Type: string value describing the number of visits over a period.
       * Default: not used.
       * 
       * **Example : **
       * 
       * Frequency = &quot;3/5&quot; means a customer must be visited 3 times within a
       * 5-days long period. The solver engine will create and optimize routes
       * respecting an optimal duration between consecutive visits. Thus, back to
       * the example, the computed period is 5/3 rounded = 2. The best solution
       * will respect, as far as possible, a 2-days long period between each visit
       * (ex: day1, day3, day5 is a good solution).
     *
     * @return string
     */
    public function getFrequency()
    {
        return $this->frequency;
    }

    /**
     * The visit occurrence within a defined period.
       * 
       * Use this constraint to plan multiple visits at a customer during a
       * period.
       * 
       * Type: string value describing the number of visits over a period.
       * Default: not used.
       * 
       * **Example : **
       * 
       * Frequency = &quot;3/5&quot; means a customer must be visited 3 times within a
       * 5-days long period. The solver engine will create and optimize routes
       * respecting an optimal duration between consecutive visits. Thus, back to
       * the example, the computed period is 5/3 rounded = 2. The best solution
       * will respect, as far as possible, a 2-days long period between each visit
       * (ex: day1, day3, day5 is a good solution).
     *
     * @param string $frequency
     */
    public function setFrequency($frequency)
    {
        $this->frequency = $frequency;
    }
    /**
     * The unique identifier of the order
     *
     * @return string
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * The unique identifier of the order
     *
     * @param string $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }
    /**
     * The min duration of the visit that enables partition.
       * 
       * When the total duration of an order is very long, you may want to part it
       * into multiple consecutive visits. First use this constraint to specify a
       * duration threshold from which visit can be cut into multiple parts. Then
       * use the tsOrderMinPartDuration to specify the min duration of one part.
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
       * 
       * **Default : ** not used.
     *
     * @return string
     */
    public function getMinDuration()
    {
        return $this->minDuration;
    }

    /**
     * The min duration of the visit that enables partition.
       * 
       * When the total duration of an order is very long, you may want to part it
       * into multiple consecutive visits. First use this constraint to specify a
       * duration threshold from which visit can be cut into multiple parts. Then
       * use the tsOrderMinPartDuration to specify the min duration of one part.
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
       * 
       * **Default : ** not used.
     *
     * @param string $minDuration
     */
    public function setMinDuration($minDuration)
    {
        $this->minDuration = $minDuration;
    }
    /**
     * The min duration of a part of a split visit.
       * 
       * When the total duration of an order is very long, you may want to part it
       * into multiple consecutive visits. First use the tsOrderMinDuration to
       * specify a duration threshold from which the visit can be cut into
       * multiple parts. Then use this constraint to specify the min duration of
       * one part. The visit is split into parts of the set duration, and
       * eventually a bigger one.
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
       * 
       * **Default : ** not used.
     *
     * @return string
     */
    public function getMinPartDuration()
    {
        return $this->minPartDuration;
    }

    /**
     * The min duration of a part of a split visit.
       * 
       * When the total duration of an order is very long, you may want to part it
       * into multiple consecutive visits. First use the tsOrderMinDuration to
       * specify a duration threshold from which the visit can be cut into
       * multiple parts. Then use this constraint to specify the min duration of
       * one part. The visit is split into parts of the set duration, and
       * eventually a bigger one.
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
       * 
       * **Default : ** not used.
     *
     * @param string $minPartDuration
     */
    public function setMinPartDuration($minPartDuration)
    {
        $this->minPartDuration = $minPartDuration;
    }
    /**
     * The priority for a customer to be delivered on time (Old engine only).
       * With the new engine, use maxDelaytime and delayPenaltyPerHour instead.
       * 
       * Use this constraint to introduce different priority levels for the
       * respect of visit time windows (when defined). Specify a value from 1 to 5
       * to set the priority: customers with a punctuality set to 5 will have less
       * risk of delayed deliveries than a customer with a punctuality set to 1.
       * You can specify more precisely punctuality requirements to enforce delay
       * control by using the tsOrderDelayPenaltyPerHour constraint instead of the
       * tsOrderPunctuality constraint.
       * 
       * **Type : ** integer value from 1 to 5.
       * 
       * **Default : ** 1.
     *
     * @return integer
     */
    public function getPunctuality()
    {
        return $this->punctuality;
    }

    /**
     * The priority for a customer to be delivered on time (Old engine only).
       * With the new engine, use maxDelaytime and delayPenaltyPerHour instead.
       * 
       * Use this constraint to introduce different priority levels for the
       * respect of visit time windows (when defined). Specify a value from 1 to 5
       * to set the priority: customers with a punctuality set to 5 will have less
       * risk of delayed deliveries than a customer with a punctuality set to 1.
       * You can specify more precisely punctuality requirements to enforce delay
       * control by using the tsOrderDelayPenaltyPerHour constraint instead of the
       * tsOrderPunctuality constraint.
       * 
       * **Type : ** integer value from 1 to 5.
       * 
       * **Default : ** 1.
     *
     * @param integer $punctuality
     */
    public function setPunctuality($punctuality)
    {
        $this->punctuality = $punctuality;
    }
    /**
     * The requested product quantities for an order.
       * 
       * Use this constraint to specify the product quantities ordered by a
       * customer, for instance. Up to 24 quantities can be used to order
       * different products. Useless when planning commercial tours.
       * 
       * **Type : ** float array (maximum of 3 significant digits after decimal
       * separator).
       * 
       * **Default : ** 0 **Max : ** 2,147,483.
       * 
       * **Example : **
       * 
       * * Use this constraint to store the number of ordered packages, when
       * working with packages.
       * 
       * * Use this constraint to store the number of ordered liters, when working
       * with liquids.
       * 
       * * Use multiple dimensions when working with multiple products: when
       * delivering fuels for instance, you will use as many dimensions as types
       * of fuels
       * 
       * **Warning : ** The quantity constraint of the *Orders* elements must be
       * related to the corresponding capacity constraint of the *Resources*
       * elements: thus, an order will not be planned whenever no resource with
       * the related capacity has been defined.
     *
     * @return double[]
     */
    public function getQuantities()
    {
        return $this->quantities;
    }

    /**
     * The requested product quantities for an order.
       * 
       * Use this constraint to specify the product quantities ordered by a
       * customer, for instance. Up to 24 quantities can be used to order
       * different products. Useless when planning commercial tours.
       * 
       * **Type : ** float array (maximum of 3 significant digits after decimal
       * separator).
       * 
       * **Default : ** 0 **Max : ** 2,147,483.
       * 
       * **Example : **
       * 
       * * Use this constraint to store the number of ordered packages, when
       * working with packages.
       * 
       * * Use this constraint to store the number of ordered liters, when working
       * with liquids.
       * 
       * * Use multiple dimensions when working with multiple products: when
       * delivering fuels for instance, you will use as many dimensions as types
       * of fuels
       * 
       * **Warning : ** The quantity constraint of the *Orders* elements must be
       * related to the corresponding capacity constraint of the *Resources*
       * elements: thus, an order will not be planned whenever no resource with
       * the related capacity has been defined.
     *
     * @param double[] $quantities
     */
    public function setQuantities($quantities)
    {
        $this->quantities = $quantities;
    }
    /**
     * The list of the skills a customer requires to be visited.
       * 
       * Use this constraint when an order must be affected to a specific kind of
       * resource: these resources will have to provide the required skills to be
       * able to visit the customer.
       * 
       * **Type : ** string array.
       * 
       * **Default : ** none.
       * 
       * **Example : **
       * 
       * * Specify the word &quot;Maintenance&quot; as a required skill for a maintenance
       * visit. Only the resources providing the &quot;Maintenance&quot; skill can perform
       * the visit.
       * 
       * * Specify &quot;Small vehicle&quot; as a required skill for a customer living down
       * town.
     *
     * @return string[]
     */
    public function getRequiredSkills()
    {
        return $this->requiredSkills;
    }

    /**
     * The list of the skills a customer requires to be visited.
       * 
       * Use this constraint when an order must be affected to a specific kind of
       * resource: these resources will have to provide the required skills to be
       * able to visit the customer.
       * 
       * **Type : ** string array.
       * 
       * **Default : ** none.
       * 
       * **Example : **
       * 
       * * Specify the word &quot;Maintenance&quot; as a required skill for a maintenance
       * visit. Only the resources providing the &quot;Maintenance&quot; skill can perform
       * the visit.
       * 
       * * Specify &quot;Small vehicle&quot; as a required skill for a customer living down
       * town.
     *
     * @param string[] $requiredSkills
     */
    public function setRequiredSkills($requiredSkills)
    {
        $this->requiredSkills = $requiredSkills;
    }
    /**
     * Value for compatibility with resources.
       * 
       * If the order has a compatibility constraint value, a resource is
       * compatible with the order if its compatibility value is either
       * non-existent either larger or equal to the order&#39;s one. See
       * tsResourceOrderCompatibility.
       * 
       * **Example : **
       * 
       * * Set tsOrderResourceCompatibility to 254.18 and
       * tsResourceOrderCompatibility to 260.12: order and resource are compatible
       * 
       * * Set tsOrderResourceCompatibility to 254.18 and
       * tsResourceOrderCompatibility to 200: the order can not be affected to the
       * resource
       * 
       * * Set tsOrderResourceCompatibility to 254.18 and
       * tsResourceOrderCompatibility empty: order and resource are compatible
       * 
       * * Set tsOrderResourceCompatibility empty and tsResourceOrderCompatibility
       * to 260.12: order and resource are compatible
       * 
       * 
       * **Type : ** double
       * 
       * **Default :** -1
     *
     * @return double
     */
    public function getResourceCompatibility()
    {
        return $this->resourceCompatibility;
    }

    /**
     * Value for compatibility with resources.
       * 
       * If the order has a compatibility constraint value, a resource is
       * compatible with the order if its compatibility value is either
       * non-existent either larger or equal to the order&#39;s one. See
       * tsResourceOrderCompatibility.
       * 
       * **Example : **
       * 
       * * Set tsOrderResourceCompatibility to 254.18 and
       * tsResourceOrderCompatibility to 260.12: order and resource are compatible
       * 
       * * Set tsOrderResourceCompatibility to 254.18 and
       * tsResourceOrderCompatibility to 200: the order can not be affected to the
       * resource
       * 
       * * Set tsOrderResourceCompatibility to 254.18 and
       * tsResourceOrderCompatibility empty: order and resource are compatible
       * 
       * * Set tsOrderResourceCompatibility empty and tsResourceOrderCompatibility
       * to 260.12: order and resource are compatible
       * 
       * 
       * **Type : ** double
       * 
       * **Default :** -1
     *
     * @param double $resourceCompatibility
     */
    public function setResourceCompatibility($resourceCompatibility)
    {
        $this->resourceCompatibility = $resourceCompatibility;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getSequenceNumber()
    {
        return $this->sequenceNumber;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $sequenceNumber
     */
    public function setSequenceNumber($sequenceNumber)
    {
        $this->sequenceNumber = $sequenceNumber;
    }
    /**
     * The visit time windows.
       * 
       * Use this constraint to specify a visit time window during which the order
       * can be delivered. A visit time window is defined by its start time, its
       * end time and possible visit days (see tsOrderTimeWindow1_EndTime,
       * tsOrderPossibleVisitDays1). You can specify up to 4 visit time windows
       * for a customer.
       * 
       * **Type : ** array of time windows
       * 
       * **Default : ** &quot;00:00:00&quot;.
       * 
       * **Example : ** A customer can only be delivered: *
       * 
       * * on Monday from 11:00:00 to 12:00:00 AM and from 04:00:00 to 05:00:00
       * PM,
       * 
       * * on Tuesday, Wednesday, Thursday from 08:00:00 to 09:00:00 AM and from
       * 04:00:00 to 05:00:00 PM,
       * 
       * * on Friday from 08:00:00 to 09:00:00 AM.
       * 
       * Its visit time windows will be specified as follows:
       * 
       * * first time window StartTime = &quot;08:00:00&quot;, EndTime = &quot;09:00:00&quot;, first
       * set of possible days = &quot;2=&gt;5&quot;,
       * 
       * * second time window StartTime = &quot;11:00:00&quot;, EndTime = &quot;12:00:00&quot;, second
       * set of possible days = 1,
       * 
       * * third time window StartTime = &quot;16:00:00&quot;, EndTime = &quot;17:00:00&quot;, third
       * set of possible days = &quot;1=&gt;4&quot;.
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTimeWindow[]
     */
    public function getTimeWindows()
    {
        return $this->timeWindows;
    }

    /**
     * The visit time windows.
       * 
       * Use this constraint to specify a visit time window during which the order
       * can be delivered. A visit time window is defined by its start time, its
       * end time and possible visit days (see tsOrderTimeWindow1_EndTime,
       * tsOrderPossibleVisitDays1). You can specify up to 4 visit time windows
       * for a customer.
       * 
       * **Type : ** array of time windows
       * 
       * **Default : ** &quot;00:00:00&quot;.
       * 
       * **Example : ** A customer can only be delivered: *
       * 
       * * on Monday from 11:00:00 to 12:00:00 AM and from 04:00:00 to 05:00:00
       * PM,
       * 
       * * on Tuesday, Wednesday, Thursday from 08:00:00 to 09:00:00 AM and from
       * 04:00:00 to 05:00:00 PM,
       * 
       * * on Friday from 08:00:00 to 09:00:00 AM.
       * 
       * Its visit time windows will be specified as follows:
       * 
       * * first time window StartTime = &quot;08:00:00&quot;, EndTime = &quot;09:00:00&quot;, first
       * set of possible days = &quot;2=&gt;5&quot;,
       * 
       * * second time window StartTime = &quot;11:00:00&quot;, EndTime = &quot;12:00:00&quot;, second
       * set of possible days = 1,
       * 
       * * third time window StartTime = &quot;16:00:00&quot;, EndTime = &quot;17:00:00&quot;, third
       * set of possible days = &quot;1=&gt;4&quot;.
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTimeWindow[] $timeWindows
     */
    public function setTimeWindows($timeWindows)
    {
        $this->timeWindows = $timeWindows;
    }
    /**
     * Indicates the value of the travel time modifier.
       * 
       * When reaching a location situated in a large city, one may want to take
       * into account driving difficulties, such as narrow streets and congestion.
       * The travel time modifier enables to increase the travel times around a
       * location. It is describes by three values. The value by which multiply
       * the travel times around the location (tsOrderTravelTimeModifierValue),
       * the portion of the travel time on which the modifier applies
       * (tsOrderTravelTimeModifierLength) an offset to add to any travel duration
       * leaving or reaching the location (tsOrderTravelTimeModifierOffSet).
       * 
       * **Example : **
       * 
       * * Set tsOrderTravelTimeModifierValue to 1.5,
       * tsOrderTravelTimeModifierLength to 300 and
       * tsOrderTravelTimeModifierOffSet to 60 for Order 1
       * 
       * * Set tsOrderTravelTimeModifierValue to 2,
       * tsOrderTravelTimeModifierLength to 420 and
       * tsOrderTravelTimeModifierOffSet to 0 for Order 2 If the initial travel
       * duration between Order 1 and Order 2 was 1000, one obtains a travel time
       * 360 * 1.5 + 60 + 280 + 420 * 2 + 0 = 1660
       * 
       * **Type : ** float
       * 
       * **Default : ** 1
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTravelTimeModifier
     */
    public function getTravelTimeModifier()
    {
        return $this->travelTimeModifier;
    }

    /**
     * Indicates the value of the travel time modifier.
       * 
       * When reaching a location situated in a large city, one may want to take
       * into account driving difficulties, such as narrow streets and congestion.
       * The travel time modifier enables to increase the travel times around a
       * location. It is describes by three values. The value by which multiply
       * the travel times around the location (tsOrderTravelTimeModifierValue),
       * the portion of the travel time on which the modifier applies
       * (tsOrderTravelTimeModifierLength) an offset to add to any travel duration
       * leaving or reaching the location (tsOrderTravelTimeModifierOffSet).
       * 
       * **Example : **
       * 
       * * Set tsOrderTravelTimeModifierValue to 1.5,
       * tsOrderTravelTimeModifierLength to 300 and
       * tsOrderTravelTimeModifierOffSet to 60 for Order 1
       * 
       * * Set tsOrderTravelTimeModifierValue to 2,
       * tsOrderTravelTimeModifierLength to 420 and
       * tsOrderTravelTimeModifierOffSet to 0 for Order 2 If the initial travel
       * duration between Order 1 and Order 2 was 1000, one obtains a travel time
       * 360 * 1.5 + 60 + 280 + 420 * 2 + 0 = 1660
       * 
       * **Type : ** float
       * 
       * **Default : ** 1
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTravelTimeModifier $travelTimeModifier
     */
    public function setTravelTimeModifier($travelTimeModifier)
    {
        $this->travelTimeModifier = $travelTimeModifier;
    }
    /**
     * The type of visit at a customer.
       * 
       * * 0 (Delivery): the resource will delivere related quantities.
       * 
       * * 1 (PickUp): the resource will pick-up related quantities.
       * 
       * * 2 (DeliveryFirst): the resource will not mix deliveries and pick-ups in
       * a same rotation.
       * 
       * It is possible to mix pickups and 0 type deliveries in the same rotation.
       * However, the delivered products will come from the depot and the pickup
       * products will be unloaded at the depot. No product delivered to a
       * customer can come from a pickup at another customer&#39;s.
       * 
       * **Type : ** Integer.
       * 
       * **Default : ** 0 (Delivery).
     *
     * @return integer
     */
    public function getType()
    {
        return $this->type;
    }

    /**
     * The type of visit at a customer.
       * 
       * * 0 (Delivery): the resource will delivere related quantities.
       * 
       * * 1 (PickUp): the resource will pick-up related quantities.
       * 
       * * 2 (DeliveryFirst): the resource will not mix deliveries and pick-ups in
       * a same rotation.
       * 
       * It is possible to mix pickups and 0 type deliveries in the same rotation.
       * However, the delivered products will come from the depot and the pickup
       * products will be unloaded at the depot. No product delivered to a
       * customer can come from a pickup at another customer&#39;s.
       * 
       * **Type : ** Integer.
       * 
       * **Default : ** 0 (Delivery).
     *
     * @param integer $type
     */
    public function setType($type)
    {
        $this->type = $type;
    }
    /**
     * The time needed to deliver one unit of product.
       * 
       * Use this constraint when the time spent at a customer depends on the
       * quantity to deliver. It is the time needed to unload one unit of the
       * quantity stored in the customer tsOrderQuantity constraint.
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
       * 
       * **Default : ** not used.
     *
     * @return string
     */
    public function getUnloadingDurationPerUnit()
    {
        return $this->unloadingDurationPerUnit;
    }

    /**
     * The time needed to deliver one unit of product.
       * 
       * Use this constraint when the time spent at a customer depends on the
       * quantity to deliver. It is the time needed to unload one unit of the
       * quantity stored in the customer tsOrderQuantity constraint.
       * 
       * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
       * 
       * **Default : ** not used.
     *
     * @param string $unloadingDurationPerUnit
     */
    public function setUnloadingDurationPerUnit($unloadingDurationPerUnit)
    {
        $this->unloadingDurationPerUnit = $unloadingDurationPerUnit;
    }
    /**
     * longitude of order location
     *
     * @return double
     */
    public function getX()
    {
        return $this->x;
    }

    /**
     * longitude of order location
     *
     * @param double $x
     */
    public function setX($x)
    {
        $this->x = $x;
    }
    /**
     * latitude of order location
     *
     * @return double
     */
    public function getY()
    {
        return $this->y;
    }

    /**
     * latitude of order location
     *
     * @param double $y
     */
    public function setY($y)
    {
        $this->y = $y;
    }
    /**
     * Indicates whether the order should scheduled or not
       * 
       * **Default : ** True.
     *
     * @return boolean
     */
    public function getActive()
    {
        return $this->active;
    }

    /**
     * Indicates whether the order should scheduled or not
       * 
       * **Default : ** True.
     *
     * @param boolean $active
     */
    public function setActive($active)
    {
        $this->active = $active;
    }
    /**
     * Whole visit ends before time window end.
       * 
       * Use this constraint if you want that a visit ends before the end of the
       * time window.
       * 
       * **Default : ** false.
     *
     * @return boolean
     */
    public function getWholeVisitInTimeWindow()
    {
        return $this->wholeVisitInTimeWindow;
    }

    /**
     * Whole visit ends before time window end.
       * 
       * Use this constraint if you want that a visit ends before the end of the
       * time window.
       * 
       * **Default : ** false.
     *
     * @param boolean $wholeVisitInTimeWindow
     */
    public function setWholeVisitInTimeWindow($wholeVisitInTimeWindow)
    {
        $this->wholeVisitInTimeWindow = $wholeVisitInTimeWindow;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getLabel()
    {
        return $this->label;
    }

    /**
     * (no documentation provided)
     *
     * @param string $label
     */
    public function setLabel($label)
    {
        $this->label = $label;
    }
    /**
     * first order assignment (specifying resource, day and position in route).
       * 
       * Use it to compare optimization result with a previous optimization
       * 
       * **Warning : ** used only if startFromEvaluationInfo is set to true in
       * options.
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSEvaluationInfos
     */
    public function getEvaluationInfos()
    {
        return $this->evaluationInfos;
    }

    /**
     * first order assignment (specifying resource, day and position in route).
       * 
       * Use it to compare optimization result with a previous optimization
       * 
       * **Warning : ** used only if startFromEvaluationInfo is set to true in
       * options.
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSEvaluationInfos $evaluationInfos
     */
    public function setEvaluationInfos($evaluationInfos)
    {
        $this->evaluationInfos = $evaluationInfos;
    }
    /**
     * The possible visit days related to each visit time window.
       * 
       * Use this constraint to specify the possible visit days of a customer
       * referring to a visit time window. It must be related to the
       * tsResourceWorkDays constraint of the resources, as resources work days
       * define the planning period. You can plan visits on a 64-days-long period
       * max.
       * 
       * **Type : ** array of string values containing visit days separated with
       * commas (like &quot;1, 2, 5&quot; or &quot;4, 20/05/2010&quot;) or intervals (like &quot;1-10&quot;,
       * &quot;2=&gt;5&quot; or &quot;22/05/2010=&gt;03/06/2010&quot;). For day intervals, prefer the &quot;=&gt;&quot;
       * separator. Be carrefull, if the separator of date is - then &quot;1-5&quot;
       * corresponds to May the 1st of the current year. 1 is the first day of the
       * planning period, the corresponding date, if any, is defined by the oldest
       * date, for all resources, in the tsResourceWorkDays constraint. No date in
       * the possible visit days description can precede the first day of the
       * planning period defined by the resources (which is day 1). Default:
       * 1=&gt;64.
       * 
       * You can set up to 4 sets of visit days in this array. If you define
       * several time windows, each time window will apply to corresponding set of
       * possible days : first time window applies to first possible days set,
       * second time window applies to second possible days set, etc.
       * 
       * **Example : **
       * 
       * - Set it to &quot;1&quot; (or &quot;14/05/2010) when a customer must be visited on the
       * first day of the planning period.
       * 
       * - Set it to &quot;1, 2, 4, 5&quot; (or
       * &quot;14/05/2010,15/05/2010,17/05/2010,18/05/2010&quot;) if the customer cannot be
       * visited on the third day of a five days planning period.
       * 
       * - Set it to &quot;1=&gt;5&quot; (or &quot;14/05/2010=&gt;18/05/2010&quot;) to define a 5-days long
       * period during which the customer can be visited.
     *
     * @return string[]
     */
    public function getPossibleVisitDaysList()
    {
        return $this->possibleVisitDaysList;
    }

    /**
     * The possible visit days related to each visit time window.
       * 
       * Use this constraint to specify the possible visit days of a customer
       * referring to a visit time window. It must be related to the
       * tsResourceWorkDays constraint of the resources, as resources work days
       * define the planning period. You can plan visits on a 64-days-long period
       * max.
       * 
       * **Type : ** array of string values containing visit days separated with
       * commas (like &quot;1, 2, 5&quot; or &quot;4, 20/05/2010&quot;) or intervals (like &quot;1-10&quot;,
       * &quot;2=&gt;5&quot; or &quot;22/05/2010=&gt;03/06/2010&quot;). For day intervals, prefer the &quot;=&gt;&quot;
       * separator. Be carrefull, if the separator of date is - then &quot;1-5&quot;
       * corresponds to May the 1st of the current year. 1 is the first day of the
       * planning period, the corresponding date, if any, is defined by the oldest
       * date, for all resources, in the tsResourceWorkDays constraint. No date in
       * the possible visit days description can precede the first day of the
       * planning period defined by the resources (which is day 1). Default:
       * 1=&gt;64.
       * 
       * You can set up to 4 sets of visit days in this array. If you define
       * several time windows, each time window will apply to corresponding set of
       * possible days : first time window applies to first possible days set,
       * second time window applies to second possible days set, etc.
       * 
       * **Example : **
       * 
       * - Set it to &quot;1&quot; (or &quot;14/05/2010) when a customer must be visited on the
       * first day of the planning period.
       * 
       * - Set it to &quot;1, 2, 4, 5&quot; (or
       * &quot;14/05/2010,15/05/2010,17/05/2010,18/05/2010&quot;) if the customer cannot be
       * visited on the third day of a five days planning period.
       * 
       * - Set it to &quot;1=&gt;5&quot; (or &quot;14/05/2010=&gt;18/05/2010&quot;) to define a 5-days long
       * period during which the customer can be visited.
     *
     * @param string[] $possibleVisitDaysList
     */
    public function setPossibleVisitDaysList($possibleVisitDaysList)
    {
        $this->possibleVisitDaysList = $possibleVisitDaysList;
    }
    /**
     * The maximum number of days required between two visits of a same order.
       * 
       * Use this constraint in case of frequency order to specify how many days
       * at most should be left between two visits of the order.
       * 
       * **Type : ** integer
       * 
       * **Max : ** 2,147,483.
     *
     * @return integer
     */
    public function getTsOrderMaximumSpacing()
    {
        return $this->tsOrderMaximumSpacing;
    }

    /**
     * The maximum number of days required between two visits of a same order.
       * 
       * Use this constraint in case of frequency order to specify how many days
       * at most should be left between two visits of the order.
       * 
       * **Type : ** integer
       * 
       * **Max : ** 2,147,483.
     *
     * @param integer $tsOrderMaximumSpacing
     */
    public function setTsOrderMaximumSpacing($tsOrderMaximumSpacing)
    {
        $this->tsOrderMaximumSpacing = $tsOrderMaximumSpacing;
    }
    /**
     * The minimum number of days required between two visits of a same order.
       * 
       * Use this constraint in case of frequency order to specify how many days
       * at least should be left between two visits of the order.
       * 
       * **Type : ** integer
       * 
       * **Default : ** 0 **Max : ** 2,147,483.
       * 
       * **Warning : ** if the number of occurences of the frequency is more than
       * one, the constraints tsOrderLastVisit and tsOrderMinimumSpacing are not
       * considered.
     *
     * @return integer
     */
    public function getTsOrderMinimumSpacing()
    {
        return $this->tsOrderMinimumSpacing;
    }

    /**
     * The minimum number of days required between two visits of a same order.
       * 
       * Use this constraint in case of frequency order to specify how many days
       * at least should be left between two visits of the order.
       * 
       * **Type : ** integer
       * 
       * **Default : ** 0 **Max : ** 2,147,483.
       * 
       * **Warning : ** if the number of occurences of the frequency is more than
       * one, the constraints tsOrderLastVisit and tsOrderMinimumSpacing are not
       * considered.
     *
     * @param integer $tsOrderMinimumSpacing
     */
    public function setTsOrderMinimumSpacing($tsOrderMinimumSpacing)
    {
        $this->tsOrderMinimumSpacing = $tsOrderMinimumSpacing;
    }
    /**
     * The number of days before the beginning of the planning the last visit
       * belonging to the order has been performed
       * 
       * Use this constraint in case of a frequency order to specify from how many
       * days the last visit was performed before starting the current planning.
       * The default value indicates this constraint is to be unused in the
       * planning.
       * 
       * **Type : ** negative integer
       * 
       * **Default : ** 0 **Max : ** -2,147,483.
       * 
       * **Example : **
       * 
       * If *tsOrderLastVisit* = -2, the last visit of the same order has been
       * performed two days ago.
       * 
       * **Warning : ** if the number of occurences of the frequency is more than
       * one, the constraints tsOrderLastVisit and tsOrderMinimumSpacing are not
       * considered.
     *
     * @return integer
     */
    public function getTsOrderLastVisit()
    {
        return $this->tsOrderLastVisit;
    }

    /**
     * The number of days before the beginning of the planning the last visit
       * belonging to the order has been performed
       * 
       * Use this constraint in case of a frequency order to specify from how many
       * days the last visit was performed before starting the current planning.
       * The default value indicates this constraint is to be unused in the
       * planning.
       * 
       * **Type : ** negative integer
       * 
       * **Default : ** 0 **Max : ** -2,147,483.
       * 
       * **Example : **
       * 
       * If *tsOrderLastVisit* = -2, the last visit of the same order has been
       * performed two days ago.
       * 
       * **Warning : ** if the number of occurences of the frequency is more than
       * one, the constraints tsOrderLastVisit and tsOrderMinimumSpacing are not
       * considered.
     *
     * @param integer $tsOrderLastVisit
     */
    public function setTsOrderLastVisit($tsOrderLastVisit)
    {
        $this->tsOrderLastVisit = $tsOrderLastVisit;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getCustomerId()
    {
        return $this->customerId;
    }

    /**
     * (no documentation provided)
     *
     * @param string $customerId
     */
    public function setCustomerId($customerId)
    {
        $this->customerId = $customerId;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getEmail()
    {
        return $this->email;
    }

    /**
     * (no documentation provided)
     *
     * @param string $email
     */
    public function setEmail($email)
    {
        $this->email = $email;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getPhone()
    {
        return $this->phone;
    }

    /**
     * (no documentation provided)
     *
     * @param string $phone
     */
    public function setPhone($phone)
    {
        $this->phone = $phone;
    }
    /**
     * This constraint lets you chain visits. Two chained visits will be performed the same day by the same driver.
       * The visit on which this constraint is defined will be placed after the one it defines. If a visit from the chain cannot be placed, then none will be.
       * You can specify one order id or several order ids (comma separated string).
     *
     * @return string
     */
    public function getTsOrderBefore()
    {
        return $this->tsOrderBefore;
    }

    /**
     * This constraint lets you chain visits. Two chained visits will be performed the same day by the same driver.
       * The visit on which this constraint is defined will be placed after the one it defines. If a visit from the chain cannot be placed, then none will be.
       * You can specify one order id or several order ids (comma separated string).
     *
     * @param string $tsOrderBefore
     */
    public function setTsOrderBefore($tsOrderBefore)
    {
        $this->tsOrderBefore = $tsOrderBefore;
    }
    /**
     * This constraint specifies the maximum spacing between the two chained visits.
       * 
       * * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
       * 
       * **Default : ** not used.
     *
     * @return string
     */
    public function getTsOrderBeforeMaxTimeSpacing()
    {
        return $this->tsOrderBeforeMaxTimeSpacing;
    }

    /**
     * This constraint specifies the maximum spacing between the two chained visits.
       * 
       * * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
       * 
       * **Default : ** not used.
     *
     * @param string $tsOrderBeforeMaxTimeSpacing
     */
    public function setTsOrderBeforeMaxTimeSpacing($tsOrderBeforeMaxTimeSpacing)
    {
        $this->tsOrderBeforeMaxTimeSpacing = $tsOrderBeforeMaxTimeSpacing;
    }
    /**
     * This constraint specifies the minimum spacing between the two chained visits.
       * 
       * * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
       * 
       * **Default : ** not used.
     *
     * @return string
     */
    public function getTsOrderBeforeMinTimeSpacing()
    {
        return $this->tsOrderBeforeMinTimeSpacing;
    }

    /**
     * This constraint specifies the minimum spacing between the two chained visits.
       * 
       * * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
       * 
       * **Default : ** not used.
     *
     * @param string $tsOrderBeforeMinTimeSpacing
     */
    public function setTsOrderBeforeMinTimeSpacing($tsOrderBeforeMinTimeSpacing)
    {
        $this->tsOrderBeforeMinTimeSpacing = $tsOrderBeforeMinTimeSpacing;
    }
    /**
     * Boolean.True if a visit can receive notification email/sms
     *
     * @return boolean
     */
    public function getGetNotifications()
    {
        return $this->getNotifications;
    }

    /**
     * Boolean.True if a visit can receive notification email/sms
     *
     * @param boolean $getNotifications
     */
    public function setGetNotifications($getNotifications)
    {
        $this->getNotifications = $getNotifications;
    }
    /**
     * If true, force the use of the specified day, resource and start time (new solver only)
       * 
       * You must specify orderOriginalResourceId and orderOriginalVisitDay of evaluationInfo and set the time window to the exact time (respecting the duration)
     *
     * @return boolean
     */
    public function getTsOrderFixed()
    {
        return $this->tsOrderFixed;
    }

    /**
     * If true, force the use of the specified day, resource and start time (new solver only)
       * 
       * You must specify orderOriginalResourceId and orderOriginalVisitDay of evaluationInfo and set the time window to the exact time (respecting the duration)
     *
     * @param boolean $tsOrderFixed
     */
    public function setTsOrderFixed($tsOrderFixed)
    {
        $this->tsOrderFixed = $tsOrderFixed;
    }
    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Model\ScanItem[]
     */
    public function getScanItems()
    {
        return $this->scanItems;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Model\ScanItem[] $scanItems
     */
    public function setScanItems($scanItems)
    {
        $this->scanItems = $scanItems;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getInvoiceId()
    {
        return $this->invoiceId;
    }

    /**
     * (no documentation provided)
     *
     * @param string $invoiceId
     */
    public function setInvoiceId($invoiceId)
    {
        $this->invoiceId = $invoiceId;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getOriginalOperationalId()
    {
        return $this->originalOperationalId;
    }

    /**
     * (no documentation provided)
     *
     * @param string $originalOperationalId
     */
    public function setOriginalOperationalId($originalOperationalId)
    {
        $this->originalOperationalId = $originalOperationalId;
    }
    /**
     * This constraint specifies the maximum allowed delay (new solver only).
       * You must specify a cost per hour through the delayPenaltyPerHour constraint.
       * 
       * * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
       * 
       * **Default : ** not used.
     *
     * @return string
     */
    public function getMaxDelayTime()
    {
        return $this->maxDelayTime;
    }

    /**
     * This constraint specifies the maximum allowed delay (new solver only).
       * You must specify a cost per hour through the delayPenaltyPerHour constraint.
       * 
       * * **Type : ** Time (&quot;hh:mm&quot; or &quot;hh:mm:ss&quot;) or Integer (number of minutes).
       * 
       * **Default : ** not used.
     *
     * @param string $maxDelayTime
     */
    public function setMaxDelayTime($maxDelayTime)
    {
        $this->maxDelayTime = $maxDelayTime;
    }

    /**
     * Sets a known child element of TSOrder from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'allSkillsRequired') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->allSkillsRequired = $child;
            $happened = true;
        }
        else if (($xml->localName == 'assignResources') && (empty($xml->namespaceURI)) && (!$xml->isEmptyElement)) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc. in the wrapper
                }
        if (($xml->localName == 'resource') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->assignResources)) {
                $this->assignResources = array();
            }
            array_push($this->assignResources, $child);
            $happened = true;
        }
                $xml->read();
            }
            $happened = true;
        }
        else if (($xml->localName == 'assignCosts') && (empty($xml->namespaceURI)) && (!$xml->isEmptyElement)) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc. in the wrapper
                }
        if (($xml->localName == 'cost') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->assignCosts)) {
                $this->assignCosts = array();
            }
            array_push($this->assignCosts, $child);
            $happened = true;
        }
                $xml->read();
            }
            $happened = true;
        }
        else if (($xml->localName == 'documentReferences') && (empty($xml->namespaceURI)) && (!$xml->isEmptyElement)) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc. in the wrapper
                }
        if (($xml->localName == 'docRef') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->documentReferences)) {
                $this->documentReferences = array();
            }
            array_push($this->documentReferences, $child);
            $happened = true;
        }
                $xml->read();
            }
            $happened = true;
        }
        else if (($xml->localName == 'courierPenalty') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->courierPenalty = $child;
            $happened = true;
        }
        else if (($xml->localName == 'customDataMap') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->customDataMap = $child;
            $happened = true;
        }
        else if (($xml->localName == 'delayPenaltyPerHour') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->delayPenaltyPerHour = $child;
            $happened = true;
        }
        else if (($xml->localName == 'excludeResources') && (empty($xml->namespaceURI)) && (!$xml->isEmptyElement)) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc. in the wrapper
                }
        if (($xml->localName == 'resource') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->excludeResources)) {
                $this->excludeResources = array();
            }
            array_push($this->excludeResources, $child);
            $happened = true;
        }
                $xml->read();
            }
            $happened = true;
        }
        else if (($xml->localName == 'fixedVisitDuration') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->fixedVisitDuration = $child;
            $happened = true;
        }
        else if (($xml->localName == 'frequency') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->frequency = $child;
            $happened = true;
        }
        else if (($xml->localName == 'id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'minDuration') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->minDuration = $child;
            $happened = true;
        }
        else if (($xml->localName == 'minPartDuration') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->minPartDuration = $child;
            $happened = true;
        }
        else if (($xml->localName == 'punctuality') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->punctuality = $child;
            $happened = true;
        }
        else if (($xml->localName == 'quantities') && (empty($xml->namespaceURI)) && (!$xml->isEmptyElement)) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc. in the wrapper
                }
        if (($xml->localName == 'quantity') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->quantities)) {
                $this->quantities = array();
            }
            array_push($this->quantities, $child);
            $happened = true;
        }
                $xml->read();
            }
            $happened = true;
        }
        else if (($xml->localName == 'requiredSkills') && (empty($xml->namespaceURI)) && (!$xml->isEmptyElement)) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc. in the wrapper
                }
        if (($xml->localName == 'requiredSkill') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->requiredSkills)) {
                $this->requiredSkills = array();
            }
            array_push($this->requiredSkills, $child);
            $happened = true;
        }
                $xml->read();
            }
            $happened = true;
        }
        else if (($xml->localName == 'resourceCompatibility') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->resourceCompatibility = $child;
            $happened = true;
        }
        else if (($xml->localName == 'sequenceNumber') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->sequenceNumber = $child;
            $happened = true;
        }
        else if (($xml->localName == 'timeWindows') && (empty($xml->namespaceURI)) && (!$xml->isEmptyElement)) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc. in the wrapper
                }
        if (($xml->localName == 'TSTimeWindow') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTimeWindow($xml);
            if (!isset($this->timeWindows)) {
                $this->timeWindows = array();
            }
            array_push($this->timeWindows, $child);
            $happened = true;
        }
                $xml->read();
            }
            $happened = true;
        }
        else if (($xml->localName == 'travelTimeModifier') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTravelTimeModifier($xml);
            $this->travelTimeModifier = $child;
            $happened = true;
        }
        else if (($xml->localName == 'type') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->type = $child;
            $happened = true;
        }
        else if (($xml->localName == 'unloadingDurationPerUnit') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->unloadingDurationPerUnit = $child;
            $happened = true;
        }
        else if (($xml->localName == 'x') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->x = $child;
            $happened = true;
        }
        else if (($xml->localName == 'y') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->y = $child;
            $happened = true;
        }
        else if (($xml->localName == 'active') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->active = $child;
            $happened = true;
        }
        else if (($xml->localName == 'wholeVisitInTimeWindow') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->wholeVisitInTimeWindow = $child;
            $happened = true;
        }
        else if (($xml->localName == 'label') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->label = $child;
            $happened = true;
        }
        else if (($xml->localName == 'evaluationInfos') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSEvaluationInfos($xml);
            $this->evaluationInfos = $child;
            $happened = true;
        }
        else if (($xml->localName == 'possibleVisitDays') && (empty($xml->namespaceURI)) && (!$xml->isEmptyElement)) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc. in the wrapper
                }
        if (($xml->localName == 'possibleVisitDaysList') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->possibleVisitDaysList)) {
                $this->possibleVisitDaysList = array();
            }
            array_push($this->possibleVisitDaysList, $child);
            $happened = true;
        }
                $xml->read();
            }
            $happened = true;
        }
        else if (($xml->localName == 'tsOrderMaximumSpacing') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->tsOrderMaximumSpacing = $child;
            $happened = true;
        }
        else if (($xml->localName == 'tsOrderMinimumSpacing') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->tsOrderMinimumSpacing = $child;
            $happened = true;
        }
        else if (($xml->localName == 'tsOrderLastVisit') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->tsOrderLastVisit = $child;
            $happened = true;
        }
        else if (($xml->localName == 'customerId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->customerId = $child;
            $happened = true;
        }
        else if (($xml->localName == 'email') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->email = $child;
            $happened = true;
        }
        else if (($xml->localName == 'phone') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->phone = $child;
            $happened = true;
        }
        else if (($xml->localName == 'tsOrderBefore') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->tsOrderBefore = $child;
            $happened = true;
        }
        else if (($xml->localName == 'tsOrderBeforeMaxTimeSpacing') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->tsOrderBeforeMaxTimeSpacing = $child;
            $happened = true;
        }
        else if (($xml->localName == 'tsOrderBeforeMinTimeSpacing') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->tsOrderBeforeMinTimeSpacing = $child;
            $happened = true;
        }
        else if (($xml->localName == 'getNotifications') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->getNotifications = $child;
            $happened = true;
        }
        else if (($xml->localName == 'tsOrderFixed') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->tsOrderFixed = $child;
            $happened = true;
        }
        else if (($xml->localName == 'scanItems') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\ScanItem($xml);
            if (!isset($this->scanItems)) {
                $this->scanItems = array();
            }
            array_push($this->scanItems, $child);
            $happened = true;
        }
        else if (($xml->localName == 'invoiceId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->invoiceId = $child;
            $happened = true;
        }
        else if (($xml->localName == 'originalOperationalId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->originalOperationalId = $child;
            $happened = true;
        }
        else if (($xml->localName == 'maxDelayTime') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->maxDelayTime = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of TSOrder from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes the contents of this TSOrder to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->allSkillsRequired) {
            $writer->startElementNs(null, 'allSkillsRequired', null);
            $writer->text($this->allSkillsRequired);
            $writer->endElement();
        }
        if ($this->assignResources) {
            $writer->startElementNs(null, 'assignResources', null);
            foreach ($this->assignResources as $i => $x) {
                $writer->startElementNs(null, 'resource', null);
                $writer->text($x);
                $writer->endElement();
            }
            $writer->endElement();
        }
        if ($this->assignCosts) {
            $writer->startElementNs(null, 'assignCosts', null);
            foreach ($this->assignCosts as $i => $x) {
                $writer->startElementNs(null, 'cost', null);
                $writer->text($x);
                $writer->endElement();
            }
            $writer->endElement();
        }
        if ($this->documentReferences) {
            $writer->startElementNs(null, 'documentReferences', null);
            foreach ($this->documentReferences as $i => $x) {
                $writer->startElementNs(null, 'docRef', null);
                $writer->text($x);
                $writer->endElement();
            }
            $writer->endElement();
        }
        if ($this->courierPenalty) {
            $writer->startElementNs(null, 'courierPenalty', null);
            $writer->text($this->courierPenalty);
            $writer->endElement();
        }
        if ($this->customDataMap) {
            $writer->startElementNs(null, 'customDataMap', null);
            $writer->text($this->customDataMap);
            $writer->endElement();
        }
        if ($this->delayPenaltyPerHour) {
            $writer->startElementNs(null, 'delayPenaltyPerHour', null);
            $writer->text($this->delayPenaltyPerHour);
            $writer->endElement();
        }
        if ($this->excludeResources) {
            $writer->startElementNs(null, 'excludeResources', null);
            foreach ($this->excludeResources as $i => $x) {
                $writer->startElementNs(null, 'resource', null);
                $writer->text($x);
                $writer->endElement();
            }
            $writer->endElement();
        }
        if ($this->fixedVisitDuration) {
            $writer->startElementNs(null, 'fixedVisitDuration', null);
            $writer->text($this->fixedVisitDuration);
            $writer->endElement();
        }
        if ($this->frequency) {
            $writer->startElementNs(null, 'frequency', null);
            $writer->text($this->frequency);
            $writer->endElement();
        }
        if ($this->id) {
            $writer->startElementNs(null, 'id', null);
            $writer->text($this->id);
            $writer->endElement();
        }
        if ($this->minDuration) {
            $writer->startElementNs(null, 'minDuration', null);
            $writer->text($this->minDuration);
            $writer->endElement();
        }
        if ($this->minPartDuration) {
            $writer->startElementNs(null, 'minPartDuration', null);
            $writer->text($this->minPartDuration);
            $writer->endElement();
        }
        if ($this->punctuality) {
            $writer->startElementNs(null, 'punctuality', null);
            $writer->text($this->punctuality);
            $writer->endElement();
        }
        if ($this->quantities) {
            $writer->startElementNs(null, 'quantities', null);
            foreach ($this->quantities as $i => $x) {
                $writer->startElementNs(null, 'quantity', null);
                $writer->text($x);
                $writer->endElement();
            }
            $writer->endElement();
        }
        if ($this->requiredSkills) {
            $writer->startElementNs(null, 'requiredSkills', null);
            foreach ($this->requiredSkills as $i => $x) {
                $writer->startElementNs(null, 'requiredSkill', null);
                $writer->text($x);
                $writer->endElement();
            }
            $writer->endElement();
        }
        if ($this->resourceCompatibility) {
            $writer->startElementNs(null, 'resourceCompatibility', null);
            $writer->text($this->resourceCompatibility);
            $writer->endElement();
        }
        if ($this->sequenceNumber) {
            $writer->startElementNs(null, 'sequenceNumber', null);
            $writer->text($this->sequenceNumber);
            $writer->endElement();
        }
        if ($this->timeWindows) {
            $writer->startElementNs(null, 'timeWindows', null);
            foreach ($this->timeWindows as $i => $x) {
                $writer->startElementNs(null, 'TSTimeWindow', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
            $writer->endElement();
        }
        if ($this->travelTimeModifier) {
            $writer->startElementNs(null, 'travelTimeModifier', null);
            $this->travelTimeModifier->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->type) {
            $writer->startElementNs(null, 'type', null);
            $writer->text($this->type);
            $writer->endElement();
        }
        if ($this->unloadingDurationPerUnit) {
            $writer->startElementNs(null, 'unloadingDurationPerUnit', null);
            $writer->text($this->unloadingDurationPerUnit);
            $writer->endElement();
        }
        if ($this->x) {
            $writer->startElementNs(null, 'x', null);
            $writer->text($this->x);
            $writer->endElement();
        }
        if ($this->y) {
            $writer->startElementNs(null, 'y', null);
            $writer->text($this->y);
            $writer->endElement();
        }
        if ($this->active) {
            $writer->startElementNs(null, 'active', null);
            $writer->text($this->active);
            $writer->endElement();
        }
        if ($this->wholeVisitInTimeWindow) {
            $writer->startElementNs(null, 'wholeVisitInTimeWindow', null);
            $writer->text($this->wholeVisitInTimeWindow);
            $writer->endElement();
        }
        if ($this->label) {
            $writer->startElementNs(null, 'label', null);
            $writer->text($this->label);
            $writer->endElement();
        }
        if ($this->evaluationInfos) {
            $writer->startElementNs(null, 'evaluationInfos', null);
            $this->evaluationInfos->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->possibleVisitDaysList) {
            $writer->startElementNs(null, 'possibleVisitDays', null);
            foreach ($this->possibleVisitDaysList as $i => $x) {
                $writer->startElementNs(null, 'possibleVisitDaysList', null);
                $writer->text($x);
                $writer->endElement();
            }
            $writer->endElement();
        }
        if ($this->tsOrderMaximumSpacing) {
            $writer->startElementNs(null, 'tsOrderMaximumSpacing', null);
            $writer->text($this->tsOrderMaximumSpacing);
            $writer->endElement();
        }
        if ($this->tsOrderMinimumSpacing) {
            $writer->startElementNs(null, 'tsOrderMinimumSpacing', null);
            $writer->text($this->tsOrderMinimumSpacing);
            $writer->endElement();
        }
        if ($this->tsOrderLastVisit) {
            $writer->startElementNs(null, 'tsOrderLastVisit', null);
            $writer->text($this->tsOrderLastVisit);
            $writer->endElement();
        }
        if ($this->customerId) {
            $writer->startElementNs(null, 'customerId', null);
            $writer->text($this->customerId);
            $writer->endElement();
        }
        if ($this->email) {
            $writer->startElementNs(null, 'email', null);
            $writer->text($this->email);
            $writer->endElement();
        }
        if ($this->phone) {
            $writer->startElementNs(null, 'phone', null);
            $writer->text($this->phone);
            $writer->endElement();
        }
        if ($this->tsOrderBefore) {
            $writer->startElementNs(null, 'tsOrderBefore', null);
            $writer->text($this->tsOrderBefore);
            $writer->endElement();
        }
        if ($this->tsOrderBeforeMaxTimeSpacing) {
            $writer->startElementNs(null, 'tsOrderBeforeMaxTimeSpacing', null);
            $writer->text($this->tsOrderBeforeMaxTimeSpacing);
            $writer->endElement();
        }
        if ($this->tsOrderBeforeMinTimeSpacing) {
            $writer->startElementNs(null, 'tsOrderBeforeMinTimeSpacing', null);
            $writer->text($this->tsOrderBeforeMinTimeSpacing);
            $writer->endElement();
        }
        if ($this->getNotifications) {
            $writer->startElementNs(null, 'getNotifications', null);
            $writer->text($this->getNotifications);
            $writer->endElement();
        }
        if ($this->tsOrderFixed) {
            $writer->startElementNs(null, 'tsOrderFixed', null);
            $writer->text($this->tsOrderFixed);
            $writer->endElement();
        }
        if ($this->scanItems) {
            foreach ($this->scanItems as $i => $x) {
                $writer->startElementNs(null, 'scanItems', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->invoiceId) {
            $writer->startElementNs(null, 'invoiceId', null);
            $writer->text($this->invoiceId);
            $writer->endElement();
        }
        if ($this->originalOperationalId) {
            $writer->startElementNs(null, 'originalOperationalId', null);
            $writer->text($this->originalOperationalId);
            $writer->endElement();
        }
        if ($this->maxDelayTime) {
            $writer->startElementNs(null, 'maxDelayTime', null);
            $writer->text($this->maxDelayTime);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Optim;

/**
 * (no documentation provided)
 */
class SectorizationMethod
{

    /**
     * 
     */
    const TIME = "TIME";

    /**
     * 
     */
    const DISTANCE = "DISTANCE";
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Optim;

/**
 * (no documentation provided)
 */
class BalanceType
{

    /**
     * 
     */
    const NONE = "NONE";

    /**
     * 
     */
    const ORDERS = "ORDERS";

    /**
     * 
     */
    const HOURS = "HOURS";

    /**
     * 
     */
    const QUANTITY = "QUANTITY";
}

namespace Com\Geoconcept\Toursolver\Model\Toursolver\Optim;

/**
 * (no documentation provided)
 */
class TSDepot extends \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSObject
{

    /**
     * The unique identifier of the depot
     *
     * @var string
     */
    private $id;

    /**
     * The depot days of opening, related to the nth depot time window.
     * 
     * Use this constraint to specify the days of operation of a depot referring
     * to a depot time window. It must be related to the tsResourceWorkDays
     * constraint of the resources, as resources work days define the planning
     * period. Depot may be opened on a 64-days long period max, from day 1 to
     * day 64.
     * 
     * **Type : ** string value containing days separated with commas (like &quot;1, 2, 5&quot;
     * or &quot;4, 20/05/2010&quot;) or intervals (like &quot;1-10&quot;, &quot;2=&gt;5&quot; or
     * &quot;22/05/2010=&gt;03/06/2010&quot;). For day intervals, prefer the &quot;=&gt;&quot; separator.
     * 1 is the first day of the planning period, the corresponding date, if
     * any, is defined by the oldest date, for all resources, in the
     * tsResourceWorkDays constraint. No date in the depots days of opening
     * description can precede the first day of the planning period defined by
     * the resources (which is day 1). **Default : ** 1=&gt;64.
     * 
     * 
     * ** Example : **
     * 
     * * Set it to &quot;1&quot; (or &quot;14/05/2010) when a depot is opened on the first
     * day of the planning period. Set it to &quot;1, 2, 4, 5&quot; (or
     * &quot;14/05/2010,15/05/2010,17/05/2010,18/05/2010&quot;) if depot may not be
     * visited on the third day of a five-days planning period.
     * 
     * * Set it to &quot;1=&gt;5&quot; (or &quot;14/05/2010=&gt;18/05/2010&quot;) to define a 5-days
     * long period during which the depot is opened.
     *
     * @var string[]
     */
    private $openingDaysList;

    /**
     * The depot time windows.
     * 
     * Use this constraint to specify a depot time window during which the depot
     * is opened. A depot time window is defined by its start time, its end time
     * and days of opening. The start time of a depot time window is the first
     * instant when a resource can enter the depot. Its end time is the last
     * instant when a resource can enter the depot (but it may leave it
     * afterward). You can specify up to 4 depot time windows for each depot.
     * 
     * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** &quot;00:00:00&quot;.
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTimeWindow[]
     */
    private $timeWindows;

    /**
     * Indicates whether a depot is included in the planning process or not.
     * 
     * This constraint enables you to easily modify your optimization problem
     * configuration without having to add nor delete your original data.
     * 
     * * Set it to True to include a depot element in the planning process.
     * 
     * * Set it to False to ignore it: it will not be used in the planning.
     *
     * @var boolean
     */
    private $availability;

    /**
     * Lists the resources that can use the depot.
     * 
     * **Type : ** string array.
     * 
     * **Default : ** Empty array: no resource can use the depot.
     * 
     * **Example : ** Specify [&quot;Vehicle 1&quot;,&quot;Vehicle 2&quot;] to allow only the resources with
     * tags &quot;Vehicle 1&quot; and &quot;Vehicle 2&quot; to use the depot.
     *
     * @var string
     */
    private $resourceNames;

    /**
     * The list of resources excluded from the depot.
     * 
     * Use this constraint to specify a list of resources that can not use the depot.
     * 
     * **Type : ** string array.
     * **Default: ** Empty array: no resource is excluded from the depot
     *
     * @var string
     */
    private $excludeResources;

    /**
     * Indicates the value of the travel time modifier.
     * 
     * When reaching a location situated in a large city, one may want to take
     * into account driving difficulties, such as narrow streets and congestion.
     * The travel time modifier enables to increase the travel times around a
     * location. It is describes by three values. The value by which multiply
     * the travel times around the location (tsDepotTravelTimeModifierValue),
     * the portion of the travel time on which the modifier applies
     * (tsDepotTravelTimeModifierLength) an offset to add to any travel duration
     * leaving or reaching the location (tsDepotTravelTimeModifierOffSet).
     * 
     * **Example : **
     * 
     * * Set tsResource travelTimeModifierValue to 1.5,
     * tsResource travelTimeModifierLength to 300 and
     * tsResource travelTimeModifierOffSet to 60 for Resource 1
     * 
     * * Set tsDepot travelTimeModifierValue to 2,
     * tsDepot travelTimeModifierLength to 420 and
     * tsDepot travelTimeModifierOffSet to 0 for Depot 1 If the initial travel
     * duration between Resource 1 and Depot 1 was 1000, one obtains a travel
     * time 360 * 1.5 + 60 + 280 + 420 * 2 + 0 = 1660
     * 
     * **Type : ** float, **Default : ** 1
     *
     * @var \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTravelTimeModifier
     */
    private $travelTimeModifier;

    /**
     * The fixed duration for a resource to load at depot. Use this constraint
     * to specify how long takes any resource reload at the depot. You can
     * specify an additional duration according to the quantity to reload,
     * using loadingDurationPerUnit.
     * 
     * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** &quot;00:00:00&quot;.
     * 
     * **Example : **
     * 
     * tsDepot fixedVisitDuration = &quot;00:30:00&quot; indicates that 30 minutes are
     * needed to load at the depot. tsDepot loadingDurationPerUnit = 120
     * indicates that 120 seconds are needed to load one unit. If the quantity to
     * reload is 8, for instance, the variable part is 120*8. 16 minutes are
     * required to load at the depot. Total load time = 30 minutes + 16 minutes
     * = 46 minutes accounted for this reload break.
     *
     * @var string
     */
    private $fixedLoadingDuration;

    /**
     * The time needed to load a unit of product. This constraint is added to
     * the fixed part of the loading duration: it depends on the total quantity
     * to load.
     * 
     * **Type : ** &quot;hh:mm:ss&quot;, DateTime, Integer (number of seconds). **Default : ** 0.
     *
     * @var string
     */
    private $loadingDurationPerUnit;

    /**
     * Depot priority.
     * 
     * Use this constraint to specify a priority on the depot. If two depots are nearby the system considers the one with the highest priority
     * 
     * **Type : * integer
     *
     * @var integer
     */
    private $priority;

    /**
     * The list of the products a depots contains.
     * 
     * Use this constraint when a depot must be affected to a specific
     * kind of resource: these resources will have to provide the required
     * required to be able to load at the depot.
     * 
     * **Type : ** string (as a list of products separated with commas).
     * 
     * **Default : ** none
     *
     * @var string
     */
    private $requiredProducts;

    /**
     * Indicates whether a resource must provide all required products or one at least.
     * 
     * Set it to True to indicate that a resource must provide all the depot required
     * products. Set it to False to indicate that a resource must provide at least one
     * of the depot required products.
     * 
     * **Type : ** boolean **Default : ** True
     *
     * @var boolean
     */
    private $allProductsRequired;

    /**
     * The available quantities of products available at the depot.
     * 
     * You can specify up to 24 quantities
     * 
     * **Type : ** float array
     *
     * @var integer[]
     */
    private $deliveryQuantities;

    /**
     * The available space for a product available at the depot.
     * 
     * You can specify up to 24 values.
     * 
     * **Type : ** float array
     *
     * @var integer[]
     */
    private $pickupQuantities;

    /**
     * longitude WGS84 of depot
     *
     * @var double
     */
    private $x;

    /**
     * latitude WGS84 of depot
     *
     * @var double
     */
    private $y;

    /**
     * Constructs a TSDepot from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * The unique identifier of the depot
     *
     * @return string
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * The unique identifier of the depot
     *
     * @param string $id
     */
    public function setId($id)
    {
        $this->id = $id;
    }
    /**
     * The depot days of opening, related to the nth depot time window.
       * 
       * Use this constraint to specify the days of operation of a depot referring
       * to a depot time window. It must be related to the tsResourceWorkDays
       * constraint of the resources, as resources work days define the planning
       * period. Depot may be opened on a 64-days long period max, from day 1 to
       * day 64.
       * 
       * **Type : ** string value containing days separated with commas (like &quot;1, 2, 5&quot;
       * or &quot;4, 20/05/2010&quot;) or intervals (like &quot;1-10&quot;, &quot;2=&gt;5&quot; or
       * &quot;22/05/2010=&gt;03/06/2010&quot;). For day intervals, prefer the &quot;=&gt;&quot; separator.
       * 1 is the first day of the planning period, the corresponding date, if
       * any, is defined by the oldest date, for all resources, in the
       * tsResourceWorkDays constraint. No date in the depots days of opening
       * description can precede the first day of the planning period defined by
       * the resources (which is day 1). **Default : ** 1=&gt;64.
       * 
       * 
       * ** Example : **
       * 
       * * Set it to &quot;1&quot; (or &quot;14/05/2010) when a depot is opened on the first
       * day of the planning period. Set it to &quot;1, 2, 4, 5&quot; (or
       * &quot;14/05/2010,15/05/2010,17/05/2010,18/05/2010&quot;) if depot may not be
       * visited on the third day of a five-days planning period.
       * 
       * * Set it to &quot;1=&gt;5&quot; (or &quot;14/05/2010=&gt;18/05/2010&quot;) to define a 5-days
       * long period during which the depot is opened.
     *
     * @return string[]
     */
    public function getOpeningDaysList()
    {
        return $this->openingDaysList;
    }

    /**
     * The depot days of opening, related to the nth depot time window.
       * 
       * Use this constraint to specify the days of operation of a depot referring
       * to a depot time window. It must be related to the tsResourceWorkDays
       * constraint of the resources, as resources work days define the planning
       * period. Depot may be opened on a 64-days long period max, from day 1 to
       * day 64.
       * 
       * **Type : ** string value containing days separated with commas (like &quot;1, 2, 5&quot;
       * or &quot;4, 20/05/2010&quot;) or intervals (like &quot;1-10&quot;, &quot;2=&gt;5&quot; or
       * &quot;22/05/2010=&gt;03/06/2010&quot;). For day intervals, prefer the &quot;=&gt;&quot; separator.
       * 1 is the first day of the planning period, the corresponding date, if
       * any, is defined by the oldest date, for all resources, in the
       * tsResourceWorkDays constraint. No date in the depots days of opening
       * description can precede the first day of the planning period defined by
       * the resources (which is day 1). **Default : ** 1=&gt;64.
       * 
       * 
       * ** Example : **
       * 
       * * Set it to &quot;1&quot; (or &quot;14/05/2010) when a depot is opened on the first
       * day of the planning period. Set it to &quot;1, 2, 4, 5&quot; (or
       * &quot;14/05/2010,15/05/2010,17/05/2010,18/05/2010&quot;) if depot may not be
       * visited on the third day of a five-days planning period.
       * 
       * * Set it to &quot;1=&gt;5&quot; (or &quot;14/05/2010=&gt;18/05/2010&quot;) to define a 5-days
       * long period during which the depot is opened.
     *
     * @param string[] $openingDaysList
     */
    public function setOpeningDaysList($openingDaysList)
    {
        $this->openingDaysList = $openingDaysList;
    }
    /**
     * The depot time windows.
       * 
       * Use this constraint to specify a depot time window during which the depot
       * is opened. A depot time window is defined by its start time, its end time
       * and days of opening. The start time of a depot time window is the first
       * instant when a resource can enter the depot. Its end time is the last
       * instant when a resource can enter the depot (but it may leave it
       * afterward). You can specify up to 4 depot time windows for each depot.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** &quot;00:00:00&quot;.
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTimeWindow[]
     */
    public function getTimeWindows()
    {
        return $this->timeWindows;
    }

    /**
     * The depot time windows.
       * 
       * Use this constraint to specify a depot time window during which the depot
       * is opened. A depot time window is defined by its start time, its end time
       * and days of opening. The start time of a depot time window is the first
       * instant when a resource can enter the depot. Its end time is the last
       * instant when a resource can enter the depot (but it may leave it
       * afterward). You can specify up to 4 depot time windows for each depot.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** &quot;00:00:00&quot;.
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTimeWindow[] $timeWindows
     */
    public function setTimeWindows($timeWindows)
    {
        $this->timeWindows = $timeWindows;
    }
    /**
     * Indicates whether a depot is included in the planning process or not.
       * 
       * This constraint enables you to easily modify your optimization problem
       * configuration without having to add nor delete your original data.
       * 
       * * Set it to True to include a depot element in the planning process.
       * 
       * * Set it to False to ignore it: it will not be used in the planning.
     *
     * @return boolean
     */
    public function getAvailability()
    {
        return $this->availability;
    }

    /**
     * Indicates whether a depot is included in the planning process or not.
       * 
       * This constraint enables you to easily modify your optimization problem
       * configuration without having to add nor delete your original data.
       * 
       * * Set it to True to include a depot element in the planning process.
       * 
       * * Set it to False to ignore it: it will not be used in the planning.
     *
     * @param boolean $availability
     */
    public function setAvailability($availability)
    {
        $this->availability = $availability;
    }
    /**
     * Lists the resources that can use the depot.
       * 
       * **Type : ** string array.
       * 
       * **Default : ** Empty array: no resource can use the depot.
       * 
       * **Example : ** Specify [&quot;Vehicle 1&quot;,&quot;Vehicle 2&quot;] to allow only the resources with
       * tags &quot;Vehicle 1&quot; and &quot;Vehicle 2&quot; to use the depot.
     *
     * @return string
     */
    public function getResourceNames()
    {
        return $this->resourceNames;
    }

    /**
     * Lists the resources that can use the depot.
       * 
       * **Type : ** string array.
       * 
       * **Default : ** Empty array: no resource can use the depot.
       * 
       * **Example : ** Specify [&quot;Vehicle 1&quot;,&quot;Vehicle 2&quot;] to allow only the resources with
       * tags &quot;Vehicle 1&quot; and &quot;Vehicle 2&quot; to use the depot.
     *
     * @param string $resourceNames
     */
    public function setResourceNames($resourceNames)
    {
        $this->resourceNames = $resourceNames;
    }
    /**
     * The list of resources excluded from the depot.
       * 
       * Use this constraint to specify a list of resources that can not use the depot.
       * 
       * **Type : ** string array.
       * **Default: ** Empty array: no resource is excluded from the depot
     *
     * @return string
     */
    public function getExcludeResources()
    {
        return $this->excludeResources;
    }

    /**
     * The list of resources excluded from the depot.
       * 
       * Use this constraint to specify a list of resources that can not use the depot.
       * 
       * **Type : ** string array.
       * **Default: ** Empty array: no resource is excluded from the depot
     *
     * @param string $excludeResources
     */
    public function setExcludeResources($excludeResources)
    {
        $this->excludeResources = $excludeResources;
    }
    /**
     * Indicates the value of the travel time modifier.
       * 
       * When reaching a location situated in a large city, one may want to take
       * into account driving difficulties, such as narrow streets and congestion.
       * The travel time modifier enables to increase the travel times around a
       * location. It is describes by three values. The value by which multiply
       * the travel times around the location (tsDepotTravelTimeModifierValue),
       * the portion of the travel time on which the modifier applies
       * (tsDepotTravelTimeModifierLength) an offset to add to any travel duration
       * leaving or reaching the location (tsDepotTravelTimeModifierOffSet).
       * 
       * **Example : **
       * 
       * * Set tsResource travelTimeModifierValue to 1.5,
       * tsResource travelTimeModifierLength to 300 and
       * tsResource travelTimeModifierOffSet to 60 for Resource 1
       * 
       * * Set tsDepot travelTimeModifierValue to 2,
       * tsDepot travelTimeModifierLength to 420 and
       * tsDepot travelTimeModifierOffSet to 0 for Depot 1 If the initial travel
       * duration between Resource 1 and Depot 1 was 1000, one obtains a travel
       * time 360 * 1.5 + 60 + 280 + 420 * 2 + 0 = 1660
       * 
       * **Type : ** float, **Default : ** 1
     *
     * @return \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTravelTimeModifier
     */
    public function getTravelTimeModifier()
    {
        return $this->travelTimeModifier;
    }

    /**
     * Indicates the value of the travel time modifier.
       * 
       * When reaching a location situated in a large city, one may want to take
       * into account driving difficulties, such as narrow streets and congestion.
       * The travel time modifier enables to increase the travel times around a
       * location. It is describes by three values. The value by which multiply
       * the travel times around the location (tsDepotTravelTimeModifierValue),
       * the portion of the travel time on which the modifier applies
       * (tsDepotTravelTimeModifierLength) an offset to add to any travel duration
       * leaving or reaching the location (tsDepotTravelTimeModifierOffSet).
       * 
       * **Example : **
       * 
       * * Set tsResource travelTimeModifierValue to 1.5,
       * tsResource travelTimeModifierLength to 300 and
       * tsResource travelTimeModifierOffSet to 60 for Resource 1
       * 
       * * Set tsDepot travelTimeModifierValue to 2,
       * tsDepot travelTimeModifierLength to 420 and
       * tsDepot travelTimeModifierOffSet to 0 for Depot 1 If the initial travel
       * duration between Resource 1 and Depot 1 was 1000, one obtains a travel
       * time 360 * 1.5 + 60 + 280 + 420 * 2 + 0 = 1660
       * 
       * **Type : ** float, **Default : ** 1
     *
     * @param \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTravelTimeModifier $travelTimeModifier
     */
    public function setTravelTimeModifier($travelTimeModifier)
    {
        $this->travelTimeModifier = $travelTimeModifier;
    }
    /**
     * The fixed duration for a resource to load at depot. Use this constraint
       * to specify how long takes any resource reload at the depot. You can
       * specify an additional duration according to the quantity to reload,
       * using loadingDurationPerUnit.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** &quot;00:00:00&quot;.
       * 
       * **Example : **
       * 
       * tsDepot fixedVisitDuration = &quot;00:30:00&quot; indicates that 30 minutes are
       * needed to load at the depot. tsDepot loadingDurationPerUnit = 120
       * indicates that 120 seconds are needed to load one unit. If the quantity to
       * reload is 8, for instance, the variable part is 120*8. 16 minutes are
       * required to load at the depot. Total load time = 30 minutes + 16 minutes
       * = 46 minutes accounted for this reload break.
     *
     * @return string
     */
    public function getFixedLoadingDuration()
    {
        return $this->fixedLoadingDuration;
    }

    /**
     * The fixed duration for a resource to load at depot. Use this constraint
       * to specify how long takes any resource reload at the depot. You can
       * specify an additional duration according to the quantity to reload,
       * using loadingDurationPerUnit.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime. **Default : ** &quot;00:00:00&quot;.
       * 
       * **Example : **
       * 
       * tsDepot fixedVisitDuration = &quot;00:30:00&quot; indicates that 30 minutes are
       * needed to load at the depot. tsDepot loadingDurationPerUnit = 120
       * indicates that 120 seconds are needed to load one unit. If the quantity to
       * reload is 8, for instance, the variable part is 120*8. 16 minutes are
       * required to load at the depot. Total load time = 30 minutes + 16 minutes
       * = 46 minutes accounted for this reload break.
     *
     * @param string $fixedLoadingDuration
     */
    public function setFixedLoadingDuration($fixedLoadingDuration)
    {
        $this->fixedLoadingDuration = $fixedLoadingDuration;
    }
    /**
     * The time needed to load a unit of product. This constraint is added to
       * the fixed part of the loading duration: it depends on the total quantity
       * to load.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime, Integer (number of seconds). **Default : ** 0.
     *
     * @return string
     */
    public function getLoadingDurationPerUnit()
    {
        return $this->loadingDurationPerUnit;
    }

    /**
     * The time needed to load a unit of product. This constraint is added to
       * the fixed part of the loading duration: it depends on the total quantity
       * to load.
       * 
       * **Type : ** &quot;hh:mm:ss&quot;, DateTime, Integer (number of seconds). **Default : ** 0.
     *
     * @param string $loadingDurationPerUnit
     */
    public function setLoadingDurationPerUnit($loadingDurationPerUnit)
    {
        $this->loadingDurationPerUnit = $loadingDurationPerUnit;
    }
    /**
     * Depot priority.
       * 
       * Use this constraint to specify a priority on the depot. If two depots are nearby the system considers the one with the highest priority
       * 
       * **Type : * integer
     *
     * @return integer
     */
    public function getPriority()
    {
        return $this->priority;
    }

    /**
     * Depot priority.
       * 
       * Use this constraint to specify a priority on the depot. If two depots are nearby the system considers the one with the highest priority
       * 
       * **Type : * integer
     *
     * @param integer $priority
     */
    public function setPriority($priority)
    {
        $this->priority = $priority;
    }
    /**
     * The list of the products a depots contains.
       * 
       * Use this constraint when a depot must be affected to a specific
       * kind of resource: these resources will have to provide the required
       * required to be able to load at the depot.
       * 
       * **Type : ** string (as a list of products separated with commas).
       * 
       * **Default : ** none
     *
     * @return string
     */
    public function getRequiredProducts()
    {
        return $this->requiredProducts;
    }

    /**
     * The list of the products a depots contains.
       * 
       * Use this constraint when a depot must be affected to a specific
       * kind of resource: these resources will have to provide the required
       * required to be able to load at the depot.
       * 
       * **Type : ** string (as a list of products separated with commas).
       * 
       * **Default : ** none
     *
     * @param string $requiredProducts
     */
    public function setRequiredProducts($requiredProducts)
    {
        $this->requiredProducts = $requiredProducts;
    }
    /**
     * Indicates whether a resource must provide all required products or one at least.
       * 
       * Set it to True to indicate that a resource must provide all the depot required
       * products. Set it to False to indicate that a resource must provide at least one
       * of the depot required products.
       * 
       * **Type : ** boolean **Default : ** True
     *
     * @return boolean
     */
    public function getAllProductsRequired()
    {
        return $this->allProductsRequired;
    }

    /**
     * Indicates whether a resource must provide all required products or one at least.
       * 
       * Set it to True to indicate that a resource must provide all the depot required
       * products. Set it to False to indicate that a resource must provide at least one
       * of the depot required products.
       * 
       * **Type : ** boolean **Default : ** True
     *
     * @param boolean $allProductsRequired
     */
    public function setAllProductsRequired($allProductsRequired)
    {
        $this->allProductsRequired = $allProductsRequired;
    }
    /**
     * The available quantities of products available at the depot.
       * 
       * You can specify up to 24 quantities
       * 
       * **Type : ** float array
     *
     * @return integer[]
     */
    public function getDeliveryQuantities()
    {
        return $this->deliveryQuantities;
    }

    /**
     * The available quantities of products available at the depot.
       * 
       * You can specify up to 24 quantities
       * 
       * **Type : ** float array
     *
     * @param integer[] $deliveryQuantities
     */
    public function setDeliveryQuantities($deliveryQuantities)
    {
        $this->deliveryQuantities = $deliveryQuantities;
    }
    /**
     * The available space for a product available at the depot.
       * 
       * You can specify up to 24 values.
       * 
       * **Type : ** float array
     *
     * @return integer[]
     */
    public function getPickupQuantities()
    {
        return $this->pickupQuantities;
    }

    /**
     * The available space for a product available at the depot.
       * 
       * You can specify up to 24 values.
       * 
       * **Type : ** float array
     *
     * @param integer[] $pickupQuantities
     */
    public function setPickupQuantities($pickupQuantities)
    {
        $this->pickupQuantities = $pickupQuantities;
    }
    /**
     * longitude WGS84 of depot
     *
     * @return double
     */
    public function getX()
    {
        return $this->x;
    }

    /**
     * longitude WGS84 of depot
     *
     * @param double $x
     */
    public function setX($x)
    {
        $this->x = $x;
    }
    /**
     * latitude WGS84 of depot
     *
     * @return double
     */
    public function getY()
    {
        return $this->y;
    }

    /**
     * latitude WGS84 of depot
     *
     * @param double $y
     */
    public function setY($y)
    {
        $this->y = $y;
    }

    /**
     * Sets a known child element of TSDepot from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'id') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->id = $child;
            $happened = true;
        }
        else if (($xml->localName == 'openingDays') && (empty($xml->namespaceURI)) && (!$xml->isEmptyElement)) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc. in the wrapper
                }
        if (($xml->localName == 'openingDaysList') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->openingDaysList)) {
                $this->openingDaysList = array();
            }
            array_push($this->openingDaysList, $child);
            $happened = true;
        }
                $xml->read();
            }
            $happened = true;
        }
        else if (($xml->localName == 'timeWindows') && (empty($xml->namespaceURI)) && (!$xml->isEmptyElement)) {
            $xml->read();
            while ($xml->nodeType != \XMLReader::END_ELEMENT) {
                if ($xml->nodeType != \XMLReader::ELEMENT) {
                    //no-op: skip any insignificant whitespace, comments, etc. in the wrapper
                }
        if (($xml->localName == 'TSTimeWindow') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTimeWindow($xml);
            if (!isset($this->timeWindows)) {
                $this->timeWindows = array();
            }
            array_push($this->timeWindows, $child);
            $happened = true;
        }
                $xml->read();
            }
            $happened = true;
        }
        else if (($xml->localName == 'availability') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->availability = $child;
            $happened = true;
        }
        else if (($xml->localName == 'resourceNames') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->resourceNames = $child;
            $happened = true;
        }
        else if (($xml->localName == 'excludeResources') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->excludeResources = $child;
            $happened = true;
        }
        else if (($xml->localName == 'travelTimeModifier') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\Toursolver\Optim\TSTravelTimeModifier($xml);
            $this->travelTimeModifier = $child;
            $happened = true;
        }
        else if (($xml->localName == 'fixedLoadingDuration') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->fixedLoadingDuration = $child;
            $happened = true;
        }
        else if (($xml->localName == 'loadingDurationPerUnit') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->loadingDurationPerUnit = $child;
            $happened = true;
        }
        else if (($xml->localName == 'priority') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->priority = $child;
            $happened = true;
        }
        else if (($xml->localName == 'requiredProducts') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->requiredProducts = $child;
            $happened = true;
        }
        else if (($xml->localName == 'allProductsRequired') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->allProductsRequired = $child;
            $happened = true;
        }
        else if (($xml->localName == 'deliveryQuantities') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->deliveryQuantities)) {
                $this->deliveryQuantities = array();
            }
            array_push($this->deliveryQuantities, $child);
            $happened = true;
        }
        else if (($xml->localName == 'pickupQuantities') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            if (!isset($this->pickupQuantities)) {
                $this->pickupQuantities = array();
            }
            array_push($this->pickupQuantities, $child);
            $happened = true;
        }
        else if (($xml->localName == 'x') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->x = $child;
            $happened = true;
        }
        else if (($xml->localName == 'y') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->y = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of TSDepot from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes the contents of this TSDepot to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->id) {
            $writer->startElementNs(null, 'id', null);
            $writer->text($this->id);
            $writer->endElement();
        }
        if ($this->openingDaysList) {
            $writer->startElementNs(null, 'openingDays', null);
            foreach ($this->openingDaysList as $i => $x) {
                $writer->startElementNs(null, 'openingDaysList', null);
                $writer->text($x);
                $writer->endElement();
            }
            $writer->endElement();
        }
        if ($this->timeWindows) {
            $writer->startElementNs(null, 'timeWindows', null);
            foreach ($this->timeWindows as $i => $x) {
                $writer->startElementNs(null, 'TSTimeWindow', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
            $writer->endElement();
        }
        if ($this->availability) {
            $writer->startElementNs(null, 'availability', null);
            $writer->text($this->availability);
            $writer->endElement();
        }
        if ($this->resourceNames) {
            $writer->startElementNs(null, 'resourceNames', null);
            $writer->text($this->resourceNames);
            $writer->endElement();
        }
        if ($this->excludeResources) {
            $writer->startElementNs(null, 'excludeResources', null);
            $writer->text($this->excludeResources);
            $writer->endElement();
        }
        if ($this->travelTimeModifier) {
            $writer->startElementNs(null, 'travelTimeModifier', null);
            $this->travelTimeModifier->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->fixedLoadingDuration) {
            $writer->startElementNs(null, 'fixedLoadingDuration', null);
            $writer->text($this->fixedLoadingDuration);
            $writer->endElement();
        }
        if ($this->loadingDurationPerUnit) {
            $writer->startElementNs(null, 'loadingDurationPerUnit', null);
            $writer->text($this->loadingDurationPerUnit);
            $writer->endElement();
        }
        if ($this->priority) {
            $writer->startElementNs(null, 'priority', null);
            $writer->text($this->priority);
            $writer->endElement();
        }
        if ($this->requiredProducts) {
            $writer->startElementNs(null, 'requiredProducts', null);
            $writer->text($this->requiredProducts);
            $writer->endElement();
        }
        if ($this->allProductsRequired) {
            $writer->startElementNs(null, 'allProductsRequired', null);
            $writer->text($this->allProductsRequired);
            $writer->endElement();
        }
        if ($this->deliveryQuantities) {
            foreach ($this->deliveryQuantities as $i => $x) {
                $writer->startElementNs(null, 'deliveryQuantities', null);
                $writer->text($x);
                $writer->endElement();
            }
        }
        if ($this->pickupQuantities) {
            foreach ($this->pickupQuantities as $i => $x) {
                $writer->startElementNs(null, 'pickupQuantities', null);
                $writer->text($x);
                $writer->endElement();
            }
        }
        if ($this->x) {
            $writer->startElementNs(null, 'x', null);
            $writer->text($this->x);
            $writer->endElement();
        }
        if ($this->y) {
            $writer->startElementNs(null, 'y', null);
            $writer->text($this->y);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Toursolver\Model;

/**
 * (no documentation provided)
 */
class ScanStatus
{

    /**
     * 
     */
    const PICKUPFROMDEPOT = "PickupFromDepot";

    /**
     * 
     */
    const DELIVERYTOCUSTOMER = "DeliveryToCustomer";

    /**
     * 
     */
    const PICKUPFROMCUSTOMER = "PickupFromCustomer";

    /**
     * 
     */
    const PICKUPFROMCOLLEAGUE = "PickupFromColleague";

    /**
     * 
     */
    const DELIVERYTODEPOT = "DeliveryToDepot";

    /**
     * 
     */
    const DELIVERYTOCOLLEAGUE = "DeliveryToColleague";

    /**
     * 
     */
    const MISSINGINDEPOT = "MissingInDepot";

    /**
     * 
     */
    const MISSINGPARCEL = "MissingParcel";
}

namespace Com\Geoconcept\Toursolver\Export;

/**
 * (no documentation provided)
 */
class OperationalOrderSynchroStatus
{

    /**
     * 
     */
    const PUBLISHED = "PUBLISHED";

    /**
     * 
     */
    const SENT = "SENT";

    /**
     * 
     */
    const UPDATED = "UPDATED";

    /**
     * 
     */
    const UNKNOWN = "UNKNOWN";
}

namespace Com\Geoconcept\Toursolver\Export;

/**
 * (no documentation provided)
 */
class OperationalOrderType
{

    /**
     * 
     */
    const MISSION = "MISSION";

    /**
     * 
     */
    const RESTBREAK = "RESTBREAK";

    /**
     * 
     */
    const LUNCHBREAK = "LUNCHBREAK";

    /**
     * 
     */
    const WAITBREAK = "WAITBREAK";

    /**
     * 
     */
    const RELOADBREAK = "RELOADBREAK";

    /**
     * 
     */
    const START = "START";

    /**
     * 
     */
    const END = "END";

    /**
     * 
     */
    const ENDBEFORENIGHT = "ENDBEFORENIGHT";

    /**
     * 
     */
    const STARTAFTERNIGHT = "STARTAFTERNIGHT";

    /**
     * 
     */
    const BRIEFING = "BRIEFING";

    /**
     * 
     */
    const DEBRIEFING = "DEBRIEFING";

    /**
     * 
     */
    const UNKNOWN = "UNKNOWN";
}

namespace Com\Geoconcept\Toursolver\Export;

/**
 * (no documentation provided)
 */
class GlobalScanStatus
{

    /**
     * 
     */
    const PICKUPFROMDEPOT = "PickupFromDepot";

    /**
     * 
     */
    const PARTIALLYPICKUPFROMDEPOT = "PartiallyPickupFromDepot";

    /**
     * 
     */
    const DELIVERYTOCUSTOMER = "DeliveryToCustomer";

    /**
     * 
     */
    const PARTIALLYDELIVERYTOCUSTOMER = "PartiallyDeliveryToCustomer";

    /**
     * 
     */
    const DELIVERYTOCOLLEAGUE = "DeliveryToColleague";

    /**
     * 
     */
    const MISSINGINDEPOT = "MissingInDepot";
}

namespace Com\Geoconcept\Toursolver\Export;

/**
 * (no documentation provided)
 */
class OperationalLastKnownPosition extends \Com\Geoconcept\Common\Persistence\PersistentObject
{

    /**
     * last position recording date
     *
     * @var integer
     */
    private $date;

    /**
     * Longitude
     *
     * @var double
     */
    private $lon;

    /**
     * Latitude
     *
     * @var double
     */
    private $lat;

    /**
     * GPS positioning accuracy (radius in meters)
     *
     * @var double
     */
    private $accuracy;

    /**
     * Private life status in Mobile App.
     * If true, it means that mobile App is currently in Private life mode,
     * therefore this position is the last known position before the Private life switch.
     *
     * @var boolean
     */
    private $privateLife;

    /**
     * GPS status of the device
     *
     * @var string
     */
    private $gpsStatus;

    /**
     * Battery level of the device
     *
     * @var integer
     */
    private $batteryLevel;

    /**
     * Constructs a OperationalLastKnownPosition from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * last position recording date
     *
     * @return integer
     */
    public function getDate()
    {
        return $this->date;
    }

    /**
     * last position recording date
     *
     * @param integer $date
     */
    public function setDate($date)
    {
        $this->date = $date;
    }
    /**
     * Longitude
     *
     * @return double
     */
    public function getLon()
    {
        return $this->lon;
    }

    /**
     * Longitude
     *
     * @param double $lon
     */
    public function setLon($lon)
    {
        $this->lon = $lon;
    }
    /**
     * Latitude
     *
     * @return double
     */
    public function getLat()
    {
        return $this->lat;
    }

    /**
     * Latitude
     *
     * @param double $lat
     */
    public function setLat($lat)
    {
        $this->lat = $lat;
    }
    /**
     * GPS positioning accuracy (radius in meters)
     *
     * @return double
     */
    public function getAccuracy()
    {
        return $this->accuracy;
    }

    /**
     * GPS positioning accuracy (radius in meters)
     *
     * @param double $accuracy
     */
    public function setAccuracy($accuracy)
    {
        $this->accuracy = $accuracy;
    }
    /**
     * Private life status in Mobile App.
       * If true, it means that mobile App is currently in Private life mode,
       * therefore this position is the last known position before the Private life switch.
     *
     * @return boolean
     */
    public function getPrivateLife()
    {
        return $this->privateLife;
    }

    /**
     * Private life status in Mobile App.
       * If true, it means that mobile App is currently in Private life mode,
       * therefore this position is the last known position before the Private life switch.
     *
     * @param boolean $privateLife
     */
    public function setPrivateLife($privateLife)
    {
        $this->privateLife = $privateLife;
    }
    /**
     * GPS status of the device
     *
     * @return string
     */
    public function getGpsStatus()
    {
        return $this->gpsStatus;
    }

    /**
     * GPS status of the device
     *
     * @param string $gpsStatus
     */
    public function setGpsStatus($gpsStatus)
    {
        $this->gpsStatus = $gpsStatus;
    }
    /**
     * Battery level of the device
     *
     * @return integer
     */
    public function getBatteryLevel()
    {
        return $this->batteryLevel;
    }

    /**
     * Battery level of the device
     *
     * @param integer $batteryLevel
     */
    public function setBatteryLevel($batteryLevel)
    {
        $this->batteryLevel = $batteryLevel;
    }

    /**
     * Sets a known child element of OperationalLastKnownPosition from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'date') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->date = $child;
            $happened = true;
        }
        else if (($xml->localName == 'lon') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->lon = $child;
            $happened = true;
        }
        else if (($xml->localName == 'lat') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->lat = $child;
            $happened = true;
        }
        else if (($xml->localName == 'accuracy') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->accuracy = $child;
            $happened = true;
        }
        else if (($xml->localName == 'privateLife') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->privateLife = $child;
            $happened = true;
        }
        else if (($xml->localName == 'gpsStatus') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->gpsStatus = $child;
            $happened = true;
        }
        else if (($xml->localName == 'batteryLevel') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->batteryLevel = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of OperationalLastKnownPosition from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes the contents of this OperationalLastKnownPosition to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->date) {
            $writer->startElementNs(null, 'date', null);
            $writer->text($this->date);
            $writer->endElement();
        }
        if ($this->lon) {
            $writer->startElementNs(null, 'lon', null);
            $writer->text($this->lon);
            $writer->endElement();
        }
        if ($this->lat) {
            $writer->startElementNs(null, 'lat', null);
            $writer->text($this->lat);
            $writer->endElement();
        }
        if ($this->accuracy) {
            $writer->startElementNs(null, 'accuracy', null);
            $writer->text($this->accuracy);
            $writer->endElement();
        }
        if ($this->privateLife) {
            $writer->startElementNs(null, 'privateLife', null);
            $writer->text($this->privateLife);
            $writer->endElement();
        }
        if ($this->gpsStatus) {
            $writer->startElementNs(null, 'gpsStatus', null);
            $writer->text($this->gpsStatus);
            $writer->endElement();
        }
        if ($this->batteryLevel) {
            $writer->startElementNs(null, 'batteryLevel', null);
            $writer->text($this->batteryLevel);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Mycustomers\Api\Model;

/**
 * (no documentation provided)
 */
class ClientEntity extends \Com\Geoconcept\Mycustomers\Api\Model\ClientBaseEntity
{

    /**
     * (no documentation provided)
     *
     * @var array
     */
    private $customData;

    /**
     * Constructs a ClientEntity from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return array
     */
    public function getCustomData()
    {
        return $this->customData;
    }

    /**
     * (no documentation provided)
     *
     * @param array $customData
     */
    public function setCustomData($customData)
    {
        $this->customData = $customData;
    }

    /**
     * Sets a known child element of ClientEntity from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'customData') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->customData = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of ClientEntity from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes the contents of this ClientEntity to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->customData) {
            $writer->startElementNs(null, 'customData', null);
            $writer->text($this->customData);
            $writer->endElement();
        }
    }
}

namespace Com\Geoconcept\Dispatcher\Optimization;

/**
 * (no documentation provided)
 */
class OptimizeStatus
{

    /**
     * 
     */
    const UNDEFINED = "undefined";

    /**
     * 
     */
    const WAITING = "waiting";

    /**
     * 
     */
    const GEOCODING = "geocoding";

    /**
     * 
     */
    const MILEAGE_CHART_BUILDING = "mileageChartBuilding";

    /**
     * 
     */
    const RUNNING = "running";

    /**
     * 
     */
    const ABORTED = "aborted";

    /**
     * 
     */
    const TERMINATED = "terminated";

    /**
     * 
     */
    const ERROR = "error";

    /**
     * 
     */
    const SECTORIZATION_WAITING = "sectorizationWaiting";

    /**
     * 
     */
    const SECTORIZATION_RUNNING = "sectorizationRunning";

    /**
     * 
     */
    const SECTORIZATION_FINISHED = "sectorizationFinished";

    /**
     * 
     */
    const SECTORIZATION_ABORTED = "sectorizationAborted";
}

namespace Com\Geoconcept\Toursolver\Export;

/**
 * (no documentation provided)
 */
class OperationalOrder extends \Com\Geoconcept\Toursolver\Export\OperationalOrderAchievement
{

    /**
     * (no documentation provided)
     *
     * @var \Com\Geoconcept\Toursolver\Mobile\Data
     */
    private $report;

    /**
     * (no documentation provided)
     *
     * @var boolean
     */
    private $isLate;

    /**
     * (no documentation provided)
     *
     * @var integer
     */
    private $lateNotificationTimeout;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $etaOrderId;

    /**
     * Customer satisfaction data
     *
     * @var \Com\Geoconcept\Toursolver\Imminent\Model\ImminentOperationalOrderData
     */
    private $etaOrderData;

    /**
     * Distance from previous stop
     *
     * @var double
     */
    private $distance;

    /**
     * Scan informations
     *
     * @var \Com\Geoconcept\Toursolver\Model\ScanItemAchievement[]
     */
    private $scanItems;

    /**
     * Global scan status
     *
     * @var string
     */
    private $globalScanItemsStatus;

    /**
     * True is tour progress notification has been sent to customer
     *
     * @var boolean
     */
    private $tourProgressNotificationSent;

    /**
     * Total number of delivered items
     *
     * @var integer
     */
    private $numberOfDeliveredItems;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $weatherSkyDescription;

    /**
     * (no documentation provided)
     *
     * @var string
     */
    private $weatherPrecipitationDesc;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $weatherPrecipitationProbability;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $weatherTemperature;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $weatherSnowFall;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $weatherRainFall;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $weatherWindSpeed;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $weatherSnowCover;

    /**
     * (no documentation provided)
     *
     * @var double
     */
    private $weatherVisibility;

    /**
     * Constructs a OperationalOrder from an XMLReader
     *
     * @param \XMLReader $reader The reader.
     */
    public function __construct($reader = null)
    {
        $success = true;
        while ($success && $reader->nodeType != \XMLReader::ELEMENT) {
            $success = $reader->read();
        }
        if ($reader->nodeType != \XMLReader::ELEMENT) {
            throw new \Exception("Unable to read XML: no start element found.");
        }

        $this->initFromReader($reader);
    }

    /**
     * (no documentation provided)
     *
     * @return \Com\Geoconcept\Toursolver\Mobile\Data
     */
    public function getReport()
    {
        return $this->report;
    }

    /**
     * (no documentation provided)
     *
     * @param \Com\Geoconcept\Toursolver\Mobile\Data $report
     */
    public function setReport($report)
    {
        $this->report = $report;
    }
    /**
     * (no documentation provided)
     *
     * @return boolean
     */
    public function getIsLate()
    {
        return $this->isLate;
    }

    /**
     * (no documentation provided)
     *
     * @param boolean $isLate
     */
    public function setIsLate($isLate)
    {
        $this->isLate = $isLate;
    }
    /**
     * (no documentation provided)
     *
     * @return integer
     */
    public function getLateNotificationTimeout()
    {
        return $this->lateNotificationTimeout;
    }

    /**
     * (no documentation provided)
     *
     * @param integer $lateNotificationTimeout
     */
    public function setLateNotificationTimeout($lateNotificationTimeout)
    {
        $this->lateNotificationTimeout = $lateNotificationTimeout;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getEtaOrderId()
    {
        return $this->etaOrderId;
    }

    /**
     * (no documentation provided)
     *
     * @param string $etaOrderId
     */
    public function setEtaOrderId($etaOrderId)
    {
        $this->etaOrderId = $etaOrderId;
    }
    /**
     * Customer satisfaction data
     *
     * @return \Com\Geoconcept\Toursolver\Imminent\Model\ImminentOperationalOrderData
     */
    public function getEtaOrderData()
    {
        return $this->etaOrderData;
    }

    /**
     * Customer satisfaction data
     *
     * @param \Com\Geoconcept\Toursolver\Imminent\Model\ImminentOperationalOrderData $etaOrderData
     */
    public function setEtaOrderData($etaOrderData)
    {
        $this->etaOrderData = $etaOrderData;
    }
    /**
     * Distance from previous stop
     *
     * @return double
     */
    public function getDistance()
    {
        return $this->distance;
    }

    /**
     * Distance from previous stop
     *
     * @param double $distance
     */
    public function setDistance($distance)
    {
        $this->distance = $distance;
    }
    /**
     * Scan informations
     *
     * @return \Com\Geoconcept\Toursolver\Model\ScanItemAchievement[]
     */
    public function getScanItems()
    {
        return $this->scanItems;
    }

    /**
     * Scan informations
     *
     * @param \Com\Geoconcept\Toursolver\Model\ScanItemAchievement[] $scanItems
     */
    public function setScanItems($scanItems)
    {
        $this->scanItems = $scanItems;
    }
    /**
     * Global scan status
     *
     * @return string
     */
    public function getGlobalScanItemsStatus()
    {
        return $this->globalScanItemsStatus;
    }

    /**
     * Global scan status
     *
     * @param string $globalScanItemsStatus
     */
    public function setGlobalScanItemsStatus($globalScanItemsStatus)
    {
        $this->globalScanItemsStatus = $globalScanItemsStatus;
    }
    /**
     * True is tour progress notification has been sent to customer
     *
     * @return boolean
     */
    public function getTourProgressNotificationSent()
    {
        return $this->tourProgressNotificationSent;
    }

    /**
     * True is tour progress notification has been sent to customer
     *
     * @param boolean $tourProgressNotificationSent
     */
    public function setTourProgressNotificationSent($tourProgressNotificationSent)
    {
        $this->tourProgressNotificationSent = $tourProgressNotificationSent;
    }
    /**
     * Total number of delivered items
     *
     * @return integer
     */
    public function getNumberOfDeliveredItems()
    {
        return $this->numberOfDeliveredItems;
    }

    /**
     * Total number of delivered items
     *
     * @param integer $numberOfDeliveredItems
     */
    public function setNumberOfDeliveredItems($numberOfDeliveredItems)
    {
        $this->numberOfDeliveredItems = $numberOfDeliveredItems;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getWeatherSkyDescription()
    {
        return $this->weatherSkyDescription;
    }

    /**
     * (no documentation provided)
     *
     * @param string $weatherSkyDescription
     */
    public function setWeatherSkyDescription($weatherSkyDescription)
    {
        $this->weatherSkyDescription = $weatherSkyDescription;
    }
    /**
     * (no documentation provided)
     *
     * @return string
     */
    public function getWeatherPrecipitationDesc()
    {
        return $this->weatherPrecipitationDesc;
    }

    /**
     * (no documentation provided)
     *
     * @param string $weatherPrecipitationDesc
     */
    public function setWeatherPrecipitationDesc($weatherPrecipitationDesc)
    {
        $this->weatherPrecipitationDesc = $weatherPrecipitationDesc;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getWeatherPrecipitationProbability()
    {
        return $this->weatherPrecipitationProbability;
    }

    /**
     * (no documentation provided)
     *
     * @param double $weatherPrecipitationProbability
     */
    public function setWeatherPrecipitationProbability($weatherPrecipitationProbability)
    {
        $this->weatherPrecipitationProbability = $weatherPrecipitationProbability;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getWeatherTemperature()
    {
        return $this->weatherTemperature;
    }

    /**
     * (no documentation provided)
     *
     * @param double $weatherTemperature
     */
    public function setWeatherTemperature($weatherTemperature)
    {
        $this->weatherTemperature = $weatherTemperature;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getWeatherSnowFall()
    {
        return $this->weatherSnowFall;
    }

    /**
     * (no documentation provided)
     *
     * @param double $weatherSnowFall
     */
    public function setWeatherSnowFall($weatherSnowFall)
    {
        $this->weatherSnowFall = $weatherSnowFall;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getWeatherRainFall()
    {
        return $this->weatherRainFall;
    }

    /**
     * (no documentation provided)
     *
     * @param double $weatherRainFall
     */
    public function setWeatherRainFall($weatherRainFall)
    {
        $this->weatherRainFall = $weatherRainFall;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getWeatherWindSpeed()
    {
        return $this->weatherWindSpeed;
    }

    /**
     * (no documentation provided)
     *
     * @param double $weatherWindSpeed
     */
    public function setWeatherWindSpeed($weatherWindSpeed)
    {
        $this->weatherWindSpeed = $weatherWindSpeed;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getWeatherSnowCover()
    {
        return $this->weatherSnowCover;
    }

    /**
     * (no documentation provided)
     *
     * @param double $weatherSnowCover
     */
    public function setWeatherSnowCover($weatherSnowCover)
    {
        $this->weatherSnowCover = $weatherSnowCover;
    }
    /**
     * (no documentation provided)
     *
     * @return double
     */
    public function getWeatherVisibility()
    {
        return $this->weatherVisibility;
    }

    /**
     * (no documentation provided)
     *
     * @param double $weatherVisibility
     */
    public function setWeatherVisibility($weatherVisibility)
    {
        $this->weatherVisibility = $weatherVisibility;
    }

    /**
     * Sets a known child element of OperationalOrder from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether a child element was set.
     */
    protected function setKnownChildElement($xml) {
        $happened = parent::setKnownChildElement($xml);
        if ($happened) {
          return true;
        }
        else if (($xml->localName == 'report') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Mobile\Data($xml);
            $this->report = $child;
            $happened = true;
        }
        else if (($xml->localName == 'isLate') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->isLate = $child;
            $happened = true;
        }
        else if (($xml->localName == 'lateNotificationTimeout') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->lateNotificationTimeout = $child;
            $happened = true;
        }
        else if (($xml->localName == 'etaOrderId') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->etaOrderId = $child;
            $happened = true;
        }
        else if (($xml->localName == 'etaOrderData') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Imminent\Model\ImminentOperationalOrderData($xml);
            $this->etaOrderData = $child;
            $happened = true;
        }
        else if (($xml->localName == 'distance') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->distance = $child;
            $happened = true;
        }
        else if (($xml->localName == 'scanItems') && (empty($xml->namespaceURI))) {
            $child = new \Com\Geoconcept\Toursolver\Model\ScanItemAchievement($xml);
            if (!isset($this->scanItems)) {
                $this->scanItems = array();
            }
            array_push($this->scanItems, $child);
            $happened = true;
        }
        else if (($xml->localName == 'globalScanItemsStatus') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->globalScanItemsStatus = $child;
            $happened = true;
        }
        else if (($xml->localName == 'tourProgressNotificationSent') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->tourProgressNotificationSent = $child;
            $happened = true;
        }
        else if (($xml->localName == 'numberOfDeliveredItems') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->numberOfDeliveredItems = $child;
            $happened = true;
        }
        else if (($xml->localName == 'weatherSkyDescription') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->weatherSkyDescription = $child;
            $happened = true;
        }
        else if (($xml->localName == 'weatherPrecipitationDesc') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->weatherPrecipitationDesc = $child;
            $happened = true;
        }
        else if (($xml->localName == 'weatherPrecipitationProbability') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->weatherPrecipitationProbability = $child;
            $happened = true;
        }
        else if (($xml->localName == 'weatherTemperature') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->weatherTemperature = $child;
            $happened = true;
        }
        else if (($xml->localName == 'weatherSnowFall') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->weatherSnowFall = $child;
            $happened = true;
        }
        else if (($xml->localName == 'weatherRainFall') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->weatherRainFall = $child;
            $happened = true;
        }
        else if (($xml->localName == 'weatherWindSpeed') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->weatherWindSpeed = $child;
            $happened = true;
        }
        else if (($xml->localName == 'weatherSnowCover') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->weatherSnowCover = $child;
            $happened = true;
        }
        else if (($xml->localName == 'weatherVisibility') && (empty($xml->namespaceURI))) {
            $child = '';
            while ($xml->read() && $xml->hasValue) {
                $child = $child . $xml->value;
            }
            $this->weatherVisibility = $child;
            $happened = true;
        }
        return $happened;
    }

    /**
     * Sets a known attribute of OperationalOrder from an XML reader.
     *
     * @param \XMLReader $xml The reader.
     * @return bool Whether an attribute was set.
     */
    protected function setKnownAttribute($xml) {
        if (parent::setKnownAttribute($xml)) {
            return true;
        }

        return false;
    }

    /**
     * Writes the contents of this OperationalOrder to an XML writer. The startElement is expected to be already provided.
     *
     * @param \XMLWriter $writer The XML writer.
     */
    public function writeXmlContents($writer)
    {
        parent::writeXmlContents($writer);
        if ($this->report) {
            $writer->startElementNs(null, 'report', null);
            $this->report->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->isLate) {
            $writer->startElementNs(null, 'isLate', null);
            $writer->text($this->isLate);
            $writer->endElement();
        }
        if ($this->lateNotificationTimeout) {
            $writer->startElementNs(null, 'lateNotificationTimeout', null);
            $writer->text($this->lateNotificationTimeout);
            $writer->endElement();
        }
        if ($this->etaOrderId) {
            $writer->startElementNs(null, 'etaOrderId', null);
            $writer->text($this->etaOrderId);
            $writer->endElement();
        }
        if ($this->etaOrderData) {
            $writer->startElementNs(null, 'etaOrderData', null);
            $this->etaOrderData->writeXmlContents($writer);
            $writer->endElement();
        }
        if ($this->distance) {
            $writer->startElementNs(null, 'distance', null);
            $writer->text($this->distance);
            $writer->endElement();
        }
        if ($this->scanItems) {
            foreach ($this->scanItems as $i => $x) {
                $writer->startElementNs(null, 'scanItems', null);
                $x->writeXmlContents($writer);
                $writer->endElement();
            }
        }
        if ($this->globalScanItemsStatus) {
            $writer->startElementNs(null, 'globalScanItemsStatus', null);
            $writer->text($this->globalScanItemsStatus);
            $writer->endElement();
        }
        if ($this->tourProgressNotificationSent) {
            $writer->startElementNs(null, 'tourProgressNotificationSent', null);
            $writer->text($this->tourProgressNotificationSent);
            $writer->endElement();
        }
        if ($this->numberOfDeliveredItems) {
            $writer->startElementNs(null, 'numberOfDeliveredItems', null);
            $writer->text($this->numberOfDeliveredItems);
            $writer->endElement();
        }
        if ($this->weatherSkyDescription) {
            $writer->startElementNs(null, 'weatherSkyDescription', null);
            $writer->text($this->weatherSkyDescription);
            $writer->endElement();
        }
        if ($this->weatherPrecipitationDesc) {
            $writer->startElementNs(null, 'weatherPrecipitationDesc', null);
            $writer->text($this->weatherPrecipitationDesc);
            $writer->endElement();
        }
        if ($this->weatherPrecipitationProbability) {
            $writer->startElementNs(null, 'weatherPrecipitationProbability', null);
            $writer->text($this->weatherPrecipitationProbability);
            $writer->endElement();
        }
        if ($this->weatherTemperature) {
            $writer->startElementNs(null, 'weatherTemperature', null);
            $writer->text($this->weatherTemperature);
            $writer->endElement();
        }
        if ($this->weatherSnowFall) {
            $writer->startElementNs(null, 'weatherSnowFall', null);
            $writer->text($this->weatherSnowFall);
            $writer->endElement();
        }
        if ($this->weatherRainFall) {
            $writer->startElementNs(null, 'weatherRainFall', null);
            $writer->text($this->weatherRainFall);
            $writer->endElement();
        }
        if ($this->weatherWindSpeed) {
            $writer->startElementNs(null, 'weatherWindSpeed', null);
            $writer->text($this->weatherWindSpeed);
            $writer->endElement();
        }
        if ($this->weatherSnowCover) {
            $writer->startElementNs(null, 'weatherSnowCover', null);
            $writer->text($this->weatherSnowCover);
            $writer->endElement();
        }
        if ($this->weatherVisibility) {
            $writer->startElementNs(null, 'weatherVisibility', null);
            $writer->text($this->weatherVisibility);
            $writer->endElement();
        }
    }
}
